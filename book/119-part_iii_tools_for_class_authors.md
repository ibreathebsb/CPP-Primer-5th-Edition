---
title: Part III: Tools for Class Authors
---

<h1 id="filepos3192626">Part III: Tools for Class Authors</h1>
<p>Contents</p><ul><li><strong><a href="120-chapter_13._copy_control.html#filepos3197881">Chapter 13 Copy Control</a></strong></li><li><strong><a href="129-chapter_14._overloaded_operations_and_conversions.html#filepos3544393">Chapter 14 Overloaded Operations and Conversions</a></strong></li><li><strong><a href="141-chapter_15._objectoriented_programming.html#filepos3778984">Chapter 15 Object-Oriented Programming</a></strong></li><li><strong><a href="153-chapter_16._templates_and_generic_programming.html#filepos4150078">Chapter 16 Templates and Generic Programming</a></strong></li></ul>

<p>Classes are the central concept in C++. <a href="072-chapter_7._classes.html#filepos1741323">Chapter 7</a> began our detailed coverage of how classes are defined. That chapter covered topics fundamental to any use of classes: class scope, data hiding, and constructors. It also introduced various important class features: member functions, the implicit <code>this</code> pointer, friends, and <code>const, static</code>, and <code>mutable</code> members. In this part, we’ll extend our coverage of classes by looking at copy control, overloaded operators, inheritance, and templates.</p>
<p>As we’ve seen, in C++ classes define constructors to control what happens when objects of the class type are initialized. Classes also control what happens when objects are copied, assigned, moved, and destroyed. In this respect, C++ differs from other languages, many of which do not give class designers the ability to control these operations. <a href="120-chapter_13._copy_control.html#filepos3197881">Chapter 13</a> covers these topics. This chapter also covers two important concepts introduced by the new standard: rvalue references and move operations.</p>
<p><a href="129-chapter_14._overloaded_operations_and_conversions.html#filepos3544393">Chapter 14</a> looks at operator overloading, which allows operands of class types to be used with the built-in operators. Operator overloading is one of the ways whereby C++ lets us create new types that are as intuitive to use as are the built-in types.</p>
<p>Among the operators that a class can overload is the funtion call operator. We can “call” objects of such classes just as if they were functions. We’ll also look at new library facilities that make it easy to use different types of callable objects in a uniform way.</p>
<p>This chapter concludes by looking at another special kind of class member function—conversion operators. These operators define implicit conversions from objects of class type. The compiler applies these conversions in the same contexts—and for the same reasons—as it does with conversions among the built-in types.</p>
<p>The last two chapters in this part cover how C++ supports object-oriented and generic programming.</p>
<p><a href="141-chapter_15._objectoriented_programming.html#filepos3778984">Chapter 15</a> covers inheritance and dynamic binding. Along with data abstraction, inheritance and dynamic binding are fundamental to object-oriented programming. Inheritance makes it easier for us to define related types and dynamic binding lets us write type-indepenent code that can ignore the differences among types that are related by inheritance.</p>
<p><a href="153-chapter_16._templates_and_generic_programming.html#filepos4150078">Chapter 16</a> covers function and class templates. Templates let us write generic classes and functions that are type-independent. A number of new template-related features were introduced by the new standard: variadic templates, template type aliases, and new ways to control instantiation.</p>
<p>Writing our own object-oriented or generic types requires a fairly good understanding of C++. Fortunately, we can use object-oriented and generic types without understanding the details of how to build them. For example, the standard library uses the facilities we’ll study in <a href="141-chapter_15._objectoriented_programming.html#filepos3778984">Chapters 15</a> and <a href="153-chapter_16._templates_and_generic_programming.html#filepos4150078">16</a> extensively, and we’ve used the library types and algorithms without needing to know how they are implemented.</p>
<p>Readers, therefore, should understand that <a href="119-part_iii_tools_for_class_authors.html#filepos3192626">Part III</a> covers fairly advanced topics. Writing templates or object-oriented classes requires a good understanding of the basics of C++ and a good grasp of how to define more basic classes.</p> 

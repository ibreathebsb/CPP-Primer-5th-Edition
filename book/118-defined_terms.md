<h3 id="filepos3186257">Defined Terms</h3><ul><li><p><a href="115-12.2._dynamic_arrays.html#filepos3124364" id="filepos3186396"><strong>allocator</strong></a> Library class that allocates unconstructed memory.</p></li><li><p><a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos2993303" id="filepos3186618"><strong>dangling pointer</strong></a> A pointer that refers to memory that once had an object but no longer does. Program errors due to dangling pointers are notoriously difficult to debug.</p></li><li><p><a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos2905384" id="filepos3186948"><strong>delete</strong></a> Frees memory allocated by <code>new</code>. <code>delete p</code> frees the object and <code>delete [] p</code> frees the array to which <code>p</code> points. <code>p</code> may be null or point to memory allocated by <code>new</code>.</p></li><li><p><a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos3034110" id="filepos3187653"><strong>deleter</strong></a> Function passed to a smart pointer to use in place of <code>delete</code> when destroying the object to which the pointer is bound.</p></li><li><p><a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos2924901" id="filepos3188004"><strong>destructor</strong></a> Special member function that cleans up an object when the object goes out of scope or is deleted.</p></li><li><p><a href="113-chapter_12._dynamic_memory.html#filepos2904080" id="filepos3188274"><strong>dynamically allocated</strong></a> Object that is allocated on the free store. Objects allocated on the free store exist until they are explicitly deleted or the program terminates.</p></li><li><p><a href="113-chapter_12._dynamic_memory.html#filepos2903894" id="filepos3188604"><strong>free store</strong></a> Memory pool available to a program to hold dynamically allocated objects.</p></li><li><p><a href="113-chapter_12._dynamic_memory.html#filepos2903969" id="filepos3188850"><strong>heap</strong></a> Synonym for free store.</p></li><li><p><a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos2905091" id="filepos3189040"><strong>new</strong></a> Allocates memory from the free store. <code>new T</code> allocates and constructs an object of type <code>T</code> and returns a pointer to that object; if <code>T</code> is an array type, <code>new</code> returns a pointer to the first element in the array. Similarly, <code>new [</code> allocates <em>n</em> objects of type <code>T</code> and returns a pointer to the first element in the array. By default, the allocated object is default initialized. We may also provide optional initializers.</p></li><li><p><a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos2976074" id="filepos3190070"><strong>placement new</strong></a> Form of <code>new</code> that takes additional arguments passed in parentheses following the keyword <code>new</code>; for example, <code>new (nothrow) int</code> tells <code>new</code> that it should not throw an exception.</p></li><li><p><a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos2919362" id="filepos3190670"><strong>reference count</strong></a> Counter that tracks how many users share a common object. Used by smart pointers to know when it is safe to delete memory to which the pointers point.</p></li><li><p><a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos2906648" id="filepos3190998"><strong>shared_ptr</strong></a> Smart pointer that provides shared ownership: The object is deleted when the last <code>shared_ptr</code> pointing to that object is destroyed.</p></li><li><p><a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos2906215" id="filepos3191364"><strong>smart pointer</strong></a> Library type that acts like a pointer but can be checked to see whether it is safe to use. The type takes care of deleting memory when appropriate.</p></li><li><p><a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos2906897" id="filepos3191687"><strong>unique_ptr</strong></a> Smart pointer that provides single ownership: The object is deleted when the <code>unique_ptr</code> pointing to that object is destroyed. <code>unique_ptr</code>s cannot be directly copied or assigned.</p></li><li><p><a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos2907187" id="filepos3192162"><strong>weak_ptr</strong></a> Smart pointer that points to an object managed by a <code>shared_ptr</code>. The <code>shared_ptr</code> does not count <code>weak_ptr</code>s when deciding whether to delete its object.</p></li>
 
</ul>

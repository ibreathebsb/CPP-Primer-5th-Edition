<h3 id="filepos2442334"><a id="filepos2442367"></a>Chapter Summary</h3>
<p>The library containers are template types that holds objects of a given type. In a sequential container, elements are ordered and accessed by position. The sequential containers share a common, standardized interface: If two sequential containers offer a particular operation, then the operation has the same interface and meaning for both containers.</p>
<p>All the containers (except <code>array</code>) provide efficient dynamic memory management. We may add elements to the container without worrying about where to store the elements. The container itself manages its storage. Both <code>vector</code> and <code>string</code> provide more detailed control over memory management through their <code>reserve</code> and <code>capacity</code> members.</p>
<p>For the most part, the containers define surprisingly few operations. Containers define constructors, operations to add or remove elements, operations to determine the size of the container, and operations to return iterators to particular elements. Other useful operations, such as sorting or searching, are defined not by the container types but by the standard algorithms, which we shall cover in <a href="097-chapter_10._generic_algorithms.html#filepos2454824">Chapter 10</a>.</p>
<p>When we use container operations that add or remove elements, it is essential to remember that these operations can invalidate iterators, pointers, or references to elements in the container. Many operations that invalidate an iterator, such as <code>insert</code> or <code>erase</code>, return a new iterator that allows the programmer to maintain a position within the container. Loops that use container operations that change the size of a container should be particularly careful in their use of iterators, pointers, and references.</p>

---
title: Defined Terms
---

<h3 id="filepos5398647">Defined Terms</h3><ul><li><p><a href="182-19.6._union_a_spacesaving_class.html#filepos5315300" id="filepos5398786"><strong>anonymous union</strong></a> Unnamed union that is not used to define an object. Members of an anonymous union become members of the surrounding scope. These unions may not have member functions and may not have private or protected members.</p></li><li><p><a href="184-19.8._inherently_nonportable_features.html#filepos5356098" id="filepos5399176"><strong>bit-field</strong></a> Class member with a integral type that specifies the number of bits to allocate to the member. Bit-fields defined in consecutive order in the class are, if possible, compacted into a common integral value.</p></li><li><p><a href="182-19.6._union_a_spacesaving_class.html#filepos5323244" id="filepos5399553"><strong>discriminant</strong></a> Programming technique that uses an object to determine which actual type is held in a union at any given time.</p></li><li><p><a href="178-19.2._runtime_type_identification.html#filepos5161543" id="filepos5399838"><strong>dynamic_cast</strong></a> Operator that performs a checked cast from a base type to a derived type. When the base type has at least one virtual function, the operator checks the dynamic type of the object to which the reference <a id="filepos5400115"></a>or pointer is bound. If the object type is the same as the type of the cast (or a type derived from that type), then the cast is done. Otherwise, a zero pointer is returned for a pointer cast, or an exception is thrown for a cast to a reference type.</p></li><li><p><a href="179-19.3._enumerations.html#filepos5202609" id="filepos5400473"><strong>enumeration</strong></a> Type that groups a set of named integral constants.</p></li><li><p><a href="179-19.3._enumerations.html#filepos5203408" id="filepos5400698"><strong>enumerator</strong></a> Member of an enumeration. Enumerators are <code>const</code> and may be used where integral constant expressions are required.</p></li><li><p><a href="177-19.1._controlling_memory_allocation.html#filepos5145004" id="filepos5401047"><strong>free</strong></a> Low-level memory deallocation function defined in <code>cstdlib</code>. <code>free</code> may be used <em>only</em> to free memory allocated by <code>malloc</code>.</p></li><li><p><a href="184-19.8._inherently_nonportable_features.html#filepos5377973" id="filepos5401528"><strong>linkage directive</strong></a> Mechanism used to allow functions written in a different language to be called from a C++ program. All compilers must support calling C and C++ functions. It is compiler dependent whether any other languages are supported.</p></li><li><p><a href="183-19.7._local_classes.html#filepos5346776" id="filepos5401930"><strong>local class</strong></a> Class defined inside a function. A local class is visible only inside the function in which it is defined. All members of the class must be defined inside the class body. There can be no <code>static</code> members of a local class. Local class members may not access the non<code>static</code> variables defined in the enclosing function. They may use type names, <code>static</code> variables, or enumerators defined in the enclosing function.</p></li><li><p><a href="177-19.1._controlling_memory_allocation.html#filepos5145826" id="filepos5402699"><strong>malloc</strong></a> Low-level memory allocation function defined in <code>cstdlib</code>. Memory allocated by <code>malloc</code> must be freed by <code>free</code>.</p></li><li><p><a href="180-19.4._pointer_to_class_member.html#filepos5277688" id="filepos5403163"><strong>mem_fn</strong></a> Library class template that generates a callable object from a given pointer to member function.</p></li><li><p><a href="181-19.5._nested_classes.html#filepos5285215" id="filepos5403428"><strong>nested class</strong></a> Class defined inside another class. A nested class is defined inside its enclosing scope: Nested-class names must be unique within the class scope in which they are defined but can be reused in scopes outside the enclosing class. Access to the nested class outside the enclosing class requires use of the scope operator to specify the scope(s) in which the class is nested.</p></li><li><p><a href="181-19.5._nested_classes.html#filepos5285312" id="filepos5403976"><strong>nested type</strong></a> Synonym for nested class.</p></li><li><p><a href="184-19.8._inherently_nonportable_features.html#filepos5355004" id="filepos5404175"><strong>nonportable</strong></a> Features that are inherently machine specific and may require change when a program is ported to another machine or compiler.</p></li><li><p><a href="177-19.1._controlling_memory_allocation.html#filepos5129440" id="filepos5404474"><strong>operator delete</strong></a> Library function that frees untyped, unconstructed memory allocated by <code>operator new</code>. The library <code>operator delete[]</code> frees memory used to hold an array that was allocated by <code>operator new[]</code>.</p></li><li><p><a href="177-19.1._controlling_memory_allocation.html#filepos5127298" id="filepos5405028"><strong>operator new</strong></a> Library function that allocates untyped, unconstructed memory of a given size. The library function <code>operator new[]</code> allocates raw memory for arrays. These library functions provide a more primitive allocation mechanism than the library <code>allocator</code> class. Modern C++ programs should use the <code>allocator</code> classes rather than these library functions.</p></li><li><p><strong>placement new expression</strong> Form of <code>new</code> that constructs its object in specified memory. It does no allocation; instead, it takes an argument that specifies where the object should be constructed. It is a lower-level analog of the behavior provided by the <code>construct</code> member of the <code>allocator</code> class.</p></li><li><p><a href="180-19.4._pointer_to_class_member.html#filepos5224670" id="filepos5406339"><strong>pointer to member</strong></a> Pointer that encapsulates the class type as well as the member type to which the pointer points. The definition of a pointer to member must specify the class name as well as the type of the member(s) to which the pointer may point:</p></li>

```c++
T C::*pmem = &C::member;
```

<li><p>This statement defines <code>pmem</code> as a pointer that can point to members of the class named <code>C</code> that have type <code>T</code> and initializes <code>pmem</code> to point to the member in <code>C</code> named <code>member</code>. To use the pointer, we must supply an object or pointer to type <code>C</code>:</p></li>

```c++
classobj.*pmem;
classptr->*pmem;
```

<li><p><a id="filepos5407864"></a>fetches <code>member</code> from the object <code>classobj</code> of the object pointed to by <code>classptr</code>.</p></li><li><p><a href="178-19.2._runtime_type_identification.html#filepos5158858" id="filepos5408238"><strong>run-time type identification</strong></a> Language and library facilities that allow the dynamic type of a reference or pointer to be obtained at run time. The RTTI operators, <code>typeid</code> and <code>dynamic_cast</code>, provide the dynamic type only for references or pointers to class types with virtual functions. When applied to other types, the type returned is the static type of the reference or pointer.</p></li><li><p><a href="179-19.3._enumerations.html#filepos5203043" id="filepos5408904"><strong>scoped enumeration</strong></a> New-style enumeration in which the enumerator are not accessible directly in the surrounding scope.</p></li><li><p><a href="178-19.2._runtime_type_identification.html#filepos5171166" id="filepos5409184"><strong>typeid operator</strong></a> Unary operator that returns a reference to an object of the library type named <code>type_info</code> that describes the type of the given expression. When the expression is an object of a type that has virtual functions, then the dynamic type of the expression is returned; such expressions are evaluated at run time. If the type is a reference, pointer, or other type that does not define virtual functions, then the type returned is the static type of the reference, pointer, or object; such expressions are not evaluated.</p></li><li><p><a href="178-19.2._runtime_type_identification.html#filepos5196040" id="filepos5409937"><strong>type_info</strong></a> Library type returned by the <code>typeid</code> operator. The <code>type_info</code> class is inherently machine dependent, but must provide a small set of operations, including a <code>name</code> function that returns a character string representing the typeâ€™s name. <code>type_info</code> objects may not be copied, moved, or assigned.</p></li><li><p><a href="182-19.6._union_a_spacesaving_class.html#filepos5306836" id="filepos5410654"><strong>union</strong></a> Classlike aggregate type that may define multiple data members, only one of which can have a value at any one point. Unions may have member functions, including constructors and destructors. A union may not serve as a base class. Under the new standard, unions can have members that are class types that define their own copy-control members. Such unions obtain deleted copy control if they do not themselves define the corresponding copy-control functions.</p></li><li><p><a href="179-19.3._enumerations.html#filepos5204446" id="filepos5411279"><strong>unscoped enumeration</strong></a> Enumeration in which the enumerators are accessible in the surrounding scope.</p></li><li><p><a href="184-19.8._inherently_nonportable_features.html#filepos5365974" id="filepos5411539"><strong>volatile</strong></a> Type qualifier that signifies to the compiler that a variable might be changed outside the direct control of the program. It is a signal to the compiler that it may not perform certain optimizations.</p></li>
 
</ul>

<h3 id="filepos649069"><a id="filepos649102"></a>3.2. Library <code>string</code> Type</h3>
<img alt="Image" src="/images/00009.jpg"/>
<p>A <code>string</code> is a variable-length sequence of characters. To use the <code>string</code> type, we must include the <code>string</code> header. Because it is part of the library, <code>string</code> is defined in the <code>std</code> namespace. Our examples assume the following code:</p>

```c++
#include <string>
using std::string;
```

<p>This section describes the most common <code>string</code> operations; § <a href="093-9.5._additional_string_operations.html#filepos2373261">9.5</a> (p. <a href="093-9.5._additional_string_operations.html#filepos2373261">360</a>) will cover additional operations.</p>

::: info
<p>In addition to specifying the operations that the library types provide, the standard also imposes efficiency requirements on implementors. As a result, library types are efficient enough for general use.</p>
:::

<h4 id="filepos651083">3.2.1. Defining and Initializing <code>string</code>s</h4>
<img alt="Image" src="/images/00009.jpg"/>
<p>Each class defines how objects of its type can be initialized. A class may define many different ways to initialize objects of its type. Each way must be distinguished from the others either by the number of initializers that we supply, or by the types of those initializers. <a href="031-3.2._library_string_type.html#filepos653301">Table 3.1</a> lists the most common ways to initialize <code>string</code>s. Some examples:</p>

```c++
string s1;            // default initialization; s1 is the empty string
string s2 = s1;       // s2 is a copy of  s1
string s3 = "hiya";   // s3 is a copy of the string literal
string s4(10, 'c');   // s4 is cccccccccc
```

<p><a id="filepos653301"></a>Table 3.1. Ways to Initialize a <code>string</code></p>

| Statement             | Explanation                                                        |
|-----------------------|--------------------------------------------------------------------|
| `string s1`           | Default initialization; `s1` is the empty string.                  |
| `string s2(s1)`       | `s2` is a copy of `s1`.                                            |
| `string s2 = s1`      | Equivalent to `s2(s1)`, `s2` is a copy of `s1`.                    |
| `string s3("value")`  | `s3` is a copy of the string literal, not including the null.      |
| `string s3 = "value"` | Equivalent to `s3("value")`, `s3` is a copy of the string literal. |
| `string s4(n, 'c')`   | Initialize `s4` with `n` copies of the character `'c'` .           |

<p>We can default initialize a <code>string</code> (§ <a href="022-2.2._variables.html#filepos350704">2.2.1</a>, p. <a href="022-2.2._variables.html#filepos350704">44</a>), which creates an empty <code>string</code>; that is, a <code>string</code> with no characters. When we supply a string literal (§ <a href="021-2.1._primitive_builtin_types.html#filepos326709">2.1.3</a>, p. <a href="021-2.1._primitive_builtin_types.html#filepos326709">39</a>), the characters from that literal—up to but not including the null character at the end of the literal—are copied into the newly created <code>string</code>. When we supply a count and a character, the <code>string</code> contains that many copies of the given character.</p>
<h5>Direct and Copy Forms of Initialization</h5>
<p>In § <a href="022-2.2._variables.html#filepos350704">2.2.1</a> (p. <a href="022-2.2._variables.html#filepos350704">43</a>) we saw that C++ has several different forms of initialization. Using <code>string</code>s, we can start to understand how these forms differ from one another. When we initialize a variable using <code>=</code>, we are asking the compiler to <strong><a href="037-defined_terms.html#filepos980347" id="filepos655091">copy initialize</a></strong> the object by copying the initializer on the right-hand side into the object being created. Otherwise, when we omit the <code>=</code>, we use <strong><a href="037-defined_terms.html#filepos981163" id="filepos655361">direct initialization</a></strong>.</p>
<p>When we have a single initializer, we can use either the direct or copy form of initialization. When we initialize a variable from more than one value, such as in the initialization of <code>s4</code> above, we must use the direct form of initialization:</p>

```c++
string s5 = "hiya";  // copy initialization
string s6("hiya");   // direct initialization
string s7(10, 'c');  // direct initialization; s7 is cccccccccc
```

<p><a id="filepos656741"></a>When we want to use several values, we can indirectly use the copy form of initialization by explicitly creating a (temporary) object to copy:</p>

```c++
string s8 = string(10, 'c'); // copy initialization; s8 is cccccccccc
```

<p>The initializer of <code>s8</code>—<code>string(10, 'c')</code>—creates a <code>string</code> of the given size and character value and then copies that value into <code>s8</code>. It is as if we had written</p>

```c++
string temp(10, 'c'); // temp is cccccccccc
string s8 = temp;     // copy temp into s8
```

<p>Although the code used to initialize <code>s8</code> is legal, it is less readable and offers no compensating advantage over the way we initialized <code>s7</code>.</p>
<h4 id="filepos659212">3.2.2. Operations on <code>string</code>s</h4>
<img alt="Image" src="/images/00009.jpg"/>
<p>Along with defining how objects are created and initialized, a class also defines the operations that objects of the class type can perform. A class can define operations that are called by name, such as the <code>isbn</code> function of our <code>Sales_item</code> class (§ <a href="015-1.5._introducing_classes.html#filepos237516">1.5.2</a>, p. <a href="015-1.5._introducing_classes.html#filepos237516">23</a>). A class also can define what various operator symbols, such as <code>&lt;&lt;</code> or <code>+</code>, mean when applied to objects of the class’ type. <a href="031-3.2._library_string_type.html#filepos660463">Table 3.2</a> (overleaf) lists the most common <code>string</code> operations.</p>
<p><a id="filepos660463"></a>Table 3.2. <code>string</code> Operations</p>

| Expression            | Explanation                                                                                          |
|-----------------------|------------------------------------------------------------------------------------------------------|
| `os << s`             | Writes `s` onto output stream `os`. Returns `os`.                                                    |
| `is >> s`             | Reads whitespace-separated string from `is` into `s`. Returns `is`.                                  |
| `getline(is, s)`      | Reads a line of input from `is` into `s`. Returns `is`.                                              |
| `s.empty()`           | Returns `true` if `s` is empty; otherwise returns `false`.                                           |
| `s.size()`            | Returns the number of characters in `s`.                                                             |
| `s[n]`                | Returns a reference to the char at position `n` in `s`; positions start at 0.                        |
| `s1 + s2`             | Returns a string that is the concatenation of `s1` and `s2`.                                         |
| `s1 = s2`             | Replaces characters in `s1` with a copy of `s2`.                                                     |
| `s1 == s2` `s1 != s2` | The strings `s1` and `s2` are equal if they contain the same characters. Equality is case-sensitive. |
| `<, <=, >, >=`        | Comparisons are case-sensitive and use dictionary ordering.                                          |

<h5>Reading and Writing <code>string</code>s</h5>
<p>As we saw in <a href="010-chapter_1._getting_started.html#filepos113276">Chapter 1</a>, we use the <code>iostream</code> library to read and write values of built-in types such as <code>int</code>, <code>double</code>, and so on. We use the same IO operators to read and write <code>string</code>s:</p>

```c++
// Note: #include and using declarations must be added to compile this code
int main()
{
    string s;          // empty string
    cin >> s;          // read a whitespace-separated string into s
    cout << s << endl; // write s to the output
    return 0;
}
```

<p><a id="filepos663014"></a>This program begins by defining an empty <code>string</code> named <code>s</code>. The next line reads the standard input, storing what is read in <code>s</code>. The <code>string</code> input operator reads and discards any leading whitespace (e.g., spaces, newlines, tabs). It then reads characters until the next whitespace character is encountered.</p>
<p>So, if the input to this program is <code>Hello World!</code> (note leading and trailing spaces), then the output will be <code>Hello</code> with no extra spaces.</p>
<p>Like the input and output operations on the built-in types, the <code>string</code> operators return their left-hand operand as their result. Thus, we can chain together multiple reads or writes:</p>

```c++
string s1, s2;
cin >> s1 >> s2; // read first input into s1, second into s2
cout << s1 << s2 << endl; // write both strings
```

<p>If we give this version of the program the same input, <code>Hello World!</code>, our output would be “<code>HelloWorld!</code>”</p>
<h5>Reading an Unknown Number of <code>string</code>s</h5>
<p>In § <a href="014-1.4._flow_of_control.html#filepos191453">1.4.3</a> (p. <a href="014-1.4._flow_of_control.html#filepos191453">14</a>) we wrote a program that read an unknown number of <code>int</code> values. We can write a similar program that reads <code>string</code>s instead:</p>

```c++
int main()
{
    string word;
    while (cin >> word)       // read until end-of-file
        cout << word << endl; // write each word followed by a new line
    return 0;
}
```

<p>In this program, we read into a <code>string</code>, not an <code>int</code>. Otherwise, the <code>while</code> condition executes similarly to the one in our previous program. The condition tests the stream after the read completes. If the stream is valid—it hasn’t hit end-of-file <a id="filepos667577"></a>or encountered an invalid input—then the body of the <code>while</code> is executed. The body prints the value we read on the standard output. Once we hit end-of-file (or invalid input), we fall out of the <code>while</code>.</p>
<h5>Using <code>getline</code> to Read an Entire Line</h5>
<p>Sometimes we do not want to ignore the whitespace in our input. In such cases, we can use the <code>getline</code> function instead of the <code>&gt;&gt;</code> operator. The <code>getline</code> function takes an input stream and a <code>string</code>. This function reads the given stream up to and including the first newline and stores what it read—<em>not including</em> the newline—in its <code>string</code> argument. After <code>getline</code> sees a newline, even if it is the first character in the input, it stops reading and returns. If the first character in the input is a newline, then the resulting <code>string</code> is the empty <code>string</code>.</p>
<p>Like the input operator, <code>getline</code> returns its <code>istream</code> argument. As a result, we can use <code>getline</code> as a condition just as we can use the input operator as a condition (§ <a href="014-1.4._flow_of_control.html#filepos191453">1.4.3</a>, p. <a href="014-1.4._flow_of_control.html#filepos191453">14</a>). For example, we can rewrite the previous program that wrote one word per line to write a line at a time instead:</p>

```c++
int main()
{
    string line;
    // read input a line at a time until end-of-file
    while (getline(cin, line))
        cout << line << endl;
    return 0;
}
```

<p>Because <code>line</code> does not contain a newline, we must write our own. As usual, we use <code>endl</code> to end the current line and flush the buffer.</p>

::: info
<p>The newline that causes <code>getline</code> to return is discarded; the newline is <em>not</em> stored in the <code>string</code>.</p>
:::

<h5>The <code>string empty</code> and <code>size</code> Operations</h5>
<p>The <code>empty</code> function does what one would expect: It returns a <code>bool</code> (§ <a href="021-2.1._primitive_builtin_types.html#filepos288112">2.1</a>, p. <a href="021-2.1._primitive_builtin_types.html#filepos288112">32</a>) indicating whether the <code>string</code> is empty. Like the <code>isbn</code> member of <code>Sales_item</code> (§ <a href="015-1.5._introducing_classes.html#filepos237516">1.5.2</a>, p. <a href="015-1.5._introducing_classes.html#filepos237516">23</a>), <code>empty</code> is a member function of <code>string</code>. To call this function, we use the dot operator to specify the object on which we want to run the <code>empty</code> function.</p>
<p>We can revise the previous program to only print lines that are not empty:</p>

```c++
// read input a line at a time and discard blank lines
while (getline(cin, line))
    if (!line.empty())
        cout << line << endl;
```

<p>The condition uses the logical <small>NOT</small> operator (the <a href="037-defined_terms.html#filepos993484" id="filepos673879"><code>!</code>
<strong>operator</strong></a>). This operator returns the inverse of the <code>bool</code> value of its operand. In this case, the condition is <code>true</code> if <code>str</code> is not empty.</p>
<p><a id="filepos674460"></a>The <code>size</code> member returns the length of a <code>string</code> (i.e., the number of characters in it). We can use <code>size</code> to print only lines longer than 80 characters:</p>

```c++
string line;
// read input a line at a time and print lines that are longer than 80 characters
while (getline(cin, line))
    if (line.size() > 80)
        cout << line << endl;
```

<h5>The <code>string::size_type</code> Type</h5>
<p>It might be logical to expect that <code>size</code> returns an <code>int</code> or, thinking back to § <a href="021-2.1._primitive_builtin_types.html#filepos288881">2.1.1</a> (p. <a href="021-2.1._primitive_builtin_types.html#filepos288881">34</a>), an <code>unsigned</code>. Instead, <code>size</code> returns a <code>string::size_type</code> value. This type requires a bit of explanation.</p>
<p>The <code>string</code> class—and most other library types—defines several companion types. These companion types make it possible to use the library types in a machine-independent manner. The type <code>size_type</code> is one of these companion types. To use the <code>size_type</code> defined by <code>string</code>, we use the scope operator to say that the name <code>size_type</code> is defined in the <code>string</code> class.</p>
<p>Although we don’t know the precise type of <code>string::size_type</code>, we do know that it is an unsigned type (§ <a href="021-2.1._primitive_builtin_types.html#filepos288881">2.1.1</a>, p. <a href="021-2.1._primitive_builtin_types.html#filepos288881">32</a>) big enough to hold the size of any <code>string</code>. Any variable used to store the result from the <code>string size</code> operation should be of type <code>string::size_type</code>.</p>
<a id="filepos678006"></a><Badge type="tip" text="C++11" />
<p>Admittedly, it can be tedious to type <code>string::size_type</code>. Under the new standard, we can ask the compiler to provide the appropriate type by using <code>auto</code> or <code>decltype</code> (§ <a href="025-2.5._dealing_with_types.html#filepos544751">2.5.2</a>, p. <a href="025-2.5._dealing_with_types.html#filepos544751">68</a>):</p>

```c++
auto len = line.size(); // len has type string::size_type
```

<p>Because <code>size</code> returns an unsigned type, it is essential to remember that expressions that mix signed and unsigned data can have surprising results (§ <a href="021-2.1._primitive_builtin_types.html#filepos304094">2.1.2</a>, p. <a href="021-2.1._primitive_builtin_types.html#filepos304094">36</a>). For example, if <code>n</code> is an <code>int</code> that holds a negative value, then <code>s.size() &lt; n</code> will almost surely evaluate as <code>true</code>. It yields <code>true</code> because the negative value in <code>n</code> will convert to a large unsigned value.</p>

::: tip
<p>You can avoid problems due to conversion between <code>unsigned</code> and <code>int</code> by not using <code>int</code>s in expressions that use <code>size()</code>.</p>
:::

<h5>Comparing <code>string</code>s</h5>
<p>The <code>string</code> class defines several operators that compare <code>string</code>s. These operators work by comparing the characters of the <code>string</code>s. The comparisons are case-sensitive—upper- and lowercase versions of a letter are different characters.</p>
<p>The equality operators (<code>==</code> and <code>!=</code>) test whether two <code>string</code>s are equal or unequal, respectively. Two <code>string</code>s are equal if they are the same length and contain the same characters. The relational operators <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code> test whether one <code>string</code> is less than, less than or equal to, greater than, or greater than or equal to another. These operators use the same strategy as a (case-sensitive) dictionary:</p>

<ol>
    <li><a id="filepos682521"></a>If two <code>string</code>s have different lengths and if every character in the shorter <code>string</code> is equal to the corresponding character of the longer <code>string</code>, then the shorter <code>string</code> is less than the longer one.</li>
    <li>If any characters at corresponding positions in the two <code>string</code>s differ, then the result of the <code>string</code> comparison is the result of comparing the first character at which the <code>string</code>s differ.</li>
</ol>

<p>As an example, consider the following <code>string</code>s:</p>

```c++
string str = "Hello";
string phrase = "Hello World";
string slang  = "Hiya";
```

<p>Using rule 1, we see that <code>str</code> is less than <code>phrase</code>. By applying rule 2, we see that <code>slang</code> is greater than both <code>str</code> and <code>phrase</code>.</p>
<h5>Assignment for <code>string</code>s</h5>
<p>In general, the library types strive to make it as easy to use a library type as it is to use a built-in type. To this end, most of the library types support assignment. In the case of <code>string</code>s, we can assign one <code>string</code> object to another:</p>

```c++
string st1(10, 'c'), st2; // st1 is cccccccccc; st2 is an empty string
st1 = st2; // assignment: replace contents of st1 with a copy of st2
           // both st1 and st2 are now the empty string
```

<h5>Adding Two <code>string</code>s</h5>
<p>Adding two <code>string</code>s yields a new <code>string</code> that is the concatenation of the left-hand followed by the right-hand operand. That is, when we use the plus operator (<code>+</code>) on <code>string</code>s, the result is a new <code>string</code> whose characters are a copy of those in the left-hand operand followed by those from the right-hand operand. The compound assignment operator (<code>+=</code>) (§ <a href="014-1.4._flow_of_control.html#filepos166704">1.4.1</a>, p. <a href="014-1.4._flow_of_control.html#filepos166704">12</a>) appends the right-hand operand to the left-hand <code>string</code>:</p>

```c++
string s1  = "hello, ", s2 = "world\n";
string s3 = s1 + s2;   // s3 is hello, world\n
s1 += s2;   // equivalent to s1 = s1 + s2
```

<h5>Adding Literals and <code>string</code>s</h5>
<p>As we saw in § <a href="021-2.1._primitive_builtin_types.html#filepos304094">2.1.2</a> (p. <a href="021-2.1._primitive_builtin_types.html#filepos304094">35</a>), we can use one type where another type is expected if there is a conversion from the given type to the expected type. The <code>string</code> library lets us convert both character literals and character string literals (§ <a href="021-2.1._primitive_builtin_types.html#filepos326709">2.1.3</a>, p. <a href="021-2.1._primitive_builtin_types.html#filepos326709">39</a>) to <code>string</code>s. Because we can use these literals where a <code>string</code> is expected, we can rewrite the previous program as follows:</p>

```c++
string s1 = "hello", s2 = "world"; // no punctuation in s1 or s2
string s3 = s1 + ", " + s2 + '\n';
```

<p>When we mix <code>string</code>s and string or character literals, at least one operand to each <code>+</code> operator must be of <code>string</code> type:</p>
<p><a id="filepos690788"></a></p>

```c++
string s4 = s1 + ", ";           // ok: adding a string and a literal
string s5 = "hello" + ", ";      // error: no string operand
string s6 = s1 + ", " + "world"; // ok: each + has a string operand
string s7 = "hello" + ", " + s2; // error: can't add string literals
```

<p>The initializations of <code>s4</code> and <code>s5</code> involve only a single operation each, so it is easy to see whether the initialization is legal. The initialization of <code>s6</code> may appear surprising, but it works in much the same way as when we chain together input or output expressions (§ <a href="012-1.2._a_first_look_at_inputoutput.html#filepos136281">1.2</a>, p. <a href="012-1.2._a_first_look_at_inputoutput.html#filepos136281">7</a>). This initialization groups as</p>

```c++
string s6 = (s1 + ", ") + "world";
```

<p>The subexpression <code>s1 + ", "</code> returns a <code>string</code>, which forms the left-hand operand of the second <code>+</code> operator. It is as if we had written</p>

```c++
string tmp = s1 + ", ";  // ok: + has a string operand
s6 = tmp + "world";      // ok: + has a string operand
```

<p>On the other hand, the initialization of <code>s7</code> is illegal, which we can see if we parenthesize the expression:</p>

```c++
string s7 = ("hello" + ", ") + s2; // error: can't add string literals
```

<p>Now it should be easy to see that the first subexpression adds two string literals. There is no way to do so, and so the statement is in error.</p>

::: warning
<p>For historical reasons, and for compatibility with C, string literals are <em>not</em> standard library <code>string</code>s. It is important to remember that these types differ when you use string literals and library <code>string</code>s.</p>
:::

::: info
<p>Exercises Section 3.2.2</p>
<p><strong>Exercise 3.2:</strong> Write a program to read the standard input a line at a time. Modify your program to read a word at a time.</p>
<p><strong>Exercise 3.3:</strong> Explain how whitespace characters are handled in the <code>string</code> input operator and in the <code>getline</code> function.</p>
<p><strong>Exercise 3.4:</strong> Write a program to read two <code>string</code>s and report whether the <code>string</code>s are equal. If not, report which of the two is larger. Now, change the program to report whether the <code>string</code>s have the same length, and if not, report which is longer.</p>
<p><strong>Exercise 3.5:</strong> Write a program to read <code>string</code>s from the standard input, concatenating what is read into one large <code>string</code>. Print the concatenated <code>string</code>. Next, change the program to separate adjacent input <code>string</code>s by a space.</p>
:::

<h4 id="filepos697807">3.2.3. Dealing with the Characters in a <code>string</code></h4>
<img alt="Image" src="/images/00009.jpg"/>
<p>Often we need to deal with the individual characters in a <code>string</code>. We might want to check to see whether a <code>string</code> contains any whitespace, or to change the characters to lowercase, or to see whether a given character is present, and so on.</p>
<p><a id="filepos698573"></a>One part of this kind of processing involves how we gain access to the characters themselves. Sometimes we need to process every character. Other times we need to process only a specific character, or we can stop processing once some condition is met. It turns out that the best way to deal with these cases involves different language and library facilities.</p>
<p>The other part of processing characters is knowing and/or changing the characteristics of a character. This part of the job is handled by a set of library functions, described in <a href="031-3.2._library_string_type.html#filepos699416">Table 3.3</a> (overleaf). These functions are defined in the <code>cctype</code> header.</p>
<p><a id="filepos699416"></a>Table 3.3. <code>cctype</code> Functions</p>

| Function      | Explanation                                                                                                                                 |
|---------------|---------------------------------------------------------------------------------------------------------------------------------------------|
| `isalnum(c)`  | `true` if `c` is a letter or a digit.                                                                                                       |
| `isalpha(c)`  | `true` if `c` is a letter.                                                                                                                  |
| `iscntrl(c)`  | `true` if `c` is a control character.                                                                                                       |
| `isdigit(c)`  | `true` if `c` is a digit.                                                                                                                   |
| `isgraph(c)`  | `true` if `c` is not a space but is printable.                                                                                              |
| `islower(c)`  | `true` if `c` is a lowercase letter.                                                                                                        |
| `isprint(c)`  | `true` if `c` is a printable character (i.e., a space or a character that has a visible representation).                                    |
| `ispunct(c)`  | `true` if `c` is a punctuation character (i.e., a character that is not a control character, a digit, a letter, or a printable whitespace). |
| `isspace(c)`  | `true` if `c` is whitespace (i.e., a space, tab, vertical tab, return, newline, or formfeed).                                               |
| `issuper(c)`  | `true` if `c` is an uppercase letter.                                                                                                       |
| `isxdigit(c)` | `true` if `c` is a hexadecimal digit.                                                                                                       |
| `tolower(c)`  | If `c` is an uppercase letter, returns its lowercase equivalent; otherwise returns `c` unchanged.                                           |
| `toupper(c)`  | If `c` is a lowercase letter, returns its uppercase equivalent; otherwise returns `c` unchanged.                                            |

::: info
<p>Advice: Use the C++ Versions of C Library Headers</p>
<p>In addition to facilities defined specifically for C++, the C++ library incorporates the C library. Headers in C have names of the form <em>name</em>
<code>.h</code>. The C++ versions of these headers are named <code>c</code>
<em>name</em>—they remove the <code>.h</code> suffix and precede the <em>name</em> with the letter <code>c</code>. The <code>c</code> indicates that the header is part of the C library.</p>
<p>Hence, <code>cctype</code> has the same contents as <code>ctype.h</code>, but in a form that is appropriate for C++ programs. In particular, the names defined in the <code>c</code><em>name</em> headers are defined inside the <code>std</code> namespace, whereas those defined in the <code>.h</code> versions are not.</p>
<p>Ordinarily, C++ programs should use the <code>c</code><em>name</em> versions of headers and not the <em>name</em>
<code>.h</code> versions. That way names from the standard library are consistently found in the <code>std</code> namespace. Using the <code>.h</code> headers puts the burden on the programmer to remember which library names are inherited from C and which are unique to C++.</p>
:::

<a id="filepos702111"></a><Badge type="tip" text="C++11" />
<h5>Processing Every Character? Use Range-Based <code>for</code></h5>
<p>If we want to do something to every character in a <code>string</code>, by far the best approach is to use a statement introduced by the new standard: the <strong><a href="037-defined_terms.html#filepos986496" id="filepos702652">range <code>for</code></a></strong> statement. This statement iterates through the elements in a given sequence and performs some operation on each value in that sequence. The syntactic form is</p>

```c++
for (declaration : expression)
    statement
```

<p>where <em>expression</em> is an object of a type that represents a sequence, and <em>declaration</em> defines the variable that we’ll use to access the underlying elements in the sequence. On each iteration, the variable in <em>declaration</em> is initialized from the value of the next element in <em>expression</em>.</p>
<p>A <code>string</code> represents a sequence of characters, so we can use a <code>string</code> as the <em>expression</em> in a range <code>for</code>. As a simple example, we can use a range <code>for</code> to print each character from a <code>string</code> on its own line of output:</p>

```c++
string str("some string");
// print the characters in str one character to a line
for (auto c : str)      // for every char in str
    cout << c << endl;  // print the current character followed by a newline
```

<p>The <code>for</code> loop associates the variable <code>c</code> with <code>str</code>. We define the loop control variable the same way we do any other variable. In this case, we use <code>auto</code> (§ <a href="025-2.5._dealing_with_types.html#filepos544751">2.5.2</a>, <a id="filepos705989"></a>p. <a href="025-2.5._dealing_with_types.html#filepos544751">68</a>) to let the compiler determine the type of <code>c</code>, which in this case will be <code>char</code>. On each iteration, the next character in <code>str</code> will be copied into <code>c</code>. Thus, we can read this loop as saying, “For every character <code>c</code> in the <code>string str</code>,” do something. The “something” in this case is to print the character followed by a newline.</p>
<p>As a somewhat more complicated example, we’ll use a range <code>for</code> and the <code>ispunct</code> function to count the number of punctuation characters in a <code>string</code>:</p>

```c++
string s("Hello World!!!");
// punct_cnt has the same type that s.size returns; see § 2.5.3 (p. 70)
decltype(s.size()) punct_cnt = 0;
// count the number of punctuation characters in s
for (auto c : s)        // for every char in s
    if (ispunct(c))     // if the character is punctuation
        ++punct_cnt;    // increment the punctuation counter
cout << punct_cnt
     << " punctuation characters in " << s << endl;
```

<p>The output of this program is</p>

```
3 punctuation characters in Hello World!!!
```

<p>Here we use <code>decltype</code> (§ <a href="025-2.5._dealing_with_types.html#filepos562878">2.5.3</a>, p. <a href="025-2.5._dealing_with_types.html#filepos562878">70</a>) to declare our counter, <code>punct_cnt</code>. Its type is the type returned by calling <code>s.size</code>, which is <code>string::size_type</code>. We use a range <code>for</code> to process each character in the <code>string</code>. This time we check whether each character is punctuation. If so, we use the increment operator (§ <a href="014-1.4._flow_of_control.html#filepos166704">1.4.1</a>, p. <a href="014-1.4._flow_of_control.html#filepos166704">12</a>) to add <code>1</code> to the counter. When the range <code>for</code> completes, we print the result.</p>
<h5><a id="filepos710583"></a>Using a Range <code>for</code> to Change the Characters in a <code>string</code></h5>
<p>If we want to change the value of the characters in a <code>string</code>, we must define the loop variable as a reference type (§ <a href="023-2.3._compound_types.html#filepos396246">2.3.1</a>, p. <a href="023-2.3._compound_types.html#filepos396246">50</a>). Remember that a reference is just another name for a given object. When we use a reference as our control variable, that variable is bound to each element in the sequence in turn. Using the reference, we can change the character to which the reference is bound.</p>
<p>Suppose that instead of counting punctuation, we wanted to convert a <code>string</code> to all uppercase letters. To do so we can use the library <code>toupper</code> function, which takes a character and returns the uppercase version of that character. To convert the whole <code>string</code> we need to call <code>toupper</code> on each character and put the result back in that character:</p>

```c++
string s("Hello World!!!");
// convert s to uppercase
for (auto &c : s)   // for every char in s (note: c is a reference)
    c = toupper(c); // c is a reference, so the assignment changes the char in s
cout << s << endl;
```

<p>The output of this code is</p>

```
HELLO WORLD!!!
```

<p>On each iteration, <code>c</code> refers to the next character in <code>s</code>. When we assign to <code>c</code>, we are changing the underlying character in <code>s</code>. So, when we execute</p>

```c++
c = toupper(c); // c is a reference, so the assignment changes the char in s
```

<p>we’re changing the value of the character to which <code>c</code> is bound. When this loop completes, all the characters in <code>str</code> will be uppercase.</p>
<h5>Processing Only Some Characters?</h5>
<p>A range <code>for</code> works well when we need to process every character. However, sometimes we need to access only a single character or to access characters until some condition is reached. For example, we might want to capitalize only the first character or only the first word in a <code>string</code>.</p>
<p>There are two ways to access individual characters in a <code>string</code>: We can use a subscript or an iterator. We’ll have more to say about iterators in § <a href="033-3.4._introducing_iterators.html#filepos802543">3.4</a> (p. <a href="033-3.4._introducing_iterators.html#filepos802543">106</a>) and in <a href="088-chapter_9._sequential_containers.html#filepos2171064">Chapter 9</a>.</p>
<p>The subscript operator (the <a href="037-defined_terms.html#filepos990568" id="filepos716487"><code>[ ]</code>
<strong>operator</strong></a>) takes a <code>string::size_type</code> (§ <a href="031-3.2._library_string_type.html#filepos659212">3.2.2</a>, p. <a href="031-3.2._library_string_type.html#filepos659212">88</a>) value that denotes the position of the character we want to access. The operator returns a reference to the character at the given position.</p>
<p>Subscripts for <code>string</code>s start at zero; if <code>s</code> is a <code>string</code> with at least two characters, then <code>s[0]</code> is the first character, <code>s[1]</code> is the second, and the last character is in <code>s[s.size() - 1]</code>.</p>

::: info
<p>The values we use to subscript a <code>string</code> must be <code>&gt;= 0</code> and <code>&lt; size()</code>.</p>
<p><strong>The result of using an index outside this range is undefined.</strong></p>
<p><strong>By implication, subscripting an empty <code>string</code> is undefined.</strong></p>
:::

<p><a id="filepos718762"></a>The value in the subscript is referred to as “a subscript” or “an <strong><a href="037-defined_terms.html#filepos983281" id="filepos718862">index</a></strong>.” The index we supply can be any expression that yields an integral value. However, if our index has a signed type, its value will be converted to the unsigned type that <code>string::size_type</code> represents (§ <a href="021-2.1._primitive_builtin_types.html#filepos304094">2.1.2</a>, p. <a href="021-2.1._primitive_builtin_types.html#filepos304094">36</a>).</p>
<p>The following example uses the subscript operator to print the first character in a <code>string</code>:</p>

```c++
if (!s.empty())            // make sure there's a character to print
    cout << s[0] << endl;  // print the first character in s
```

<p>Before accessing the character, we check that <code>s</code> is not empty. Any time we use a subscript, we must ensure that there is a value at the given location. If <code>s</code> is empty, then <code>s[0]</code> is undefined.</p>
<p>So long as the <code>string</code> is not <code>const</code> (§ <a href="024-2.4._const_qualifier.html#filepos462256">2.4</a>, p. <a href="024-2.4._const_qualifier.html#filepos462256">59</a>), we can assign a new value to the character that the subscript operator returns. For example, we can capitalize the first letter as follows:</p>

```c++
string s("some string");
if (!s.empty())             // make sure there's a character in s[0]
    s[0] = toupper(s[0]);   // assign a new value to the first character in s
```

<p>The output of this program is</p>

```
Some string
```

<h5>Using a Subscript for Iteration</h5>
<p>As a another example, we’ll change the first word in <code>s</code> to all uppercase:</p>

```c++
// process characters in s until we run out of characters or we hit a whitespace
for (decltype(s.size()) index = 0;
     index != s.size() && !isspace(s[index]); ++index)
        s[index] = toupper(s[index]); // capitalize the current character
```

<p>This program generates</p>

```
SOME string
```

<p>Our <code>for</code> loop (§ <a href="014-1.4._flow_of_control.html#filepos180866">1.4.2</a>, p. <a href="014-1.4._flow_of_control.html#filepos180866">13</a>) uses <code>index</code> to subscript <code>s</code>. We use <code>decltype</code> to give <code>index</code> the appropriate type. We initialize <code>index</code> to <code>0</code> so that the first iteration will start on the first character in <code>s</code>. On each iteration we increment <code>index</code> to look at the next character in <code>s</code>. In the body of the loop we capitalize the current letter.</p>
<p>The new part in this loop is the condition in the <code>for</code>. That condition uses the logical <small>AND</small> operator (the <a href="037-defined_terms.html#filepos994116" id="filepos725031"><code>&amp;&amp;</code>
<strong>operator</strong></a>). This operator yields <code>true</code> if both operands are <code>true</code> and <code>false</code> otherwise. The important part about this operator is that we are guaranteed that it evaluates its right-hand operand <em>only</em> if the left-hand operand is <code>true</code>. In this case, we are guaranteed that we will not subscript <code>s</code> unless we know that <code>index</code> is in range. That is, <code>s[index]</code> is executed only if <code>index</code> is not equal to <code>s.size()</code>. Because <code>index</code> is never incremented beyond the value of <code>s.size()</code>, we know that <code>index</code> will always be less than <code>s.size()</code>.</p>

::: warning
<a id="filepos726663"></a><p>Caution: Subscripts are Unchecked</p>
<p>When we use a subscript, we must ensure that the subscript is in range. That is, the subscript must be <code>&gt;= 0</code> and <code>&lt;</code> the <code>size()</code> of the <code>string</code>. One way to simplify code that uses subscripts is <em>always</em> to use a variable of type <code>string::size_type</code> as the subscript. Because that type is <code>unsigned</code>, we ensure that the subscript cannot be less than zero. When we use a <code>size_type</code> value as the subscript, we need to check only that our subscript is less than value returned by <code>size()</code>.</p>
<p>The library is not required to check the value of an subscript. The result of using an out-of-range subscript is undefined.</p>
:::

<h5>Using a Subscript for Random Access</h5>
<p>In the previous example we advanced our subscript one position at a time to capitalize each character in sequence. We can also calculate an subscript and directly fetch the indicated character. There is no need to access characters in sequence.</p>
<p>As an example, let’s assume we have a number between 0 and 15 and we want to generate the hexadecimal representation of that number. We can do so using a <code>string</code> that is initialized to hold the 16 hexadecimal “digits”:</p>

```c++
const string hexdigits = "0123456789ABCDEF"; // possible hex digits
cout << "Enter a series of numbers between 0 and 15"
     << " separated by spaces. Hit ENTER when finished: "
     << endl;
string result;        // will hold the resulting hexify'd string
string::size_type n;  // hold numbers from the input
while (cin >> n)
    if (n < hexdigits.size())    // ignore invalid input
        result += hexdigits[n];  // fetch the indicated hex digit
cout << "Your hex number is: " << result << endl;
```

<p>If we give this program the input</p>

```
12 0 5 15 8 15
```

<p>the output will be</p>

```
Your hex number is: C05F8F
```

<p>We start by initializing <code>hexdigits</code> to hold the hexadecimal digits <code>0</code> through <code>F</code>. We make that <code>string const</code> (§ <a href="024-2.4._const_qualifier.html#filepos462256">2.4</a>, p. <a href="024-2.4._const_qualifier.html#filepos462256">59</a>) because we do not want these values to change. Inside the loop we use the input value <code>n</code> to subscript <code>hexdigits</code>. The value of <code>hexdigits[n]</code> is the <code>char</code> that appears at position <code>n</code> in <code>hexdigits</code>. For example, if <code>n</code> is <code>15</code>, then the result is <code>F</code>; if it’s <code>12</code>, the result is <code>C</code>; and so on. We append that digit to <code>result</code>, which we print once we have read all the input.</p>
<p>Whenever we use a subscript, we should think about how we know that it is in range. In this program, our subscript, <code>n</code>, is a <code>string::size_type</code>, which as we know is an unsigned type. As a result, we know that <code>n</code> is guaranteed to be greater than or equal to <code>0</code>. Before we use <code>n</code> to subscript <code>hexdigits</code>, we verify that it is less than the <code>size</code> of <code>hexdigits</code>.</p>

::: info
<a id="filepos733750"></a><p>Exercises Section 3.2.3</p>
<p><strong>Exercise 3.6:</strong> Use a range <code>for</code> to change all the characters in a <code>string</code> to <code>X</code>.</p>
<p><strong>Exercise 3.7:</strong> What would happen if you define the loop control variable in the previous exercise as type <code>char</code>? Predict the results and then change your program to use a <code>char</code> to see if you were right.</p>
<p><strong>Exercise 3.8:</strong> Rewrite the program in the first exercise, first using a <code>while</code> and again using a traditional <code>for</code> loop. Which of the three approaches do you prefer and why?</p>
<p><strong>Exercise 3.9:</strong> What does the following program do? Is it valid? If not, why not?</p>

```c++
string s;
cout << s[0] << endl;
```

<p><strong>Exercise 3.10:</strong> Write a program that reads a string of characters including punctuation and writes what was read but with the punctuation removed.</p>
<p><strong>Exercise 3.11:</strong> Is the following range <code>for</code> legal? If so, what is the type of <code>c</code>?</p>

```c++
const string s = "Keep out!";
for (auto &c : s) { /* ...  */ }
```

:::

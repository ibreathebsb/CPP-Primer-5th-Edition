---
title: Defined Terms
---

<h3 id="filepos3534784">Defined Terms</h3><ul><li><p><a href="123-13.3._swap.html#filepos3333773" id="filepos3534923"><strong>copy and swap</strong></a> Technique for writing assignment operators by copying the right-hand operand followed by a call to <code>swap</code> to exchange the copy with the left-hand operand.</p></li><li><p><a href="120-chapter_13._copy_control.html#filepos3200563" id="filepos3535314"><strong>copy-assignment operator</strong></a> Version of the assignment operator that takes an object of the same type as its type. Ordinarily, the copy-assignment operator has a parameter that is a reference to <code>const</code> and returns a reference to its object. The compiler synthesizes the copy-assignment operator if the class does not explicitly provide one.</p></li><li><p><a href="120-chapter_13._copy_control.html#filepos3200484" id="filepos3535874"><strong>copy constructor</strong></a> Constructor that initializes a new object as a copy of another object of the same type. The copy constructor is applied implicitly to pass objects to or from a function by value. If we do not provide the copy constructor, the compiler synthesizes one for us.</p></li><li><p><a href="120-chapter_13._copy_control.html#filepos3201291" id="filepos3536311"><strong>copy control</strong></a> Special members that control what happens when objects of class type are copied, moved, assigned, and destroyed. The compiler synthesizes appropriate definitions for these operations if the class does not otherwise declare them.</p></li><li><p><a href="121-13.1._copy_assign_and_destroy.html#filepos3210850" id="filepos3536714"><strong>copy initialization</strong></a> Form of initialization used when we use <code>=</code> to supply an initializer for a newly created object. Also used when we pass or return an object by value and when we initialize an array or an aggregate class. Copy initialization uses the copy constructor or the move constructor, depending on whether the initializer is an lvalue or an rvalue.</p></li><li><p><a href="121-13.1._copy_assign_and_destroy.html#filepos3264638" id="filepos3537295"><strong>deleted function</strong></a> Function that may not be used. We delete a function by specifying <code>= delete</code> on its declaration. A common use of deleted functions is to tell the compiler not to synthesize the copy and/or move operations for a class.</p></li><li><p><a href="120-chapter_13._copy_control.html#filepos3200820" id="filepos3537752"><strong>destructor</strong></a> Special member function that cleans up an object when the object goes out of scope or is deleted. The compiler automatically destroys each data member. Members of class type are destroyed by invoking their destructor; no work is done when destroying members of built-in or compound type. In particular, the object pointed to by a pointer member is not deleted by the destructor.</p></li><li><p><a href="126-13.6._moving_objects.html#filepos3430925" id="filepos3538303"><strong>lvalue reference</strong></a> Reference that can bind to an lvalue.</p></li><li><p><a id="filepos3538519"></a><a href="121-13.1._copy_assign_and_destroy.html#filepos3205675" id="filepos3538527"><strong>memberwise copy/assign</strong></a> How the synthesized copy and move constructors and the copy- and move-assignment operators work. Taking each non<code>static</code> data member in turn, the synthesized copy or move constructor initializes each member by copying or moving the corresponding member from the given object; the copy- or move-assignment operators copy-assign or move-assign each member from the right-hand object to the left. Members of built-in or compound type are initialized or assigned directly. Members of class type are initialized or assigned by using the memberâ€™s corresponding copy/move constructor or copy-/move-assignment operator.</p></li><li><p><a href="125-13.5._classes_that_manage_dynamic_memory.html#filepos3415546" id="filepos3539390"><strong>move</strong></a> Library function used to bind an rvalue reference to an lvalue. Calling <code>move</code> implicitly promises that we will not use the moved-from object except to destroy it or assign a new value to it.</p></li><li><p><a href="120-chapter_13._copy_control.html#filepos3200729" id="filepos3539809"><strong>move-assignment operator</strong></a> Version of the assignment operator that takes an rvalue reference to its type. Typically, a move-assignment operator moves data from the right-hand operand to the left. After the assignment, it must be safe to run the destructor on the right-hand operand.</p></li><li><p><a href="120-chapter_13._copy_control.html#filepos3200650" id="filepos3540251"><strong>move constructor</strong></a> Constructor that takes an rvalue reference to its type. Typically, a move constructor moves data from its parameter into the newly created object. After the move, it must be safe to run the destructor on the given argument.</p></li><li><p><a href="126-13.6._moving_objects.html#filepos3496642" id="filepos3540653"><strong>move iterator</strong></a> Iterator adaptor that generates an iterator that, when dereferenced, yields an rvalue reference.</p></li><li><p><a href="121-13.1._copy_assign_and_destroy.html#filepos3223421" id="filepos3540925"><strong>overloaded operator</strong></a> Function that redefines the meaning of an operator when applied to operand(s) of class type. This chapter showed how to define the assignment operator; <a href="129-chapter_14._overloaded_operations_and_conversions.html#filepos3544393">Chapter 14</a> covers overloaded operators in more detail.</p></li><li><p><a href="122-13.2._copy_control_and_resource_management.html#filepos3301263" id="filepos3541341"><strong>reference count</strong></a> Programming technique often used in copy-control members. A reference count keeps track of how many objects share state. Constructors (other than copy/move constructors) set the reference count to 1. Each time a new copy is made the count is incremented. When an object is destroyed, the count is decremented. The assignment operator and the destructor check whether the decremented reference count has gone to zero and, if so, they destroy the object.</p></li><li><p><a href="126-13.6._moving_objects.html#filepos3517146" id="filepos3541971"><strong>reference qualifier</strong></a> Symbol used to indicate that a non<code>static</code> member function can be called on an lvalue or an rvalue. The qualifier, <code>&amp;</code> or <code>&amp;&amp;</code>, follows the parameter list or the <code>const</code> qualifier if there is one. A function qualified by <code>&amp;</code> may be called only on lvalues; a function qualified by <code>&amp;&amp;</code> may be called only on rvalues.</p></li><li><p><a href="126-13.6._moving_objects.html#filepos3429696" id="filepos3542858"><strong>rvalue reference</strong></a> Reference to an object that is about to be destroyed.</p></li><li><p><a href="121-13.1._copy_assign_and_destroy.html#filepos3226399" id="filepos3543090"><strong>synthesized assignment operator</strong></a> A version of the copy- or move-assignment operator created (synthesized) by the compiler for classes that do not explicitly define assignment operators. Unless it is defined as deleted, a synthesized assignment operator memberwise assigns (moves) the right-hand operand to the left.</p></li><li><p><a href="121-13.1._copy_assign_and_destroy.html#filepos3205471" id="filepos3543566"><strong>synthesized copy/move constructor</strong></a> A version of the copy or move constructor that is generated by the compiler for classes that do not explicitly define the corresponding constructor. Unless it is defined as deleted, a synthesized copy or move constructor memberwise initializes the new object by copying or moving members from the given object, respectively.</p></li><li><p><a href="121-13.1._copy_assign_and_destroy.html#filepos3242525" id="filepos3544086"><strong>synthesized destructor</strong></a> Version of the destructor created (synthesized) by the compiler for classes that do not explicitly define one. The synthesized destructor has an empty function body.</p></li>
 
</ul>

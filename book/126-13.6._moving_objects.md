---
title: 13.6. Moving Objects
---

<h3 id="filepos3426774">13.6. Moving Objects</h3>
<Badge type="danger" text="Advanced" />
<p>One of the major features in the new standard is the ability to move rather than copy an object. As we saw in § <a href="121-13.1._copy_assign_and_destroy.html#filepos3203084">13.1.1</a> (p. <a href="121-13.1._copy_assign_and_destroy.html#filepos3203084">497</a>), copies are made in many circumstances. In some of these circumstances, an object is immediately destroyed after it is copied. In those cases, moving, rather than copying, the object can provide a significant performance boost.</p>
<p>As we’ve just seen, our <code>StrVec</code> class is a good example of this kind of superfluous copy. During reallocation, there is no need to copy—rather than move—the elements from the old memory to the new. A second reason to move rather than copy occurs in classes such as the IO or <code>unique_ptr</code> classes. These classes have a resource (such as a pointer or an IO buffer) that may not be shared. Hence, objects of these types can’t be copied but can be moved.</p>
<p><a id="filepos3428100"></a>Under earlier versions of the language, there was no direct way to move an object. We had to make a copy even if there was no need for the copy. If the objects are large, or if the objects themselves require memory allocation (e.g., <code>string</code>s), making a needless copy can be expensive. Similarly, in previous versions of the library, classes stored in a container had to be copyable. Under the new standard, we can use containers on types that cannot be copied so long as they can be moved.</p>

::: info
<p>The library containers, <code>string</code>, and <code>shared_ptr</code> classes support move as well as copy. The IO and <code>unique_ptr</code> classes can be moved but not copied.</p>
:::

<h4 id="filepos3429349">13.6.1. Rvalue References</h4>
<Badge type="danger" text="Advanced" />
<a id="filepos3429517"></a><Badge type="tip" text="C++11" />
<p>To support move operations, the new standard introduced a new kind of reference, an <strong><a href="128-defined_terms.html#filepos3542858" id="filepos3429696">rvalue reference</a></strong>. An rvalue reference is a reference that must be bound to an rvalue. An rvalue reference is obtained by using <code>&amp;&amp;</code> rather than <code>&amp;</code>. As we’ll see, rvalue references have the important property that they may be bound only to an object that is about to be destroyed. As a result, we are free to “move” resources from an rvalue reference to another object.</p>
<p>Recall that lvalue and rvalue are properties of an expression (§ <a href="039-4.1._fundamentals.html#filepos999677">4.1.1</a>, p. <a href="039-4.1._fundamentals.html#filepos999677">135</a>). Some expressions yield or require lvalues; others yield or require rvalues. Generally speaking, an lvalue expression refers to an object’s identity whereas an rvalue expression refers to an object’s value.</p>
<p>Like any reference, an rvalue reference is just another name for an object. As we know, we cannot bind regular references—which we’ll refer to as <strong><a href="128-defined_terms.html#filepos3538303" id="filepos3430925">lvalue references</a></strong> when we need to distinguish them from rvalue references—to expressions that require a conversion, to literals, or to expressions that return an rvalue (§ <a href="023-2.3._compound_types.html#filepos396246">2.3.1</a>, p. <a href="023-2.3._compound_types.html#filepos396246">51</a>). Rvalue references have the opposite binding properties: We can bind an rvalue reference to these kinds of expressions, but we cannot directly bind an rvalue reference to an lvalue:</p>

```c++
int i = 42;
int &r = i;             // ok: r refers to i
int &&rr = i;           // error: cannot bind an rvalue reference to an lvalue
int &r2 = i * 42;       // error: i * 42 is an rvalue
const int &r3 = i * 42; // ok: we can bind a reference to const to an rvalue
int &&rr2 = i * 42;     // ok: bind rr2 to the result of the multiplication
```

<p>Functions that return lvalue references, along with the assignment, subscript, dereference, and prefix increment/decrement operators, are all examples of expressions that return lvalues. We can bind an lvalue reference to the result of any of these expressions.</p>
<p>Functions that return a nonreference type, along with the arithmetic, relational, bitwise, and postfix increment/decrement operators, all yield rvalues. We cannot bind an lvalue reference to these expressions, but we can bind either an lvalue reference to <code>const</code> or an rvalue reference to such expressions.</p>
<h5><a id="filepos3433996"></a>Lvalues Persist; Rvalues Are Ephemeral</h5>
<p>Looking at the list of lvalue and rvalue expressions, it should be clear that lvalues and rvalues differ from each other in an important manner: Lvalues have persistent state, whereas rvalues are either literals or temporary objects created in the course of evaluating expressions.</p>
<p>Because rvalue references can only be bound to temporaries, we know that</p>
<ul><li>The referred-to object is about to be destroyed</li><li>There can be no other users of that object</li></ul>

<p>These facts together mean that code that uses an rvalue reference is free to take over resources from the object to which the reference refers.</p>

::: info
<p>Rvalue references refer to objects that are about to be destroyed. Hence, we can “steal” state from an object bound to an rvalue reference.</p>
:::

<h5>Variables Are Lvalues</h5>
<p>Although we rarely think about it this way, a variable is an expression with one operand and no operator. Like any other expression, a variable expression has the lvalue/rvalue property. Variable expressions are lvalues. It may be surprising, but as a consequence, we cannot bind an rvalue reference to a variable defined as an rvalue reference type:</p>

```c++
int &&rr1 = 42;    // ok: literals are rvalues
int &&rr2 = rr1;   // error: the expression rr1 is an lvalue!
```

<p>Given our previous observation that rvalues represent ephemeral objects, it should not be surprising that a variable is an lvalue. After all, a variable persists until it goes out of scope.</p>

::: info
<p>A variable is an lvalue; we cannot directly bind an rvalue reference to a variable <em>even if that variable was defined as an rvalue reference type.</em></p>
:::

<h5>The Library <code>move</code> Function</h5>
<a id="filepos3437715"></a><Badge type="tip" text="C++11" />
<p>Although we cannot directly bind an rvalue reference to an lvalue, we can explicitly cast an lvalue to its corresponding rvalue reference type. We can also obtain an rvalue reference bound to an lvalue by calling a new library function named <code>move</code>, which is defined in the <code>utility</code> header. The <code>move</code> function uses facilities that we’ll describe in § <a href="155-16.2._template_argument_deduction.html#filepos4403933">16.2.6</a> (p. <a href="155-16.2._template_argument_deduction.html#filepos4403933">690</a>) to return an rvalue reference to its given object.</p>

```c++
int &&rr3 = std::move(rr1);   // ok
```

<p>Calling <code>move</code> tells the compiler that we have an lvalue that we want to treat as if it were an rvalue. It is essential to realize that the call to <code>move</code> promises that we do not intend to use <code>rr1</code> again except to assign to it or to destroy it. After a call to <code>move</code>, we cannot make any assumptions about the value of the moved-from object.</p>

::: info
<a id="filepos3439682"></a>
<p>We can destroy a moved-from object and can assign a new value to it, but we cannot use the value of a moved-from object.</p>
:::

<p>As we’ve seen, differently from how we use most names from the library, we do not provide a <code>using</code> declaration (§ <a href="030-3.1._namespace_using_declarations.html#filepos638596">3.1</a>, p. <a href="030-3.1._namespace_using_declarations.html#filepos638596">82</a>) for <code>move</code> (§ <a href="125-13.5._classes_that_manage_dynamic_memory.html#filepos3380687">13.5</a>, p. <a href="125-13.5._classes_that_manage_dynamic_memory.html#filepos3380687">530</a>). We call <code>std::move</code> not <code>move</code>. We’ll explain the reasons for this usage in § <a href="172-18.2._namespaces.html#filepos4989992">18.2.3</a> (p. <a href="172-18.2._namespaces.html#filepos4989992">798</a>).</p>

::: warning
<p>Code that uses <code>move</code> should use <code>std::move</code>, not <code>move</code>. Doing so avoids potential name collisions.</p>
:::

::: info
<p>Exercises Section 13.6.1</p>
<p><strong>Exercise 13.45:</strong> Distinguish between an rvalue reference and an lvalue reference.</p>
<p><strong>Exercise 13.46:</strong> Which kind of reference can be bound to the following initializers?</p>

```c++
int f();
vector<int> vi(100);
int? r1 = f();
int? r2 = vi[0];
int? r3 = r1;
int? r4 = vi[0] * f();
```

<p><strong>Exercise 13.47:</strong> Give the copy constructor and copy-assignment operator in your <code>String</code> class from <a href="125-13.5._classes_that_manage_dynamic_memory.html#filepos3426130">exercise 13.44</a> in § <a href="125-13.5._classes_that_manage_dynamic_memory.html#filepos3380687">13.5</a> (p. <a href="125-13.5._classes_that_manage_dynamic_memory.html#filepos3380687">531</a>) a statement that prints a message each time the function is executed.</p>
<p><a id="filepos3442777"></a><strong>Exercise 13.48:</strong> Define a <code>vector&lt;String&gt;</code> and call <code>push_back</code> several times on that <code>vector</code>. Run your program and see how often <code>String</code>s are copied.</p>
:::

<h4 id="filepos3443291">13.6.2. Move Constructor and Move Assignment</h4>
<Badge type="danger" text="Advanced" />
<p>Like the <code>string</code> class (and other library classes), our own classes can benefit from being able to be moved as well as copied. To enable move operations for our own types, we define a move constructor and a move-assignment operator. These members are similar to the corresponding copy operations, but they “steal” resources from their given object rather than copy them.</p>
<a id="filepos3443986"></a><Badge type="tip" text="C++11" />
<p>Like the copy constructor, the move constructor has an initial parameter that is a reference to the class type. Differently from the copy constructor, the reference parameter in the move constructor is an rvalue reference. As in the copy constructor, any additional parameters must all have default arguments.</p>
<p>In addition to moving resources, the move constructor must ensure that the moved-from object is left in a state such that destroying that object will be harmless. In particular, once its resources are moved, the original object must no longer point to those moved resources—responsibility for those resources has been assumed by the newly created object.</p>
<p><a id="filepos3444873"></a>As an example, we’ll define the <code>StrVec</code> move constructor to move rather than copy the elements from one <code>StrVec</code> to another:</p>

```c++
StrVec::StrVec(StrVec &&s) noexcept   // move won't throw any exceptions
  // member initializers take over the resources in s
  : elements(s.elements), first_free(s.first_free), cap(s.cap)
{
    // leave s in a state in which it is safe to run the destructor
    s.elements = s.first_free = s.cap = nullptr;
}
```

<p>We’ll explain the use of <code>noexcept</code> (which signals that our constructor does not throw any exceptions) shortly, but let’s first look at what this constructor does.</p>
<p>Unlike the copy constructor, the move constructor does not allocate any new memory; it takes over the memory in the given <code>StrVec</code>. Having taken over the memory from its argument, the constructor body sets the pointers in the given object to <code>nullptr</code>. After an object is moved from, that object continues to exist. Eventually, the moved-from object will be destroyed, meaning that the destructor will be run on that object. The <code>StrVec</code> destructor calls <code>deallocate</code> on <code>first_free</code>. If we neglected to change <code>s.first_free</code>, then destroying the moved-from object would delete the memory we just moved.</p>
<h5>Move Operations, Library Containers, and Exceptions</h5>
<Badge type="warning" text="Tricky" />
<p>Because a move operation executes by “stealing” resources, it ordinarily does not itself allocate any resources. As a result, move operations ordinarily will not throw any exceptions. When we write a move operation that cannot throw, we should inform the library of that fact. As we’ll see, unless the library knows that our move constructor won’t throw, it will do extra work to cater to the possibliity that moving an object of our class type might throw.</p>
<a id="filepos3448327"></a><Badge type="tip" text="C++11" />
<p>One way inform the library is to specify <code>noexcept</code> on our constructor. We’ll cover <code>noexcept</code>, which was introduced by the new standard, in more detail in § <a href="171-18.1._exception_handling.html#filepos4896504">18.1.4</a> (p. <a href="171-18.1._exception_handling.html#filepos4896504">779</a>). For now what’s important to know is that <code>noexcept</code> is a way for us to promise that a function does not throw any exceptions. We specify <code>noexcept</code> on a function after its parameter list. In a constructor, <code>noexcept</code> appears between the parameter list and the <code>:</code> that begins the constructor initializer list:</p>

```c++
class StrVec {
public:
    StrVec(StrVec&&) noexcept;     // move constructor
    // other members as before
};
StrVec::StrVec(StrVec &&s) noexcept : /* member initializers */
{ /* constructor body   */ }
```

<p>We must specify <code>noexcept</code> on both the declaration in the class header and on the definition if that definition appears outside the class.</p>

::: info
<p>Move constructors and move assignment operators that cannot throw exceptions should be marked as <code>noexcept</code>.</p>
:::

<p><a id="filepos3451030"></a>Understanding why <code>noexcept</code> is needed can help deepen our understanding of how the library interacts with objects of the types we write. We need to indicate that a move operation doesn’t throw because of two interrelated facts: First, although move operations usually don’t throw exceptions, they are permitted to do so. Second, the library containers provide guarantees as to what they do if an exception happens. As one example, <code>vector</code> guarantees that if an exception happens when we call <code>push_back</code>, the <code>vector</code> itself will be left unchanged.</p>
<p>Now let’s think about what happens inside <code>push_back</code>. Like the corresponding <code>StrVec</code> operation (§ <a href="125-13.5._classes_that_manage_dynamic_memory.html#filepos3380687">13.5</a>, p. <a href="125-13.5._classes_that_manage_dynamic_memory.html#filepos3380687">527</a>), <code>push_back</code> on a <code>vector</code> might require that the <code>vector</code> be reallocated. When a <code>vector</code> is reallocated, it moves the elements from its old space to new memory, just as we did in <code>reallocate</code> (§ <a href="125-13.5._classes_that_manage_dynamic_memory.html#filepos3380687">13.5</a>, p. <a href="125-13.5._classes_that_manage_dynamic_memory.html#filepos3380687">530</a>).</p>
<p>As we’ve just seen, moving an object generally changes the value of the moved-from object. If reallocation uses a move constructor and that constructor throws an exception after moving some but not all of the elements, there would be a problem. The moved-from elements in the old space would have been changed, and the unconstructed elements in the new space would not yet exist. In this case, <code>vector</code> would be unable to meet its requirement that the <code>vector</code> is left unchanged.</p>
<p>On the other hand, if <code>vector</code> uses the copy constructor and an exception happens, it can easily meet this requirement. In this case, while the elements are being constructed in the new memory, the old elements remain unchanged. If an exception happens, <code>vector</code> can free the space it allocated (but could not successfully construct) and return. The original <code>vector</code> elements still exist.</p>
<p>To avoid this potential problem, <code>vector</code> must use a copy constructor instead of a move constructor during reallocation <em>unless it knows</em> that the element type’s move constructor cannot throw an exception. If we want objects of our type to be moved rather than copied in circumstances such as <code>vector</code> reallocation, we must explicity tell the library that our move constructor is safe to use. We do so by marking the move constructor (and move-assignment operator) <code>noexcept</code>.</p>
<h5>Move-Assignment Operator</h5>
<p>The move-assignment operator does the same work as the destructor and the move constructor. As with the move constructor, if our move-assignment operator won’t throw any exceptions, we should make it <code>noexcept</code>. Like a copy-assignment operator, a move-assignment operator must guard against self-assignment:</p>

```c++
StrVec &StrVec::operator=(StrVec &&rhs) noexcept
{
    // direct test for self-assignment
    if (this != &rhs) {
        free();                  // free existing elements
        elements = rhs.elements; // take over resources from rhs
        first_free = rhs.first_free;
        cap = rhs.cap;
        // leave rhs in a destructible state
        rhs.elements = rhs.first_free = rhs.cap = nullptr;
    }
    return *this;
}
```

<p><a id="filepos3457066"></a>In this case we check directly whether the <code>this</code> pointer and the address of <code>rhs</code> are the same. If they are, the right- and left-hand operands refer to the same object and there is no work to do. Otherwise, we free the memory that the left-hand operand had used, and then take over the memory from the given object. As in the move constructor, we set the pointers in <code>rhs</code> to <code>nullptr</code>.</p>
<p>It may seem surprising that we bother to check for self-assignment. After all, move assignment requires an rvalue for the right-hand operand. We do the check because that rvalue could be the result of calling <code>move</code>. As in any other assignment operator, it is crucial that we not free the left-hand resources before using those (possibly same) resources from the right-hand operand.</p>
<h5>A Moved-from Object Must Be Destructible</h5>
<Badge type="warning" text="Tricky" />
<p>Moving from an object does not destroy that object: Sometime after the move operation completes, the moved-from object will be destroyed. Therefore, when we write a move operation, we must ensure that the moved-from object is in a state in which the destructor can be run. Our <code>StrVec</code> move operations meet this requirement by setting the pointer members of the moved-from object to <code>nullptr</code>.</p>
<p>In addition to leaving the moved-from object in a state that is safe to destroy, move operations must guarantee that the object remains valid. In general, a valid object is one that can safely be given a new value or used in other ways that do not depend on its current value. On the other hand, move operations have no requirements as to the value that remains in the moved-from object. As a result, our programs should never depend on the value of a moved-from object.</p>
<p>For example, when we move from a library <code>string</code> or container object, we know that the moved-from object remains valid. As a result, we can run operations such as as <code>empty</code> or <code>size</code> on moved-from objects. However, we don’t know what result we’ll get. We might expect a moved-from object to be empty, but that is not guaranteed.</p>
<p>Our <code>StrVec</code> move operations leave the moved-from object in the same state as a default-initialized object. Therefore, all the operations of <code>StrVec</code> will continue to run the same way as they do for any other default-initialized <code>StrVec</code>. Other classes, with more complicated internal structure, may behave differently.</p>

::: warning
<p>After a move operation, the “moved-from” object must remain a valid, destructible object but users may make no assumptions about its value.</p>
:::

<h5>The Synthesized Move Operations</h5>
<p>As it does for the copy constructor and copy-assignment operator, the compiler will synthesize the move constructor and move-assignment operator. However, the conditions under which it synthesizes a move operation are quite different from those in which it synthesizes a copy operation.</p>
<p>Recall that if we do not declare our own copy constructor or copy-assignment operator the compiler <em>always</em> synthesizes these operations (§ <a href="121-13.1._copy_assign_and_destroy.html#filepos3203084">13.1.1</a>, p. <a href="121-13.1._copy_assign_and_destroy.html#filepos3203084">497</a> and § <a href="121-13.1._copy_assign_and_destroy.html#filepos3222083">13.1.2</a>, p. <a href="121-13.1._copy_assign_and_destroy.html#filepos3222083">500</a>). The copy operations are defined either to memberwise copy or assign the object or they are defined as deleted functions.</p>
<p><a id="filepos3462137"></a>Differently from the copy operations, for some classes the compiler does not synthesize the move operations <em>at all.</em> In particular, if a class defines its own copy constructor, copy-assignment operator, or destructor, the move constructor and move-assignment operator are not synthesized. As a result, some classes do not have a move constructor or a move-assignment operator. As we’ll see on page <a href="126-13.6._moving_objects.html#filepos3473849">540</a>, when a class doesn’t have a move operation, the corresponding copy operation is used in place of move through normal function matching.</p>
<p>The compiler will synthesize a move constructor or a move-assignment operator <em>only</em> if the class doesn’t define any of its own copy-control members and if every non<code>static</code> data member of the class can be moved. The compiler can move members of built-in type. It can also move members of a class type if the member’s class has the corresponding move operation:</p>

```c++
// the compiler will synthesize the move operations for X and hasX
struct X {
    int i;         // built-in types can be moved
    std::string s; // string defines its own move operations
};
struct hasX {
    X mem;  // X has synthesized move operations
};
X x, x2 = std::move(x);       // uses the synthesized move constructor
hasX hx, hx2 = std::move(hx); // uses the synthesized move constructor
```

::: info
<p>The compiler synthesizes the move constructor and move assignment only if a class does not define any of its own copy-control members and only if all the data members can be moved constructed and move assigned, respectively.</p>
:::

<p>Unlike the copy operations, a move operation is never implicitly defined as a deleted function. However, if we explicitly ask the compiler to generate a move operation by using <code>= default</code> (§ <a href="073-7.1._defining_abstract_data_types.html#filepos1802479">7.1.4</a>, p. <a href="073-7.1._defining_abstract_data_types.html#filepos1802479">264</a>), and the compiler is unable to move all the members, then the move operation will be defined as deleted. With one important exception, the rules for when a synthesized move operation is defined as deleted are analogous to those for the copy operations (§ <a href="121-13.1._copy_assign_and_destroy.html#filepos3263004">13.1.6</a>, p. <a href="121-13.1._copy_assign_and_destroy.html#filepos3263004">508</a>):</p>
<ul><li>Unlike the copy constructor, the move constructor is defined as deleted if the class has a member that defines its own copy constructor but does not also define a move constructor, or if the class has a member that doesn’t define its own copy operations and for which the compiler is unable to synthesize a move constructor. Similarly for move-assignment.</li><li>The move constructor or move-assignment operator is defined as deleted if the class has a member whose own move constructor or move-assignment operator is deleted or inaccessible.</li><li>Like the copy constructor, the move constructor is defined as deleted if the destructor is deleted or inaccessible.</li><li>Like the copy-assignment operator, the move-assignment operator is defined as deleted if the class has a <code>const</code> or reference member.</li></ul>

<p><a id="filepos3467413"></a>For example, assuming <code>Y</code> is a class that defines its own copy constructor but does not also define its own move constructor:</p>

```c++
// assume Y is a class that defines its own copy constructor but not a move constructor
struct hasY {
    hasY() = default;
    hasY(hasY&&) = default;
    Y mem; // hasY will have a deleted move constructor
};
hasY hy, hy2 = std::move(hy); // error: move constructor is deleted
```

<p>The compiler can copy objects of type <code>Y</code> but cannot move them. Class <code>hasY</code> explicitly requested a move constructor, which the compiler is unable to generate. Hence, <code>hasY</code> will get a deleted move constructor. Had <code>hasY</code> omitted the declaration of its move constructor, then the compiler would not synthesize the <code>hasY</code> move constructor at all. The move operations are not synthesized if they would otherwise be defined as deleted.</p>
<p>There is one final interaction between move operations and the synthesized copy-control members: Whether a class defines its own move operations has an impact on how the copy operations are synthesized. If the class defines either a move constructor and/or a move-assignment operator, then the synthesized copy constructor and copy-assignment operator for that class will be defined as deleted.</p>

::: info
<p>Classes that define a move constructor or move-assignment operator must also define their own copy operations. Otherwise, those members are deleted by default.</p>
:::

<h5>Rvalues Are Moved, Lvalues Are Copied ...</h5>
<p>When a class has both a move constructor and a copy constructor, the compiler uses ordinary function matching to determine which constructor to use (§ <a href="066-6.4._overloaded_functions.html#filepos1597234">6.4</a>, p. <a href="066-6.4._overloaded_functions.html#filepos1597234">233</a>). Similarly for assignment. For example, in our <code>StrVec</code> class the copy versions take a reference to <code>const StrVec</code>. As a result, they can be used on any type that can be converted to <code>StrVec</code>. The move versions take a <code>StrVec&amp;&amp;</code> and can be used only when the argument is a (non<code>const</code>) rvalue:</p>

```c++
StrVec v1, v2;
v1 = v2;                  // v2 is an lvalue; copy assignment
StrVec getVec(istream &); // getVec returns an rvalue
v2 = getVec(cin);         // getVec(cin) is an rvalue; move assignment
```

<p>In the first assignment, we pass <code>v2</code> to the assignment operator. The type of <code>v2</code> is <code>StrVec</code> and the expression, <code>v2</code>, is an lvalue. The move version of assignment is not viable (§ <a href="068-6.6._function_matching.html#filepos1674559">6.6</a>, p. <a href="068-6.6._function_matching.html#filepos1674559">243</a>), because we cannot implicitly bind an rvalue reference to an lvalue. Hence, this assignment uses the copy-assignment operator.</p>
<p>In the second assignment, we assign from the result of a call to <code>getVec</code>. That expression is an rvalue. In this case, both assignment operators are viable—we can bind the result of <code>getVec</code> to either operator’s parameter. Calling the copy-assignment operator requires a conversion to <code>const</code>, whereas <code>StrVec&amp;&amp;</code> is an exact match. Hence, the second assignment uses the move-assignment operator.</p>
<h5><a id="filepos3473849"></a>...But Rvalues Are Copied If There Is No Move Constructor</h5>
<p>What if a class has a copy constructor but does not define a move constructor? In this case, the compiler will not synthesize the move constructor, which means the class has a copy constructor but no move constructor. If a class has no move constructor, function matching ensures that objects of that type are copied, even if we attempt to move them by calling <code>move</code>:</p>

```c++
class Foo {
public:
    Foo() = default;
    Foo(const Foo&);  // copy constructor
    // other members, but Foo does not define a move constructor
};
Foo x;
Foo y(x);            // copy constructor; x is an lvalue
Foo z(std::move(x)); // copy constructor, because there is no move constructor
```

<p>The call to <code>move(x)</code> in the initialization of <code>z</code> returns a <code>Foo&amp;&amp;</code> bound to <code>x</code>. The copy constructor for <code>Foo</code> is viable because we can convert a <code>Foo&amp;&amp;</code> to a <code>const Foo&amp;</code>. Thus, the initialization of <code>z</code> uses the copy constructor for <code>Foo</code>.</p>
<p>It is worth noting that using the copy constructor in place of a move constructor is almost surely safe (and similarly for the assignment operators). Ordinarily, the copy constructor will meet the requirements of the corresponding move constructor: It will copy the given object and leave that original object in a valid state. Indeed, the copy constructor won’t even change the value of the original object.</p>

::: info
<p>If a class has a usable copy constructor and no move constructor, objects will be “moved” by the copy constructor. Similarly for the copy-assignment operator and move-assignment.</p>
:::

<h5>Copy-and-Swap Assignment Operators and Move</h5>
<p>The version of our <code>HasPtr</code> class that defined a copy-and-swap assignment operator (§ <a href="123-13.3._swap.html#filepos3315883">13.3</a>, p. <a href="123-13.3._swap.html#filepos3315883">518</a>) is a good illustration of the interaction between function matching and move operations. If we add a move constructor to this class, it will effectively get a move assignment operator as well:</p>

```c++
class HasPtr {
public:
    // added move constructor
    HasPtr(HasPtr &&p) noexcept : ps(p.ps), i(p.i) {p.ps = 0;}
    // assignment operator is both the move- and copy-assignment operator
    HasPtr& operator=(HasPtr rhs)
                   { swap(*this, rhs); return *this; }
    // other members as in § 13.2.1 (p. 511)
};
```

<p>In this version of the class, we’ve added a move constructor that takes over the values from its given argument. The constructor body sets the pointer member of <a id="filepos3479414"></a>the given <code>HasPtr</code> to zero to ensure that it is safe to destroy the moved-from object. Nothing this function does can throw an exception so we mark it as <code>noexcept</code> (§ <a href="126-13.6._moving_objects.html#filepos3443291">13.6.2</a>, p. <a href="126-13.6._moving_objects.html#filepos3443291">535</a>).</p>
<p>Now let’s look at the assignment operator. That operator has a nonreference parameter, which means the parameter is copy initialized (§ <a href="121-13.1._copy_assign_and_destroy.html#filepos3203084">13.1.1</a>, p. <a href="121-13.1._copy_assign_and_destroy.html#filepos3203084">497</a>). Depending on the type of the argument, copy initialization uses either the copy constructor or the move constructor; lvalues are copied and rvalues are moved. As a result, this single assignment operator acts as both the copy-assignment and move-assignment operator.</p>
<p>For example, assuming both <code>hp</code> and <code>hp2</code> are <code>HasPtr</code> objects:</p>

```c++
hp = hp2; //  hp2 is an lvalue; copy constructor used to copy hp2
hp = std::move(hp2); // move constructor moves hp2
```

<p>In the first assignment, the right-hand operand is an lvalue, so the move constructor is not viable. The copy constructor will be used to initialize <code>rhs</code>. The copy constructor will allocate a new <code>string</code> and copy the <code>string</code> to which <code>hp2</code> points.</p>
<p>In the second assignment, we invoke <code>std::move</code> to bind an rvalue reference to <code>hp2</code>. In this case, both the copy constructor and the move constructor are viable. However, because the argument is an rvalue reference, it is an exact match for the move constructor. The move constructor copies the pointer from <code>hp2</code>. It does not allocate any memory.</p>
<p>Regardless of whether the copy or move constructor was used, the body of the assignment operator <code>swap</code>s the state of the two operands. Swapping a <code>HasPtr</code> exchanges the pointer (and <code>int</code>) members of the two objects. After the <code>swap, rhs</code> will hold a pointer to the <code>string</code> that had been owned by the left-hand side. That <code>string</code> will be destroyed when <code>rhs</code> goes out of scope.</p>

::: info
<p>Advice: Updating the Rule of Three</p>
<p>All five copy-control members should be thought of as a unit: Ordinarily, if a class defines any of these operations, it usually should define them all. As we’ve seen, some classes <em>must</em> define the copy constructor, copy-assignment operator, and destructor to work correctly (§ <a href="121-13.1._copy_assign_and_destroy.html#filepos3244603">13.1.4</a>, p. <a href="121-13.1._copy_assign_and_destroy.html#filepos3244603">504</a>). Such classes typically have a resource that the copy members must copy. Ordinarily, copying a resource entails some amount of overhead. Classes that define the move constructor and move-assignment operator can avoid this overhead in those circumstances where a copy isn’t necessary.</p>
:::

<h5>Move Operations for the <code>Message</code> Class</h5>
<p>Classes that define their own copy constructor and copy-assignment operator generally also benefit by defining the move operations. For example, our <code>Message</code> and <code>Folder</code> classes (§ <a href="124-13.4._a_copycontrol_example.html#filepos3341274">13.4</a>, p. <a href="124-13.4._a_copycontrol_example.html#filepos3341274">519</a>) should define move operations. By defining move operations, the <code>Message</code> class can use the <code>string</code> and <code>set</code> move operations to avoid the overhead of copying the <code>contents</code> and <code>folders</code> members.</p>
<p>However, in addition to moving the <code>folders</code> member, we must also update each <code>Folder</code> that points to the original <code>Message</code>. We must remove pointers to the old <code>Message</code> and add a pointer to the new one.</p>
<p><a id="filepos3486198"></a>Both the move constructor and move-assignment operator need to update the <code>Folder</code> pointers, so we’ll start by defining an operation to do this common work:</p>

```c++
// move the Folder pointers from m to this Message
void Message::move_Folders(Message *m)
{
    folders = std::move(m->folders); // uses set move assignment
    for (auto f : folders) {  // for each Folder
        f->remMsg(m);    // remove the old Message from the Folder
        f->addMsg(this); // add this Message to that Folder
    }
    m->folders.clear();  // ensure that destroying m is harmless
}
```

<p>This function begins by moving the <code>folders</code> set. By calling <code>move</code>, we use the <code>set</code> move assignment rather than its copy assignment. Had we omitted the call to <code>move</code>, the code would still work, but the copy is unnecessary. The function then iterates through those <code>Folder</code>s, removing the pointer to the original <code>Message</code> and adding a pointer to the new <code>Message</code>.</p>
<p>It is worth noting that inserting an element to a <code>set</code> might throw an exception—adding an element to a container requires memory to be allocated, which means that a <code>bad_alloc</code> exception might be thrown (§ <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos2959483">12.1.2</a>, p. <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos2959483">460</a>). As a result, unlike our <code>HasPtr</code> and <code>StrVec</code> move operations, the <code>Message</code> move constructor and move-assignment operators might throw exceptions. We will not mark them as <code>noexcept</code> (§ <a href="126-13.6._moving_objects.html#filepos3443291">13.6.2</a>, p. <a href="126-13.6._moving_objects.html#filepos3443291">535</a>).</p>
<p>The function ends by calling <code>clear</code> on <code>m.folders</code>. After the <code>move</code>, we know that <code>m.folders</code> is valid but have no idea what its contents are. Because the <code>Message</code> destructor iterates through <code>folders</code>, we want to be certain that the <code>set</code> is empty.</p>
<p>The <code>Message</code> move constructor calls <code>move</code> to move the <code>contents</code> and default initializes its <code>folders</code> member:</p>

```c++
Message::Message(Message &&m): contents(std::move(m.contents))
{
    move_Folders(&m); // moves folders and updates the Folder pointers
}
```

<p>In the body of the constructor, we call <code>move_Folders</code> to remove the pointers to <code>m</code> and insert pointers to this <code>Message</code>.</p>
<p>The move-assignment operator does a direct check for self-assignment:</p>

```c++
Message& Message::operator=(Message &&rhs)
{
    if (this != &rhs) {       // direct check for self-assignment
        remove_from_Folders();
        contents = std::move(rhs.contents); // move assignment
        move_Folders(&rhs); // reset the Folders to point to this Message
    }
    return *this;
}
```

<p><a id="filepos3494424"></a>As with any assignment operator, the move-assignment operator must destroy the old state of the left-hand operand. In this case, destroying the left-hand operand requires that we remove pointers to this <code>Message</code> from the existing <code>folders</code>, which we do in the call to <code>remove_from_Folders</code>. Having removed itself from its <code>Folder</code>s, we call <code>move</code> to move the <code>contents</code> from <code>rhs</code> to <code>this</code> object. What remains is to call <code>move_Messages</code> to update the <code>Folder</code> pointers.</p>
<h5>Move Iterators</h5>
<p>The <code>reallocate</code> member of <code>StrVec</code> (§ <a href="125-13.5._classes_that_manage_dynamic_memory.html#filepos3380687">13.5</a>, p. <a href="125-13.5._classes_that_manage_dynamic_memory.html#filepos3380687">530</a>) used a <code>for</code> loop to call <code>construct</code> to copy the elements from the old memory to the new. As an alternative to writing that loop, it would be easier if we could call <code>uninitialized_copy</code> to construct the newly allocated space. However, <code>uninitialized_copy</code> does what it says: It copies the elements. There is no analogous library function to “move” objects into unconstructed memory.</p>
<p>Instead, the new library defines a <strong><a href="128-defined_terms.html#filepos3540653" id="filepos3496642">move iterator</a></strong> adaptor (§ <a href="101-10.4._revisiting_iterators.html#filepos2617947">10.4</a>, p. <a href="101-10.4._revisiting_iterators.html#filepos2617947">401</a>). A move iterator adapts its given iterator by changing the behavior of the iterator’s dereference operator. Ordinarily, an iterator dereference operator returns an lvalue reference to the element. Unlike other iterators, the dereference operator of a move iterator yields an rvalue reference.</p>
<a id="filepos3497138"></a><Badge type="tip" text="C++11" />
<p>We transform an ordinary iterator to a move iterator by calling the library <code>make_move_iterator</code> function. This function takes an iterator and returns a move iterator.</p>
<p>All of the original iterator’s other operations work as usual. Because these iterators support normal iterator operations, we can pass a pair of move iterators to an algorithm. In particular, we can pass move iterators to <code>uninitialized_copy</code>:</p>

```c++
void StrVec::reallocate()
{
    // allocate space for twice as many elements as the current size
    auto newcapacity = size() ? 2 * size() : 1;
    auto first = alloc.allocate(newcapacity);
    // move the elements
    auto last = uninitialized_copy(make_move_iterator(begin()),
                                   make_move_iterator(end()),
                                   first);
    free();             // free the old space
    elements = first;   // update the pointers
    first_free = last;
    cap = elements + newcapacity;
}
```

<p><code>uninitialized_copy</code> calls <code>construct</code> on each element in the input sequence to “copy” that element into the destination. That algorithm uses the iterator dereference operator to fetch elements from the input sequence. Because we passed move iterators, the dereference operator yields an rvalue reference, which means <code>construct</code> will use the move constructor to construct the elements.</p>
<p>It is worth noting that standard library makes no guarantees about which algorithms can be used with move iterators and which cannot. Because moving an <a id="filepos3500429"></a>object can obliterate the source, you should pass move iterators to algorithms only when you are <em>confident</em> that the algorithm does not access an element after it has assigned to that element or passed that element to a user-defined function.</p>

::: tip
<p>Advice: Don’t Be Too Quick to Move</p>
<p>Because a moved-from object has indeterminate state, calling <code>std::move</code> on an object is a dangerous operation. When we call <code>move</code>, we must be absolutely certain that there can be no other users of the moved-from object.</p>
<p>Judiciously used inside class code, <code>move</code> can offer significant performance benefits. Casually used in ordinary user code (as opposed to class implementation code), moving an object is more likely to lead to mysterious and hard-to-find bugs than to any improvement in the performance of the application.</p>
<p>Best Practices</p>
<p>Outside of class implementation code such as move constructors or move-assignment operators, use <code>std::move</code> only when you <em>are certain</em> that you need to do a move and that the move is guaranteed to be safe.</p>
:::

::: info
<p>Exercises Section 13.6.2</p>
<p><strong>Exercise 13.49:</strong> Add a move constructor and move-assignment operator to your <code>StrVec</code>, <code>String</code>, and <code>Message</code> classes.</p>
<p><strong>Exercise 13.50:</strong> Put print statements in the move operations in your <code>String</code> class and rerun the program from <a href="126-13.6._moving_objects.html#filepos3442777">exercise 13.48</a> in § <a href="126-13.6._moving_objects.html#filepos3429349">13.6.1</a> (p. <a href="126-13.6._moving_objects.html#filepos3429349">534</a>) that used a <code>vector&lt;String&gt;</code> to see when the copies are avoided.</p>
<p><strong>Exercise 13.51:</strong> Although <code>unique_ptr</code>s cannot be copied, in § <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos3040235">12.1.5</a> (p. <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos3040235">471</a>) we wrote a <code>clone</code> function that returned a <code>unique_ptr</code> by value. Explain why that function is legal and how it works.</p>
<p><strong>Exercise 13.52:</strong> Explain in detail what happens in the assignments of the <code>HasPtr</code> objects on page <a href="126-13.6._moving_objects.html#filepos3479414">541</a>. In particular, describe step by step what happens to values of <code>hp</code>, <code>hp2</code>, and of the <code>rhs</code> parameter in the <code>HasPtr</code> assignment operator.</p>
<p><strong>Exercise 13.53:</strong> As a matter of low-level efficiency, the <code>HasPtr</code> assignment operator is not ideal. Explain why. Implement a copy-assignment and move-assignment operator for <code>HasPtr</code> and compare the operations executed in your new move-assignment operator versus the copy-and-swap version.</p>
<p><strong>Exercise 13.54:</strong> What would happen if we defined a <code>HasPtr</code> move-assignment operator but did not change the copy-and-swap operator? Write code to test your answer.</p>
:::

<h4 id="filepos3505762">13.6.3. Rvalue References and Member Functions</h4>
<Badge type="danger" text="Advanced" />
<p>Member functions other than constructors and assignment can benefit from providing both copy and move versions. Such move-enabled members typically use <a id="filepos3506122"></a>the same parameter pattern as the copy/move constructor and the assignment operators—one version takes an lvalue reference to <code>const</code>, and the second takes an rvalue reference to non<code>const</code>.</p>
<p>For example, the library containers that define <code>push_back</code> provide two versions: one that has an rvalue reference parameter and the other a <code>const</code> lvalue reference. Assuming <code>X</code> is the element type, these containers define:</p>

```c++
void push_back(const X&); // copy: binds to any kind of X
void push_back(X&&);      // move: binds only to modifiable rvalues of type X
```

<p>We can pass any object that can be converted to type <code>X</code> to the first version of <code>push_back</code>. This version copies data from its parameter. We can pass only an rvalue that is not <code>const</code> to the second version. This version is an exact match (and a better match) for non<code>const</code> rvalues and will be run when we pass a modifiable rvalue (§ <a href="126-13.6._moving_objects.html#filepos3443291">13.6.2</a>, p. <a href="126-13.6._moving_objects.html#filepos3443291">539</a>). This version is free to steal resources from its parameter.</p>
<p>Ordinarily, there is no need to define versions of the operation that take a <code>const X&amp;&amp;</code> or a (plain) <code>X&amp;</code>. Usually, we pass an rvalue reference when we want to “steal” from the argument. In order to do so, the argument must not be <code>const</code>. Similarly, copying from an object should not change the object being copied. As a result, there is usually no need to define a version that take a (plain) <code>X&amp;</code> parameter.</p>

::: info
<p>Overloaded functions that distinguish between moving and copying a parameter typically have one version that takes a <code>const T&amp;</code> and one that takes a <code>T&amp;&amp;</code>.</p>
:::

<p>As a more concrete example, we’ll give our <code>StrVec</code> class a second version of <code>push_back</code>:</p>

```c++
class StrVec {
public:
    void push_back(const std::string&);  // copy the element
    void push_back(std::string&&);       // move the element
    // other members as before
};
// unchanged from the original version in § 13.5 (p. 527)
void StrVec::push_back(const string& s)
{
    chk_n_alloc(); // ensure that there is room for another element
    // construct a copy of s in the element to which first_free points
    alloc.construct(first_free++, s);
}
void StrVec::push_back(string &&s)
{
    chk_n_alloc(); // reallocates the StrVec if necessary
    alloc.construct(first_free++, std::move(s));
}
```

<p>These members are nearly identical. The difference is that the rvalue reference version of <code>push_back</code> calls <code>move</code> to pass its parameter to <code>construct</code>. As we’ve seen, the <code>construct</code> function uses the type of its second and subsequent arguments to determine which constructor to use. Because <code>move</code> returns an rvalue reference, the <a id="filepos3512820"></a>type of the argument to <code>construct</code> is <code>string&amp;&amp;</code>. Therefore, the <code>string</code> move constructor will be used to construct a new last element.</p>
<p>When we call <code>push_back</code> the type of the argument determines whether the new element is copied or moved into the container:</p>

```c++
StrVec vec;  // empty StrVec
string s = "some string or another";
vec.push_back(s);      // calls push_back(const string&)
vec.push_back("done"); // calls push_back(string&&)
```

<p>These calls differ as to whether the argument is an lvalue (<code>s</code>) or an rvalue (the temporary <code>string</code> created from <code>"done")</code>. The calls are resolved accordingly.</p>
<h5>Rvalue and Lvalue Reference Member Functions</h5>
<p>Ordinarily, we can call a member function on an object, regardless of whether that object is an lvalue or an rvalue. For example:</p>

```c++
string s1 = "a value", s2 = "another";
auto n = (s1 + s2).find('a');
```

<p>Here, we called the <code>find</code> member (§ <a href="093-9.5._additional_string_operations.html#filepos2401949">9.5.3</a>, p. <a href="093-9.5._additional_string_operations.html#filepos2401949">364</a>) on the <code>string</code> rvalue that results from adding two <code>string</code>s. Sometimes such usage can be surprising:</p>

```c++
s1 + s2 = "wow!";
```

<p>Here we assign to the rvalue result of concatentating these <code>string</code>s.</p>
<p>Prior to the new standard, there was no way to prevent such usage. In order to maintain backward compatability, the library classes continue to allow assignment to rvalues, However, we might want to prevent such usage in our own classes. In this case, we’d like to force the left-hand operand (i.e., the object to which <code>this</code> points) to be an lvalue.</p>
<a id="filepos3516732"></a><Badge type="tip" text="C++11" />
<p>We indicate the lvalue/rvalue property of <code>this</code> in the same way that we define <code>const</code> member functions (§ <a href="073-7.1._defining_abstract_data_types.html#filepos1761316">7.1.2</a>, p. <a href="073-7.1._defining_abstract_data_types.html#filepos1761316">258</a>); we place a <strong><a href="128-defined_terms.html#filepos3541971" id="filepos3517146">reference qualifier</a></strong> after the parameter list:</p>

```c++
class Foo {
public:
    Foo &operator=(const Foo&) &; // may assign only to modifiable lvalues
    // other members of Foo
};
Foo &Foo::operator=(const Foo &rhs) &
{
    // do whatever is needed to assign rhs to this object
    return *this;
}
```

<p>The reference qualifier can be either <code>&amp;</code> or <code>&amp;&amp;</code>, indicating that <code>this</code> may point to an rvalue or lvalue, respectively. Like the <code>const</code> qualifier, a reference qualifier may appear only on a (non<code>static</code>) member function and must appear in both the declaration and definition of the function.</p>
<p>We may run a function qualified by <code>&amp;</code> only on an lvalue and may run a function qualified by <code>&amp;&amp;</code> only on an rvalue:</p>
<p><a id="filepos3519362"></a></p>

```c++
Foo &retFoo();  // returns a reference; a call to retFoo is an lvalue
Foo retVal();   // returns by value; a call to retVal is an rvalue
Foo i, j;       // i and j are lvalues
i = j;          // ok: i is an lvalue
retFoo() = j;   // ok: retFoo() returns an lvalue
retVal() = j;   // error: retVal() returns an rvalue
i = retVal();   // ok: we can pass an rvalue as the right-hand operand to assignment
```

<p>A function can be both <code>const</code> and reference qualified. In such cases, the reference qualifier must follow the <code>const</code> qualifier:</p>

```c++
class Foo {
public:
    Foo someMem() & const;    // error: const qualifier must come first
    Foo anotherMem() const &; // ok: const qualifier comes first
};
```

<h5>Overloading and Reference Functions</h5>
<p>Just as we can overload a member function based on whether it is <code>const</code> (§ <a href="075-7.3._additional_class_features.html#filepos1876631">7.3.2</a>, p. <a href="075-7.3._additional_class_features.html#filepos1876631">276</a>), we can also overload a function based on its reference qualifier. Moreover, we may overload a function by its reference qualifier and by whether it is a <code>const</code> member. As an example, we’ll give <code>Foo</code> a <code>vector</code> member and a function named <code>sorted</code> that returns a copy of the <code>Foo</code> object in which the <code>vector</code> is sorted:</p>

```c++
class Foo {
public:
    Foo sorted() &&;         // may run on modifiable rvalues
    Foo sorted() const &;    // may run on any kind of Foo
    // other members of Foo
private:
    vector<int> data;
};
// this object is an rvalue, so we can sort in place
Foo Foo::sorted() &&
{
    sort(data.begin(), data.end());
    return *this;
}
// this object is either const or it is an lvalue; either way we can't sort in place
Foo Foo::sorted() const & {
    Foo ret(*this);                         // make a copy
    sort(ret.data.begin(), ret.data.end()); // sort the copy
    return ret;                             // return the copy
}
```

<p>When we run <code>sorted</code> on an rvalue, it is safe to sort the <code>data</code> member directly. The object is an rvalue, which means it has no other users, so we can change the object itself. When we run <code>sorted</code> on a <code>const</code> rvalue or on an lvalue, we can’t change this object, so we copy <code>data</code> before sorting it.</p>
<p>Overload resolution uses the lvalue/rvalue property of the object that calls <code>sorted</code> to determine which version is used:</p>
<p><a id="filepos3527078"></a></p>

```c++
retVal().sorted(); // retVal() is an rvalue, calls Foo::sorted() &&
retFoo().sorted(); // retFoo() is an lvalue, calls Foo::sorted() const &
```

<p>When we define <code>const</code> memeber functions, we can define two versions that differ only in that one is <code>const</code> qualified and the other is not. There is no similar default for reference qualified functions. When we define two or more members that have the same name and the same parameter list, we must provide a reference qualifier on all or none of those functions:</p>

```c++
class Foo {
public:
    Foo sorted() &&;
    Foo sorted() const; // error: must have reference qualifier
    // Comp is type alias for the function type (see § 6.7 (p. 249))
    // that can be used to compare int values
    using Comp = bool(const int&, const int&);
    Foo sorted(Comp*);        // ok: different parameter list
    Foo sorted(Comp*) const;  // ok: neither version is reference qualified
};
```

<p>Here the declaration of the <code>const</code> version of <code>sorted</code> that has no parameters is an error. There is a second version of <code>sorted</code> that has no parameters and that function has a reference qualifier, so the <code>const</code> version of that function must have a reference qualifier as well. On the other hand, the versions of <code>sorted</code> that take a pointer to a comparison operation are fine, because neither function has a qualifier.</p>

::: info
<p>If a member function has a reference qualifier, all the versions of that member with the same parameter list must have reference qualifiers.</p>
:::

::: info
<p>Exercises Section 13.6.3</p>
<p><strong>Exercise 13.55:</strong> Add an rvalue reference version of <code>push_back</code> to your <code>StrBlob</code>.</p>
<p><strong>Exercise 13.56:</strong> What would happen if we defined <code>sorted</code> as:</p>

```c++
Foo Foo::sorted() const & {
    Foo ret(*this);
    return ret.sorted();
}
```

<p><strong>Exercise 13.57:</strong> What if we defined <code>sorted</code> as:</p>

```c++
Foo Foo::sorted() const & { return Foo(*this).sorted(); }
```

<p><strong>Exercise 13.58:</strong> Write versions of class <code>Foo</code> with print statements in their <code>sorted</code> functions to test your answers to the previous two exercises.</p>
:::

<h3 id="filepos1213446">Defined Terms</h3><ul><li><p><a href="049-4.11._type_conversions.html#filepos1163004" id="filepos1213585"><strong>arithmetic conversion</strong></a> A conversion from one arithmetic type to another. In the context of the binary arithmetic operators, arithmetic conversions usually attempt to preserve precision by converting a smaller type to a larger type (e.g., integral types are converted to floating point).</p></li><li><p><a href="039-4.1._fundamentals.html#filepos1001388" id="filepos1214032"><strong>associativity</strong></a> Determines how operators with the same precedence are grouped. Operators can be either right associative (operators are grouped from right to left) or left associative (operators are grouped from left to right).</p></li><li><p><a href="039-4.1._fundamentals.html#filepos999977" id="filepos1214419"><strong>binary operators</strong></a> Operators that take two operands.</p></li><li><p><a href="049-4.11._type_conversions.html#filepos1189842" id="filepos1214631"><strong>cast</strong></a> An explicit conversion.</p></li><li><p><a href="039-4.1._fundamentals.html#filepos1010505" id="filepos1214821"><strong>compound expression</strong></a> An expression involving more than one operator.</p></li><li><p><a href="049-4.11._type_conversions.html#filepos1191613" id="filepos1215050"><strong>const_cast</strong></a> A cast that converts a low-level <code>const</code> object to the corresponding non<code>const</code> type or vice versa.</p></li><li><p><a href="049-4.11._type_conversions.html#filepos1158220" id="filepos1215444"><strong>conversion</strong></a> Process whereby a value of one type is transformed into a value of another type. The language defines conversions among the built-in types. Conversions to and from class types are also possible.</p></li><li><p><a href="049-4.11._type_conversions.html#filepos1191426" id="filepos1215811"><strong>dynamic_cast</strong></a> Used in combination with inheritance and run-time type identification. See § <a href="178-19.2._runtime_type_identification.html#filepos5158705">19.2</a> (p. <a href="178-19.2._runtime_type_identification.html#filepos5158705">825</a>).</p></li><li><p><a href="038-chapter_4._expressions.html#filepos998961" id="filepos1216138"><strong>expression</strong></a> The lowest level of computation in a C++ program. Expressions generally apply an operator to one or more operands. Each expression yields a result. Expressions can be used as operands, so we can write compound expressions requiring the evaluation of multiple operators.</p></li><li><p><a href="049-4.11._type_conversions.html#filepos1159664" id="filepos1216580"><strong>implicit conversion</strong></a> A conversion that is automatically generated by the compiler. Given an expression that needs a particular type but has an operand of a differing type, the compiler will automatically convert the operand to the desired type if an appropriate conversion exists.</p></li><li><p><a id="filepos1217021"></a><a href="049-4.11._type_conversions.html#filepos1163925" id="filepos1217029"><strong>integral promotions</strong></a> conversions that take a smaller integral type to its most closely related larger integral type. Operands of small integral types (e.g., <code>short</code>, <code>char</code>, etc.) are always promoted, even in contexts where such conversions might not seem to be required.</p></li><li><p><a href="039-4.1._fundamentals.html#filepos1005671" id="filepos1217583"><strong>lvalue</strong></a> An expression that yields an object or function. A non<code>const</code> lvalue that denotes an object may be the left-hand operand of assignment.</p></li><li><p><a href="038-chapter_4._expressions.html#filepos998764" id="filepos1217948"><strong>operands</strong></a> Values on which an expression operates. Each operator has one or more operands associated with it.</p></li><li><p><a href="038-chapter_4._expressions.html#filepos999188" id="filepos1218217"><strong>operator</strong></a> Symbol that determines what action an expression performs. The language defines a set of operators and what those operators mean when applied to values of built-in type. The language also defines the precedence and associativity of each operator and specifies how many operands each operator takes. Operators may be overloaded and applied to values of class type.</p></li><li><p><a href="039-4.1._fundamentals.html#filepos1001511" id="filepos1218751"><strong>order of evaluation</strong></a> Order, if any, in which the operands to an operator are evaluated. In most cases, the compiler is free to evaluate operands in any order. However, the operands are always evaluated before the operator itself is evaluated. Only the <code>&amp;&amp;</code>, <code>||</code>, <code>?:</code>, and comma operators specify the order in which their operands are evaluated.</p></li><li><p><a href="039-4.1._fundamentals.html#filepos1004502" id="filepos1219449"><strong>overloaded operator</strong></a> Version of an operator that is defined for use with a class type. We’ll see in <a href="129-chapter_14._overloaded_operations_and_conversions.html#filepos3544393">Chapter 14</a> how to define overloaded versions of operators.</p></li><li><p><a href="039-4.1._fundamentals.html#filepos1001303" id="filepos1219802"><strong>precedence</strong></a> Defines the order in which different operators in a compound expression are grouped. Operators with higher precedence are grouped more tightly than operators with lower precedence.</p></li><li><p><a href="039-4.1._fundamentals.html#filepos1003780" id="filepos1220155"><strong>promoted</strong></a> See integral promotions.</p></li><li><p><a href="049-4.11._type_conversions.html#filepos1191802" id="filepos1220350"><strong>reinterpret_cast</strong></a> Interprets the contents of the operand as a different type. Inherently machine dependent and dangerous.</p></li><li><p><a href="038-chapter_4._expressions.html#filepos998847" id="filepos1220632"><strong>result</strong></a> Value or object obtained by evaluating an expression.</p></li><li><p><a href="039-4.1._fundamentals.html#filepos1005560" id="filepos1220854"><strong>rvalue</strong></a> Expression that yields a value but not the associated location, if any, of that value.</p></li><li><p><a href="041-4.3._logical_and_relational_operators.html#filepos1046144" id="filepos1221109"><strong>short-circuit evaluation</strong></a> Term used to describe how the logical <small>AND</small> and logical <small>OR</small> operators execute. If the first operand to these operators is sufficient to determine the overall result, evaluation stops. We are guaranteed that the second operand is not evaluated.</p></li><li><p><a href="047-4.9._the_sizeof_operator.html#filepos1142776" id="filepos1221566"><strong>sizeof</strong></a> Operator that returns the size, in bytes, to store an object of a given type name or of the type of a given expression.</p></li><li><p><a href="049-4.11._type_conversions.html#filepos1191240" id="filepos1221854"><strong>static_cast</strong></a> An explicit request for a well-defined type conversion. Often used to override an implicit conversion that the compiler would otherwise perform.</p></li><li><p><a href="039-4.1._fundamentals.html#filepos999887" id="filepos1222172"><strong>unary operators</strong></a> Operators that take a single operand.</p></li><li><p><code>,</code>
<strong>operator</strong> Comma operator. Binary operator that is evaluated left to right. The result of a comma expression is the value of the right-hand operand. The result is an lvalue if and only if that operand is an lvalue.</p></li><li><p><a href="045-4.7._the_conditional_operator.html#filepos1107697" id="filepos1222855"><code>?:</code>
<strong>operator</strong></a> Conditional operator. Provides an if-then-else expression of the form</p></li>

```c++
cond ?  expr1 :  expr2;
```

<li><p>If the condition <em>cond</em> is true, then <em>expr1</em> is evaluated. Otherwise, <em>expr2</em> is evaluated. The type <em>expr1</em> and <em>expr2</em> must be the same type or be convertible to a common type. Only one of <em>expr1</em> or <em>expr2</em> is evaluated.</p></li><li><p><code>&amp;&amp;</code>
<strong>operator</strong> Logical <small>AND</small> operator. Result is <code>true</code> if both operands are <code>true</code>. The right-hand operand is evaluated <em>only</em> if the left-hand operand is <code>true</code>.</p></li><li><p><a href="046-4.8._the_bitwise_operators.html#filepos1126738" id="filepos1224608"><code>&amp;</code>
<strong>operator</strong></a> Bitwise <small>AND</small> operator. Generates a new integral value in which each bit position is 1 if both operands have a 1 in that position; otherwise the bit is 0.</p></li><li><p><a id="filepos1225081"></a><a href="046-4.8._the_bitwise_operators.html#filepos1127406" id="filepos1225089"><code>^</code>
<strong>operator</strong></a> Bitwise exclusive or operator. Generates a new integral value in which each bit position is 1 if either but not both operands contain a 1 in that bit position; otherwise, the bit is 0.</p></li><li><p><code>||</code>
<strong>operator</strong> Logical <small>OR</small> operator. Yields <code>true</code> if either operand is <code>true</code>. The right-hand operand is evaluated <em>only</em> if the left-hand operand is <code>false</code>.</p></li><li><p><a href="046-4.8._the_bitwise_operators.html#filepos1127068" id="filepos1226189"><code>|</code>
<strong>operator</strong></a> Bitwise <small>OR</small> operator. Generates a new integral value in which each bit position is 1 if either operand has a 1 in that position; otherwise the bit is 0.</p></li><li><p><code>++</code>
<strong>operator</strong> The increment operator. The increment operator has two forms, prefix and postfix. Prefix increment yields an lvalue. It adds 1 to the operand and returns the changed value of the operand. Postfix increment yields an rvalue. It adds 1 to the operand and returns a copy of the original, unchanged value of the operand. Note: Iterators have <code>++</code> even if they do not have the <code>+</code> operator.</p></li><li><p><code>--</code>
<strong>operator</strong> The decrement operator has two forms, prefix and postfix. Prefix decrement yields an lvalue. It subtracts 1 from the operand and returns the changed value of the operand. Postfix decrement yields an rvalue. It subtracts 1 from the operand and returns a copy of the original, unchanged value of the operand. Note: Iterators have <code>--</code> even if they do not have the <code>-</code>.</p></li><li><p><a href="046-4.8._the_bitwise_operators.html#filepos1123791" id="filepos1228184"><code>&lt;&lt;</code>
<strong>operator</strong></a> The left-shift operator. Shifts bits in a (possibly promoted) copy of the value of the left-hand operand to the left. Shifts as many bits as indicated by the right-hand operand. The right-hand operand must be zero or positive and strictly less than the number of bits in the result. Left-hand operand should be <code>unsigned;</code> if the left-hand operand is <code>signed</code>, it is undefined if a shift causes a different bit to shift into the sign bit.</p></li><li><p><a href="046-4.8._the_bitwise_operators.html#filepos1124082" id="filepos1229053"><code>&gt;&gt;</code>
<strong>operator</strong></a> The right-shift operator. Like the left-shift operator except that bits are shifted to the right. If the left-hand operand is <code>signed</code>, it is implementation defined whether bits shifted into the result are 0 or a copy of the sign bit.</p></li><li><p><a href="046-4.8._the_bitwise_operators.html#filepos1124838" id="filepos1229657"><code>~</code>
<strong>operator</strong></a> Bitwise <small>NOT</small> operator. Generates a new integral value in which each bit is an inverted copy of the corresponding bit in the (possibly promoted) operand.</p></li><li><p><code>!</code>
<strong>operator</strong> Logical <small>NOT</small> operator. Returns the inverse of the <code>bool</code> value of its operand. Result is <code>true</code> if operand is <code>false</code> and vice versa.</p></li>
 
</ul>

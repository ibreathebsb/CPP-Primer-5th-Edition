<h3 id="filepos1451214">6.2. Argument Passing</h3>
<Badge type="info" text="Fundamental" />
<p>As we’ve seen, each time we call a function, its parameters are created and initialized by the arguments passed in the call.</p>

::: info
<p>Parameter initialization works the same way as variable initialization.</p>
:::

<p>As with any other variable, the type of a parameter determines the interaction between the parameter and its argument. If the parameter is a reference (§ <a href="023-2.3._compound_types.html#filepos396246">2.3.1</a>, p. <a href="023-2.3._compound_types.html#filepos396246">50</a>), then the parameter is bound to its argument. Otherwise, the argument’s value is copied.</p>
<p>When a parameter is a reference, we say that its corresponding argument is <strong>“passed by reference”</strong> or that the function is <strong>“called by reference.”</strong> As with any other reference, a reference parameter is an alias for the object to which it is bound; that is, the parameter is an alias for its corresponding argument.</p>
<p><a id="filepos1452816"></a>When the argument value is copied, the parameter and argument are independent objects. We say such arguments are <strong>“passed by value”</strong> or alternatively that the function is <strong>“called by value.”</strong></p>
<h4 id="filepos1453096">6.2.1. Passing Arguments by Value</h4>
<Badge type="info" text="Fundamental" />
<p>When we initialize a nonreference type variable, the value of the initializer is copied. Changes made to the variable have no effect on the initializer:</p>

```c++
int n = 0;             // ordinary variable of type int
int i = n;             // i is a copy of the value in n
i = 42;                // value in i is changed; n is unchanged
```

<p>Passing an argument by value works exactly the same way; nothing the function does to the parameter can affect the argument. For example, inside <code>fact</code> (§ <a href="063-6.1._function_basics.html#filepos1415571">6.1</a>, p. <a href="063-6.1._function_basics.html#filepos1415571">202</a>) the parameter <code>val</code> is decremented:</p>

```c++
ret *= val--;  // decrements the value of val
```

<p>Although <code>fact</code> changes the value of <code>val</code>, that change has no effect on the argument passed to <code>fact</code>. Calling <code>fact(i)</code> does not change the value of <code>i</code>.</p>
<h5>Pointer Parameters</h5>
<p>Pointers (§ <a href="023-2.3._compound_types.html#filepos409391">2.3.2</a>, p. <a href="023-2.3._compound_types.html#filepos409391">52</a>) behave like any other nonreference type. When we copy a pointer, the value of the pointer is copied. After the copy, the two pointers are distinct. However, a pointer also gives us indirect access to the object to which that pointer points. We can change the value of that object by assigning through the pointer (§ <a href="023-2.3._compound_types.html#filepos409391">2.3.2</a>, p. <a href="023-2.3._compound_types.html#filepos409391">55</a>):</p>

```c++
int n = 0, i = 42;
int *p = &n, *q = &i; // p points to n; q points to i
*p = 42;              // value in n is changed; p is unchanged
p = q;                // p now points to i; values in i and n are unchanged
```

<p>The same behavior applies to pointer parameters:</p>

```c++
// function that takes a pointer and sets the pointed-to value to zero
void reset(int *ip)
{
    *ip = 0;  // changes the value of the object to which ip points
    ip = 0;   // changes only the local copy of ip; the argument is unchanged
}
```

<p>After a call to <code>reset</code>, the object to which the argument points will be <code>0</code>, but the pointer argument itself is unchanged:</p>

```c++
int i = 42;
reset(&i);                    // changes i but not the address of i
cout << "i = " << i << endl;  // prints i = 0
```

::: tip
<a id="filepos1461475"></a><p>Best Practices</p>
<p>Programmers accustomed to programming in C often use pointer parameters to access objects outside a function. In C++, programmers generally use reference parameters instead.</p>
:::

::: info
<p>Exercises Section 6.2.1</p>
<p><a id="filepos1462148"></a><strong>Exercise 6.10:</strong> Using pointers, write a function to swap the values of two <code>int</code>s. Test the function by calling it and printing the swapped values.</p>
:::

<h4 id="filepos1462468">6.2.2. Passing Arguments by Reference</h4>
<Badge type="info" text="Fundamental" />
<p>Recall that operations on a reference are actually operations on the object to which the reference refers (§ <a href="023-2.3._compound_types.html#filepos396246">2.3.1</a>, p. <a href="023-2.3._compound_types.html#filepos396246">50</a>):</p>

```c++
int n = 0, i = 42;
int &r = n;           // r is bound to n (i.e., r is another name for n)
r = 42;               // n is now 42
r = i;                // n now has the same value as i
i = r;                // i has the same value as n
```

<p>Reference parameters exploit this behavior. They are often used to allow a function to change the value of one or more of its arguments.</p>
<p>As one example, we can rewrite our <code>reset</code> program from the previous section to take a reference instead of a pointer:</p>

```c++
// function that takes a reference to an int and sets the given object to zero
void reset(int &i)  // i is just another name for the object passed to reset
{
    i = 0;  // changes the value of the object to which i refers
}
```

<p>As with any other reference, a reference parameter is bound directly to the object from which it is initialized. When we call this version of <code>reset</code>, <code>i</code> will be bound to whatever <code>int</code> object we pass. As with any reference, changes made to <code>i</code> are made to the object to which <code>i</code> refers. In this case, that object is the argument to <code>reset</code>.</p>
<p>When we call this version of <code>reset</code>, we pass an object directly; there is no need to pass its address:</p>

```c++
int j = 42;
reset(j);  // j is passed by reference; the value in j is changed
cout << "j = " << j  << endl;  // prints j = 0
```

<p>In this call, the parameter <code>i</code> is just another name for <code>j</code>. Any use of <code>i</code> inside <code>reset</code> is a use of <code>j</code>.</p>
<h5><a id="filepos1468676"></a>Using References to Avoid Copies</h5>
<p>It can be inefficient to copy objects of large class types or large containers. Moreover, some class types (including the IO types) cannot be copied. Functions must use reference parameters to operate on objects of a type that cannot be copied.</p>
<p>As an example, we’ll write a function to compare the length of two <code>string</code>s. Because <code>string</code>s can be long, we’d like to avoid copying them, so we’ll make our parameters references. Because comparing two <code>string</code>s does not involve changing the <code>string</code>s, we’ll make the parameters references to <code>const</code> (§ <a href="024-2.4._const_qualifier.html#filepos476737">2.4.1</a>, p. <a href="024-2.4._const_qualifier.html#filepos476737">61</a>):</p>

```c++
// compare the length of two strings
bool isShorter(const string &s1, const string &s2)
{
    return s1.size() < s2.size();
}
```

<p>As we’ll see in § <a href="064-6.2._argument_passing.html#filepos1479382">6.2.3</a> (p. <a href="064-6.2._argument_passing.html#filepos1479382">213</a>), functions should use references to <code>const</code> for reference parameters they do not need to change.</p>

::: tip
<p>Best Practices</p>
<p>Reference parameters that are not changed inside a function should be references to <code>const</code>.</p>
:::

<h5>Using Reference Parameters to Return Additional Information</h5>
<p>A function can return only a single value. However, sometimes a function has more than one value to return. Reference parameters let us effectively return multiple results. As an example, we’ll define a function named <code>find_char</code> that will return the position of the first occurrence of a given character in a <code>string</code>. We’d also like the function to return a count of how many times that character occurs.</p>
<p>How can we define a function that returns a position and an occurrence count? We could define a new type that contains the position and the count. An easier solution is to pass an additional reference argument to hold the occurrence count:</p>

```c++
// returns the index of the first occurrence of c in s
// the reference parameter occurs counts how often c occurs
string::size_type find_char(const string &s, char c,
                           string::size_type &occurs)
{
    auto ret = s.size();   // position of the first occurrence, if any
    occurs = 0;            // set the occurrence count parameter
    for (decltype(ret) i = 0; i != s.size(); ++i) {
        if (s[i] == c) {
            if (ret == s.size())
                ret = i;   // remember the first occurrence of c
            ++occurs;      // increment the occurrence count
         }
    }
    return ret;            // count is returned implicitly in occurs
}
```

<p><a id="filepos1475079"></a>When we call <code>find_char</code>, we have to pass three arguments: a <code>string</code> in which to look, the character to look for, and a <code>size_type</code> (§ <a href="031-3.2._library_string_type.html#filepos659212">3.2.2</a>, p. <a href="031-3.2._library_string_type.html#filepos659212">88</a>) object to hold the occurrence count. Assuming <code>s</code> is a <code>string</code>, and <code>ctr</code> is a <code>size_type</code> object, we can call <code>find_char</code> as follows:</p>

```c++
auto index = find_char(s, 'o', ctr);
```

<p>After the call, the value of <code>ctr</code> will be the number of times <code>o</code> occurs, and <code>index</code> will refer to the first occurrence if there is one. Otherwise, <code>index</code> will be equal to <code>s.size()</code> and <code>ctr</code> will be zero.</p>

::: info
<p>Exercises Section 6.2.2</p>
<p><strong>Exercise 6.11:</strong> Write and test your own version of <code>reset</code> that takes a reference.</p>
<p><strong>Exercise 6.12:</strong> Rewrite the program from <a href="064-6.2._argument_passing.html#filepos1462148">exercise 6.10</a> in § <a href="064-6.2._argument_passing.html#filepos1453096">6.2.1</a> (p. <a href="064-6.2._argument_passing.html#filepos1453096">210</a>) to use references instead of pointers to swap the value of two <code>int</code>s. Which version do you think would be easier to use and why?</p>
<p><strong>Exercise 6.13:</strong> Assuming <code>T</code> is the name of a type, explain the difference between a function declared as <code>void f(T)</code> and <code>void f(T&amp;)</code>.</p>
<p><strong>Exercise 6.14:</strong> Give an example of when a parameter should be a reference type. Give an example of when a parameter should not be a reference.</p>
<p><strong>Exercise 6.15:</strong> Explain the rationale for the type of each of <code>find_char</code>’s parameters In particular, why is <code>s</code> a reference to <code>const</code> but <code>occurs</code> is a plain reference? Why are these parameters references, but the <code>char</code> parameter <code>c</code> is not? What would happen if we made <code>s</code> a plain reference? What if we made <code>occurs</code> a reference to <code>const</code>?</p>
:::

<h4 id="filepos1479382">6.2.3. <code>const</code> Parameters and Arguments</h4>
<Badge type="info" text="Fundamental" />
<p>When we use parameters that are <code>const</code>, it is important to remember the discussion of top-level <code>const</code> from § <a href="024-2.4._const_qualifier.html#filepos504024">2.4.3</a> (p. <a href="024-2.4._const_qualifier.html#filepos504024">63</a>). As we saw in that section, a top-level <code>const</code> is one that applies to the object itself:</p>

```c++
const int ci = 42;     // we cannot change ci; const is top-level
int i = ci;            // ok: when we copy ci, its top-level const is ignored
int * const p = &i;    // const is top-level; we can't assign to p
*p = 0;                // ok: changes through p are allowed; i is now 0
```

<p>Just as in any other initialization, when we copy an argument to initialize a parameter, top-level <code>const</code>s are ignored. As a result, top-level <code>const</code> on parameters are ignored. We can pass either a <code>const</code> or a non<code>const</code> object to a parameter that has a top-level <code>const</code>:</p>

```c++
void fcn(const int i) { /* fcn can read but not write to i */ }
```

<p>We can call <code>fcn</code> passing it either a <code>const int</code> or a plain <code>int</code>. The fact that top-level <code>const</code>s are ignored on a parameter has one possibly surprising implication:</p>
<p><a id="filepos1483921"></a></p>

```c++
void fcn(const int i) { /* fcn can read but not write to i */ }
void fcn(int i) { /* . . . */ } // error: redefines fcn(int)
```

<p>In C++, we can define several different functions that have the same name. However, we can do so only if their parameter lists are sufficiently different. Because top-level <code>const</code>s are ignored, we can pass exactly the same types to either version of <code>fcn</code>. The second version of <code>fcn</code> is an error. Despite appearances, its parameter list doesn’t differ from the list in the first version of <code>fcn</code>.</p>
<h5>Pointer or Reference Parameters and <code>const</code></h5>
<p>Because parameters are initialized in the same way that variables are initialized, it can be helpful to remember the general initialization rules. We can initialize an object with a low-level <code>const</code> from a non<code>const</code> object but not vice versa, and a plain reference must be initialized from an object of the same type.</p>

```c++
int i = 42;
const int *cp = &i; // ok: but cp can't change i (§ 2.4.2 (p. 62))
const int &r = i;   // ok: but r can't change i (§ 2.4.1 (p. 61))
const int &r2 = 42; // ok: (§ 2.4.1 (p. 61))
int *p = cp;  // error: types of p and cp don't match (§ 2.4.2 (p. 62))
int &r3 = r;  // error: types of r3 and r don't match (§ 2.4.1 (p. 61))
int &r4 = 42; // error: can't initialize a plain reference from a literal (§ 2.3.1 (p. 50))
```

<p>Exactly the same initialization rules apply to parameter passing:</p>

```c++
int i = 0;
const int ci = i;
string::size_type ctr = 0;
reset(&i);   // calls the version of reset that has an int* parameter
reset(&ci);  // error: can't initialize an int* from a pointer to a const int object
reset(i);    // calls the version of reset that has an int& parameter
reset(ci);   // error: can't bind a plain reference to the const object ci
reset(42);   // error: can't bind a plain reference to a literal
reset(ctr);  // error: types don't match; ctr has an unsigned type
// ok: find_char's first parameter is a reference to const
find_char("Hello World!", 'o', ctr);
```

<p>We can call the reference version of <code>reset</code> (§ <a href="064-6.2._argument_passing.html#filepos1462468">6.2.2</a>, p. <a href="064-6.2._argument_passing.html#filepos1462468">210</a>) only on <code>int</code> objects. We cannot pass a literal, an expression that evaluates to an <code>int</code>, an object that requires conversion, or a <code>const int</code> object. Similarly, we may pass only an <code>int*</code> to the pointer version of <code>reset</code> (§ <a href="064-6.2._argument_passing.html#filepos1453096">6.2.1</a>, p. <a href="064-6.2._argument_passing.html#filepos1453096">209</a>). On the other hand, we can pass a string literal as the first argument to <code>find_char</code> (§ <a href="064-6.2._argument_passing.html#filepos1462468">6.2.2</a>, p. <a href="064-6.2._argument_passing.html#filepos1462468">211</a>). That function’s reference parameter is a reference to <code>const</code>, and we can initialize references to <code>const</code> from literals.</p>
<h5>Use Reference to <code>const</code> When Possible</h5>
<Badge type="warning" text="Tricky" />
<p>It is a somewhat common mistake to define parameters that a function does not change as (plain) references. Doing so gives the function’s caller the misleading impression that the function might change its argument’s value. Moreover, using a <a id="filepos1493334"></a>reference instead of a reference to <code>const</code> unduly limits the type of arguments that can be used with the function. As we’ve just seen, we cannot pass a <code>const</code> object, or a literal, or an object that requires conversion to a plain reference parameter.</p>
<p>The effect of this mistake can be surprisingly pervasive. As an example, consider our <code>find_char</code> function from § <a href="064-6.2._argument_passing.html#filepos1462468">6.2.2</a> (p. <a href="064-6.2._argument_passing.html#filepos1462468">211</a>). That function (correctly) made its <code>string</code> parameter a reference to <code>const</code>. Had we defined that parameter as a plain <code>string&amp;</code>:</p>

```c++
// bad design: the first parameter should be a const string&
string::size_type find_char(string &s, char c,
                           string::size_type &occurs);
```

<p>we could call <code>find_char</code> only on a <code>string</code> object. A call such as</p>

```c++
find_char("Hello World", 'o', ctr);
```

<p>would fail at compile time.</p>
<p>More subtly, we could not use this version of <code>find_char</code> from other functions that (correctly) define their parameters as references to <code>const</code>. For example, we might want to use <code>find_char</code> inside a function that determines whether a <code>string</code> represents a sentence:</p>

```c++
bool is_sentence(const string &s)
{
    // if there's a single period at the end of s, then s is a sentence
    string::size_type ctr = 0;
    return find_char(s, '.', ctr) == s.size() - 1 && ctr == 1;
}
```

<p>If <code>find_char</code> took a plain <code>string&amp;</code>, then this call to <code>find_char</code> would be a compile-time error. The problem is that <code>s</code> is a reference to a <code>const string</code>, but <code>find_char</code> was (incorrectly) defined to take a plain reference.</p>
<p>It might be tempting to try to fix this problem by changing the type of the parameter in <code>is_sentence</code>. But that fix only propagates the error—callers of <code>is_sentence</code> could pass only non<code>const string</code>s.</p>
<p>The right way to fix this problem is to fix the parameter in <code>find_char</code>. If it’s not possible to change <code>find_char</code>, then define a local <code>string</code> copy of <code>s</code> inside <code>is_sentence</code> and pass that <code>string</code> to <code>find_char</code>.</p>
<h4 id="filepos1499104">6.2.4. Array Parameters</h4>
<p>Arrays have two special properties that affect how we define and use functions that operate on arrays: We cannot copy an array (§ <a href="034-3.5._arrays.html#filepos855259">3.5.1</a>, p. <a href="034-3.5._arrays.html#filepos855259">114</a>), and when we use an array it is (usually) converted to a pointer (§ <a href="034-3.5._arrays.html#filepos881970">3.5.3</a>, p. <a href="034-3.5._arrays.html#filepos881970">117</a>). Because we cannot copy an array, we cannot pass an array by value. Because arrays are converted to pointers, when we pass an array to a function, we are actually passing a pointer to the array’s first element.</p>
<p>Even though we cannot pass an array by value, we can write a parameter that looks like an array:</p>

::: info
<a id="filepos1500012"></a><p>Exercises Section 6.2.3</p>
<p><strong>Exercise 6.16:</strong> The following function, although legal, is less useful than it might be. Identify and correct the limitation on this function:</p>

```c++
bool is_empty(string& s) { return s.empty(); }
```

<p><strong>Exercise 6.17:</strong> Write a function to determine whether a <code>string</code> contains any capital letters. Write a function to change a <code>string</code> to all lowercase. Do the parameters you used in these functions have the same type? If so, why? If not, why not?</p>
<p><strong>Exercise 6.18:</strong> Write declarations for each of the following functions. When you write these declarations, use the name of the function to indicate what the function does.</p>
<p><strong>(a)</strong> A function named <code>compare</code> that returns a <code>bool</code> and has two parameters that are references to a class named <code>matrix</code>.</p>
<p><strong>(b)</strong> A function named <code>change_val</code> that returns a <code>vector&lt;int&gt;</code> iterator and takes two parameters: One is an <code>int</code> and the other is an iterator for a <code>vector&lt;int&gt;</code>.</p>
<p><strong>Exercise 6.19:</strong> Given the following declarations, determine which calls are legal and which are illegal. For those that are illegal, explain why.</p>

```c++
double calc(double);
int count(const string &, char);
int sum(vector<int>::iterator, vector<int>::iterator, int);
vector<int> vec(10);
```

<p><strong>(a)</strong>
<code>calc(23.4, 55.1);</code></p>
<p><strong>(b)</strong>
<code>count("abcda", 'a');</code></p>
<p><strong>(c)</strong>
<code>calc(66);</code></p>
<p><strong>(d)</strong>
<code>sum(vec.begin(), vec.end(), 3.8);</code></p>
<p><strong>Exercise 6.20:</strong> When should reference parameters be references to <code>const</code>? What happens if we make a parameter a plain reference when it could be a reference to <code>const</code>?</p>
:::

```c++
// despite appearances, these three declarations of print are equivalent
// each function has a single parameter of type const int*
void print(const int*);
void print(const int[]);   // shows the intent that the function takes an array
void print(const int[10]); // dimension for documentation purposes (at best)
```

<p>Regardless of appearances, these declarations are equivalent: Each declares a function with a single parameter of type <code>const int*</code>. When the compiler checks a call to <code>print</code>, it checks only that the argument has type <code>const int*</code>:</p>

```c++
int i = 0, j[2] = {0, 1};
print(&i); // ok: &i is int*
print(j);  // ok: j is converted to an int* that points to j[0]
```

<p>If we pass an array to <code>print</code>, that argument is automatically converted to a pointer to the first element in the array; the size of the array is irrelevant.</p>

::: warning
<p>As with any code that uses arrays, functions that take array parameters must ensure that all uses of the array stay within the array bounds.</p>
:::

<p><a id="filepos1507824"></a>Because arrays are passed as pointers, functions ordinarily don’t know the size of the array they are given. They must rely on additional information provided by the caller. There are three common techniques used to manage pointer parameters.</p>
<h5>Using a Marker to Specify the Extent of an Array</h5>
<p>The first approach to managing array arguments requires the array itself to contain an end marker. C-style character strings (§ <a href="034-3.5._arrays.html#filepos918393">3.5.4</a>, p. <a href="034-3.5._arrays.html#filepos918393">122</a>) are an example of this approach. C-style strings are stored in character arrays in which the last character of the string is followed by a null character. Functions that deal with C-style strings stop processing the array when they see a null character:</p>

```c++
void print(const char *cp)
{
    if (cp)          // if cp is not a null pointer
        while (*cp)  // so long as the character it points to is not a null character
            cout << *cp++; // print the character and advance the pointer
}
```

<p>This convention works well for data where there is an obvious end-marker value (like the null character) that does not appear in ordinary data. It works less well with data, such as <code>int</code>s, where every value in the range is a legitimate value.</p>
<h5>Using the Standard Library Conventions</h5>
<p>A second technique used to manage array arguments is to pass pointers to the first and one past the last element in the array. This approach is inspired by techniques used in the standard library. We’ll learn more about this style of programming in <a href="081-part_ii_the_cpp_library.html#filepos2066884">Part II</a>. Using this approach, we’ll print the elements in an array as follows:</p>

```c++
void print(const int *beg, const int *end)
{
    // print every element starting at beg up to but not including end
    while (beg != end)
        cout << *beg++ << endl; // print the current element
                                // and advance the pointer
}
```

<p>The <code>while</code> uses the dereference and postfix increment operators (§ <a href="043-4.5._increment_and_decrement_operators.html#filepos1087530">4.5</a>, p. <a href="043-4.5._increment_and_decrement_operators.html#filepos1087530">148</a>) to print the current element and advance <code>beg</code> one element at a time through the array. The loop stops when <code>beg</code> is equal to <code>end</code>.</p>
<p>To call this function, we pass two pointers—one to the first element we want to print and one just past the last element:</p>

```c++
int j[2] = {0, 1};
// j is converted to a pointer to the first element in j
// the second argument is a pointer to one past the end of j
print(begin(j), end(j)); // begin and end functions, see § 3.5.3 (p. 118)
```

<p>This function is safe, as long as the caller correctly calculates the pointers. Here we let the library <code>begin</code> and <code>end</code> functions (§ <a href="034-3.5._arrays.html#filepos881970">3.5.3</a>, p. <a href="034-3.5._arrays.html#filepos881970">118</a>) provide those pointers.</p>
<h5><a id="filepos1514313"></a>Explicitly Passing a Size Parameter</h5>
<p>A third approach for array arguments, which is common in C programs and older C++ programs, is to define a second parameter that indicates the size of the array. Using this approach, we’ll rewrite <code>print</code> as follows:</p>

```c++
// const int ia[] is equivalent to const int* ia
// size is passed explicitly and used to control access to elements of ia
void print(const int ia[], size_t size)
{
    for (size_t i = 0; i != size; ++i) {
        cout << ia[i] << endl;
    }
}
```

<p>This version uses the <code>size</code> parameter to determine how many elements there are to print. When we call <code>print</code>, we must pass this additional parameter:</p>

```c++
int j[] = { 0, 1 };  // int array of size 2
print(j, end(j) - begin(j));
```

<p>The function executes safely as long as the size passed is no greater than the actual size of the array.</p>
<h5>Array Parameters and <code>const</code></h5>
<p>Note that all three versions of our <code>print</code> function defined their array parameters as pointers to <code>const</code>. The discussion in § <a href="064-6.2._argument_passing.html#filepos1479382">6.2.3</a> (p. <a href="064-6.2._argument_passing.html#filepos1479382">213</a>) applies equally to pointers as to references. When a function does not need write access to the array elements, the array parameter should be a pointer to <code>const</code> (§ <a href="024-2.4._const_qualifier.html#filepos491891">2.4.2</a>, p. <a href="024-2.4._const_qualifier.html#filepos491891">62</a>). A parameter should be a plain pointer to a non<code>const</code> type only if the function needs to change element values.</p>
<h5>Array Reference Parameters</h5>
<p>Just as we can define a variable that is a reference to an array (§ <a href="034-3.5._arrays.html#filepos855259">3.5.1</a>, p. <a href="034-3.5._arrays.html#filepos855259">114</a>), we can define a parameter that is a reference to an array. As usual, the reference parameter is bound to the corresponding argument, which in this case is an array:</p>

```c++
// ok: parameter is a reference to an array; the dimension is part of the type
void print(int (&arr)[10])
{
    for (auto elem : arr)
        cout << elem << endl;
}
```

::: info
<p>The parentheses around <code>&amp;arr</code> are necessary (§ <a href="034-3.5._arrays.html#filepos855259">3.5.1</a>, p. <a href="034-3.5._arrays.html#filepos855259">114</a>):</p>

```c++
f(int &arr[10])   // error: declares arr as an array of references
f(int (&arr)[10]) // ok: arr is a reference to an array of ten ints
```

:::

<p><a id="filepos1520481"></a>Because the size of an array is part of its type, it is safe to rely on the dimension in the body of the function. However, the fact that the size is part of the type limits the usefulness of this version of <code>print</code>. We may call this function only for an array of exactly ten <code>int</code>s:</p>

```c++
int i = 0, j[2] = {0, 1};
int k[10] = {0,1,2,3,4,5,6,7,8,9};
print(&i);   // error: argument is not an array of ten ints
print(j);    // error: argument is not an array of ten ints
print(k);    // ok: argument is an array of ten ints
```

<p>We’ll see in § <a href="154-16.1._defining_a_template.html#filepos4156441">16.1.1</a> (p. <a href="154-16.1._defining_a_template.html#filepos4156441">654</a>) how we might write this function in a way that would allow us to pass a reference parameter to an array of any size.</p>
<h5>Passing a Multidimensional Array</h5>
<p>Recall that there are no multidimensional arrays in C++ (§ <a href="035-3.6._multidimensional_arrays.html#filepos942882">3.6</a>, p. <a href="035-3.6._multidimensional_arrays.html#filepos942882">125</a>). Instead, what appears to be a multidimensional array is an array of arrays.</p>
<p>As with any array, a multidimensional array is passed as a pointer to its first element (§ <a href="035-3.6._multidimensional_arrays.html#filepos942882">3.6</a>, p. <a href="035-3.6._multidimensional_arrays.html#filepos942882">128</a>). Because we are dealing with an array of arrays, that element is an array, so the pointer is a pointer to an array. The size of the second (and any subsequent) dimension is part of the element type and must be specified:</p>

```c++
// matrix points to the first element in an array whose elements are arrays of ten ints
void print(int (*matrix)[10], int rowSize) { /* . . . */ }
```

<p>declares <code>matrix</code> as a pointer to an array of ten <code>int</code>s.</p>

::: info
<p>Again, the parentheses around <code>*matrix</code> are necessary:</p>

```c++
int *matrix[10];   // array of ten pointers
int (*matrix)[10]; // pointer to an array of ten ints
```

:::

<p>We can also define our function using array syntax. As usual, the compiler ignores the first dimension, so it is best not to include it:</p>

```c++
// equivalent definition
void print(int matrix[][10], int rowSize) { /* . . . */ }
```

<p>declares <code>matrix</code> to be what looks like a two-dimensional array. In fact, the parameter is a pointer to an array of ten <code>int</code>s.</p>
<h4 id="filepos1526324">6.2.5. <code>main</code>: Handling Command-Line Options</h4>
<p>It turns out that <code>main</code> is a good example of how C++ programs pass arrays to functions. Up to now, we have defined <code>main</code> with an empty parameter list:</p>

```c++
int main() { ... }
```

<p>However, we sometimes need to pass arguments to <code>main</code>. The most common use of arguments to <code>main</code> is to let the user specify a set of options to guide the operation of the program. For example, assuming our <code>main</code> program is in an executable file named <code>prog</code>, we might pass options to the program as follows:</p>

::: info
<a id="filepos1527699"></a><p>Exercises Section 6.2.4</p>
<p><strong>Exercise 6.21:</strong> Write a function that takes an <code>int</code> and a pointer to an <code>int</code> and returns the larger of the <code>int</code> value or the value to which the pointer points. What type should you use for the pointer?</p>
<p><strong>Exercise 6.22:</strong> Write a function to swap two <code>int</code> pointers.</p>
<p><strong>Exercise 6.23:</strong> Write your own versions of each of the <code>print</code> functions presented in this section. Call each of these functions to print <code>i</code> and <code>j</code> defined as follows:</p>

```c++
int i = 0, j[2] = {0, 1};
```

<p><strong>Exercise 6.24:</strong> Explain the behavior of the following function. If there are problems in the code, explain what they are and how you might fix them.</p>

```c++
void print(const int ia[10])
{
    for (size_t i = 0; i != 10; ++i)
        cout << ia[i] << endl;
}
```

:::

```shellscript
prog -d -o ofile data0
```

<p>Such command-line options are passed to <code>main</code> in two (optional) parameters:</p>

```c++
int main(int argc, char *argv[]) { ... }
```

<p>The second parameter, <code>argv</code>, is an array of pointers to C-style character strings. The first parameter, <code>argc</code>, passes the number of strings in that array. Because the second parameter is an array, we might alternatively define <code>main</code> as</p>

```c++
int main(int argc, char **argv) { ... }
```

<p>indicating that <code>argv</code> points to a <code>char*</code>.</p>
<p>When arguments are passed to <code>main</code>, the first element in <code>argv</code> points either to the name of the program or to the empty string. Subsequent elements pass the arguments provided on the command line. The element just past the last pointer is guaranteed to be 0.</p>
<p>Given the previous command line, <code>argc</code> would be 5, and <code>argv</code> would hold the following C-style character strings:</p>

```c++
argv[0] = "prog";   // or argv[0] might point to an empty string
argv[1] = "-d";
argv[2] = "-o";
argv[3] = "ofile";
argv[4] = "data0";
argv[5] = 0;
```

::: warning
<p>When you use the arguments in <code>argv</code>, remember that the optional arguments begin in <code>argv[1]</code>; <code>argv[0]</code> contains the program’s name, not user input.</p>
:::

::: info
<a id="filepos1533816"></a><p>Exercises Section 6.2.5</p>
<p><strong>Exercise 6.25:</strong> Write a <code>main</code> function that takes two arguments. Concatenate the supplied arguments and print the resulting <code>string</code>.</p>
<p><strong>Exercise 6.26:</strong> Write a program that accepts the options presented in this section. Print the values of the arguments passed to <code>main</code>.</p>
:::

<h4 id="filepos1534679">6.2.6. Functions with Varying Parameters</h4>
<p>Sometimes we do not know in advance how many arguments we need to pass to a function. For example, we might want to write a routine to print error messages generated from our program. We’d like to use a single function to print these error messages in order to handle them in a uniform way. However, different calls to our error-printing function might pass different arguments, corresponding to different kinds of error messages.</p>
<p>The new standard provides two primary ways to write a function that takes a varying number of arguments: If all the arguments have the same type, we can pass a library type named <code>initializer_list</code>. If the argument types vary, we can write a special kind of function, known as a variadic template, which we’ll cover in § <a href="157-16.4._variadic_templates.html#filepos4464798">16.4</a> (p. <a href="157-16.4._variadic_templates.html#filepos4464798">699</a>).</p>
<p>C++ also has a special parameter type, ellipsis, that can be used to pass a varying number of arguments. We’ll look briefly at ellipsis parameters in this section. However, it is worth noting that this facility ordinarily should be used only in programs that need to interface to C functions.</p>
<h5><code>initializer_list</code> Parameters</h5>
<a id="filepos1536414"></a><Badge type="tip" text="C++11" />
<p>We can write a function that takes an unknown number of arguments of a single type by using an <code>initializer_list</code> parameter. An <code>initializer_list</code> is a library type that represents an array (§ <a href="034-3.5._arrays.html#filepos853883">3.5</a>, p. <a href="034-3.5._arrays.html#filepos853883">113</a>) of values of the specified type. This type is defined in the <code>initializer_list</code> header. The operations that <code>initializer_list</code> provides are listed in <a href="064-6.2._argument_passing.html#filepos1537380">Table 6.1</a>.</p>
<p><a id="filepos1537380"></a>Table 6.1. Operations on <code>initializer_list</code>s</p>

| Statement                                 | Description                                                                                                                                      |
|-------------------------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------|
| `initializer_list<T> lst;`                | Default initialization; an empty list of elements of type `T`.                                                                                   |
| `initializer_list<T> lst {a, b, c, ...};` | `lst` has as many elements as there are initializers; elements are copies of the corresponding initializers. Elements in the list are `const`.   |
| `lst2(lst)` `lst2 = lst`                  | Copying or assigning an `initializer_list` does not copy the elements in the list. After the copy, the original and the copy share the elements. |
| `lst.size()`                              | Number of elements in the list.                                                                                                                  |
| `lst.begin()` `lst.end()`                 | Returns a pointer to the first and one past the last element in `lst`.                                                                           |

<p><a id="filepos1537712"></a>Like a <code>vector</code>, <code>initializer_list</code> is a template type (§ <a href="032-3.3._library_vector_type.html#filepos736471">3.3</a>, p. <a href="032-3.3._library_vector_type.html#filepos736471">96</a>). When we define an <code>initializer_list</code>, we must specify the type of the elements that the list will contain:</p>

```c++
initializer_list<string> ls; // initializer_list of strings
initializer_list<int> li;    // initializer_list of ints
```

<p>Unlike <code>vector</code>, the elements in an <code>initializer_list</code> are always <code>const</code> values; there is no way to change the value of an element in an <code>initializer_list</code>.</p>
<p>We can write our function to produce error messages from a varying number of arguments as follows:</p>

```c++
void error_msg(initializer_list<string> il)
{
    for (auto beg = il.begin(); beg != il.end(); ++beg)
        cout << *beg << " " ;
    cout << endl;
}
```

<p>The <code>begin</code> and <code>end</code> operations on <code>initializer_list</code> objects are analogous to the corresponding <code>vector</code> members (§ <a href="033-3.4._introducing_iterators.html#filepos804727">3.4.1</a>, p. <a href="033-3.4._introducing_iterators.html#filepos804727">106</a>). The <code>begin()</code> member gives us a pointer to the first element in the list, and <code>end()</code> is an off-the-end pointer one past the last element. Our function initializes <code>beg</code> to denote the first element and iterates through each element in the <code>initializer_list</code>. In the body of the loop we dereference <code>beg</code> in order to access the current element and print its value.</p>
<p>When we pass a sequence of values to an <code>initializer_list</code> parameter, we must enclose the sequence in curly braces:</p>

```c++
// expected, actual are strings
if (expected != actual)
    error_msg({"functionX", expected, actual});
else
    error_msg({"functionX", "okay"});
```

<p>Here we’re calling the same function, <code>error_msg</code>, passing three values in the first call and two values in the second.</p>
<p>A function with an <code>initializer_list</code> parameter can have other parameters as well. For example, our debugging system might have a class, named <code>ErrCode</code>, that represents various kinds of errors. We can revise our program to take an <code>ErrCode</code> in addition to an <code>initializer_list</code> as follows:</p>

```c++
void error_msg(ErrCode e, initializer_list<string> il)
{
    cout << e.msg() << ": ";
    for (const auto &elem : il)
        cout << elem << " " ;
    cout << endl;
}
```

<p>Because <code>initializer_list</code> has <code>begin</code> and <code>end</code> members, we can use a range <code>for</code> (§ <a href="057-5.4._iterative_statements.html#filepos1331917">5.4.3</a>, p. <a href="057-5.4._iterative_statements.html#filepos1331917">187</a>) to process the elements. This program, like our previous version, iterates an element at a time through the braced list of values passed to the <code>il</code> parameter.</p>
<p><a id="filepos1544813"></a>To call this version, we need to revise our calls to pass an <code>ErrCode</code> argument:</p>

```c++
if (expected != actual)
    error_msg(ErrCode(42), {"functionX", expected, actual});
else
    error_msg(ErrCode(0), {"functionX", "okay"});
```

<h5>Ellipsis Parameters</h5>
<Badge type="danger" text="Advanced" />
<p>Ellipsis parameters are in C++ to allow programs to interface to C code that uses a C library facility named <code>varargs</code>. Generally an ellipsis parameter should not be used for other purposes. Your C compiler documentation will describe how to use <code>varargs</code>.</p>

::: warning
<p>Ellipsis parameters should be used only for types that are common to both C and C++. In particular, objects of most class types are not copied properly when passed to an ellipsis parameter.</p>
:::

<p>An ellipsis parameter may appear only as the last element in a parameter list and may take either of two forms:</p>

```c++
void foo(parm_list, ...);
void foo(...);
```

<p>The first form specifies the type(s) for some of <code>foo</code>’s parameters. Arguments that correspond to the specified parameters are type checked as usual. No type checking is done for the arguments that correspond to the ellipsis parameter. In this first form, the comma following the parameter declarations is optional.</p>

::: info
<p>Exercises Section 6.2.6</p>
<p><strong>Exercise 6.27:</strong> Write a function that takes an <code>initializer_list&lt;int&gt;</code> and produces the sum of the elements in the list.</p>
<p><strong>Exercise 6.28:</strong> In the second version of <code>error_msg</code> that has an <code>ErrCode</code> parameter, what is the type of <code>elem</code> in the <code>for</code> loop?</p>
<p><strong>Exercise 6.29:</strong> When you use an <code>initializer_list</code> in a range <code>for</code> would you ever use a reference as the loop control variable? If so, why? If not, why not?</p>
:::

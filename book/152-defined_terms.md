<h3 id="filepos4139953">Defined Terms</h3><ul><li><p><a href="145-15.4._abstract_base_classes.html#filepos3892498" id="filepos4140092"><strong>abstract base class</strong></a> Class that has one or more pure virtual functions. We cannot create objects of an abstract base-class type.</p></li><li><p><a href="146-15.5._access_control_and_inheritance.html#filepos3901937" id="filepos4140381"><strong>accessible</strong></a> Base class member that can be used through a derived object. Accessibility depends on the access specifier used in derivation list of the derived class and the access level of the member in the base class. For example, a <code>public</code> member of a class that is inherited via <code>public</code> inheritance is accessible to users of the derived class. A <code>public</code> base class member is inacceessible if the inheritance is <code>private</code>.</p></li><li><p><a href="142-15.1._oop_an_overview.html#filepos3783382" id="filepos4141212"><strong>base class</strong></a> Class from which other classes inherit. The members of the base class become members of the derived class.</p></li><li><p><a href="142-15.1._oop_an_overview.html#filepos3786652" id="filepos4141491"><strong>class derivation list</strong></a> List of base classes, each of which may have an optional access level, from which a derived class inherits. If no access specifier is provided, the inheritance is <code>public</code> if the derived class is defined with the <code>struct</code> keyword, and is <code>private</code> if the class is defined with the <code>class</code> keyword.</p></li><li><p><a href="142-15.1._oop_an_overview.html#filepos3783584" id="filepos4142216"><strong>derived class</strong></a> Class that inherits from another class. A derived class can override the virtuals of its base and can define new members. A derived-class scope is nested in the scope of its base class(es); members of the derived class can use members of the base class directly.</p></li><li><p><a href="143-15.2._defining_base_and_derived_classes.html#filepos3816769" id="filepos4142654"><strong>derived-to-base conversion</strong></a> Implicit conversion of a derived object to a reference to a base class, or of a pointer to a derived object to a pointer to the base type.</p></li><li><p><a href="143-15.2._defining_base_and_derived_classes.html#filepos3832397" id="filepos4142981"><strong>direct base class</strong></a> Base class from which a derived class inherits directly. Direct base classes are specified in the derivation list of <a id="filepos4143178"></a>the derived class. A direct base class may itself be a derived class.</p></li><li><p><a href="142-15.1._oop_an_overview.html#filepos3788879" id="filepos4143355"><strong>dynamic binding</strong></a> Delaying until run time the selection of which function to run. In C++, dynamic binding refers to the runtime choice of which virtual function to run based on the underlying type of the object to which a reference or pointer is bound.</p></li><li><p><a href="143-15.2._defining_base_and_derived_classes.html#filepos3840996" id="filepos4143767"><strong>dynamic type</strong></a> Type of an object at run time. The dynamic type of an object to which a reference refers or to which a pointer points may differ from the static type of the reference or pointer. A pointer or reference to a base-class type can refer to an to object of derived type. In such cases the static type is reference (or pointer) to base, but the dynamic type is reference (or pointer) to derived.</p></li><li><p><a href="143-15.2._defining_base_and_derived_classes.html#filepos3832546" id="filepos4144331"><strong>indirect base class</strong></a> Base class that does not appear in the derivation list of a derived class. A class from which the direct base class inherits, directly or indirectly, is an indirect base class to the derived class.</p></li><li><p><a href="142-15.1._oop_an_overview.html#filepos3783270" id="filepos4144710"><strong>inheritance</strong></a> Programming technique for defining a new class (known as a derived class) in terms of an existing class (known as the base class). The derived class inherits the members of the base class.</p></li><li><p><a href="142-15.1._oop_an_overview.html#filepos3782637" id="filepos4145072"><strong>object-oriented programming</strong></a> Method of writing programs using data abstraction, inheritance, and dynamic binding.</p></li><li><p><a href="142-15.1._oop_an_overview.html#filepos3788507" id="filepos4145346"><strong>override</strong></a> Virtual function defined in a derived class that has the same parameter list as a virtual in a base class overrides the base-class definition.</p></li><li><p><strong>polymorphism</strong> As used in object-oriented programming, refers to the ability to obtain type-specific behavior based on the dynamic type of a reference or pointer.</p></li><li><p><strong>private inheritance</strong> In <code>private</code> inheritance, the <code>public</code> and <code>protected</code> members of the base class are <code>private</code> members of the derived.</p></li><li><p><strong>protected access specifier</strong> Members defined after the <code>protected</code> keyword may be accessed by the members and friends of a derived class. However, these members are only accessible through derived objects. <code>protected</code> members are not accessible to ordinary users of the class.</p></li><li><p><a href="146-15.5._access_control_and_inheritance.html#filepos3908698" id="filepos4146972"><strong>protected inheritance</strong></a> In <code>protected</code> inheritance, the <code>protected</code> and <code>public</code> members of the base class are <code>protected</code> members of the derived class.</p></li><li><p><strong>public inheritance</strong> The <code>public</code> interface of the base class is part of the <code>public</code> interface of the derived class.</p></li><li><p><a href="145-15.4._abstract_base_classes.html#filepos3888708" id="filepos4147890"><strong>pure virtual</strong></a> Virtual function declared in the class header using <code>= 0</code> just before the semicolon. A pure virtual function need not be (but may be) defined. Classes with pure virtuals are abstract classes. If a derived class does not define its own version of an inherited pure virtual, then the derived class is abstract as well.</p></li><li><p><a href="145-15.4._abstract_base_classes.html#filepos3899552" id="filepos4148442"><strong>refactoring</strong></a> Redesigning programs to collect related parts into a single abstraction, replacing the original code with uses of the new abstraction. Typically, classes are refactored to move data or function members to the highest common point in the hierarchy to avoid code duplication.</p></li><li><p><a href="142-15.1._oop_an_overview.html#filepos3795220" id="filepos4148889"><strong>run-time binding</strong></a> See dynamic binding.</p></li><li><p><a href="143-15.2._defining_base_and_derived_classes.html#filepos3852622" id="filepos4149088"><strong>sliced down</strong></a> What happens when an object of derived type is used to initialize or assign an object of the base type. The derived portion of the object is “sliced down,” leaving only the base portion, which is assigned to the base.</p></li><li><p><a href="143-15.2._defining_base_and_derived_classes.html#filepos3840881" id="filepos4149491"><strong>static type</strong></a> Type with which a variable is defined or that an expression yields. Static type is known at compile time.</p></li><li><p><strong>virtual function</strong> Member function that defines type-specific behavior. Calls to a virtual made through a reference or pointer are resolved at run time, based on the type of the object to which the reference or pointer is bound.</p></li>
 
</ul>

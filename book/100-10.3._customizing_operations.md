<h3 id="filepos2519145">10.3. Customizing Operations</h3>
<p>Many of the algorithms compare elements in the input sequence. By default, such algorithms use either the element type’s <code>&lt;</code> or <code>==</code> operator. The library also defines versions of these algorithms that let us supply our own operation to use in place of the default operator.</p>
<p><a id="filepos2519746"></a>For example, the <code>sort</code> algorithm uses the element type’s <code>&lt;</code> operator. However, we might want to sort a sequence into a different order from that defined by <code>&lt;</code>, or our sequence might have elements of a type (such as <code>Sales_data</code>) that does not have a <code>&lt;</code> operator. In both cases, we need to override the default behavior of <code>sort</code>.</p>
<h4 id="filepos2520495">10.3.1. Passing a Function to an Algorithm</h4>
<img alt="Image" src="/images/00009.jpg"/>
<p>As one example, assume that we want to print the <code>vector</code> after we call <code>elimDups</code> (§ <a href="099-10.2._a_first_look_at_the_algorithms.html#filepos2506543">10.2.3</a>, p. <a href="099-10.2._a_first_look_at_the_algorithms.html#filepos2506543">384</a>). However, we’ll also assume that we want to see the words ordered by their size, and then alphabetically within each size. To reorder the <code>vector</code> by length, we’ll use a second, overloaded version of <code>sort</code>. This version of <code>sort</code> takes a third argument that is a <strong><a href="105-defined_terms.html#filepos2716674" id="filepos2521451">predicate</a></strong>.</p>
<h5>Predicates</h5>
<p>A predicate is an expression that can be called and that returns a value that can be used as a condition. The predicates used by library algorithms are either <strong><a href="105-defined_terms.html#filepos2718411" id="filepos2521820">unary predicates</a></strong> (meaning they have a single parameter) or <strong><a href="105-defined_terms.html#filepos2710462" id="filepos2521940">binary predicates</a></strong> (meaning they have two parameters). The algorithms that take predicates call the given predicate on the elements in the input range. As a result, it must be possible to convert the element type to the parameter type of the predicate.</p>
<p>The version of <code>sort</code> that takes a binary predicate uses the given predicate in place of <code>&lt;</code> to compare elements. The predicates that we supply to <code>sort</code> must meet the requirements that we’ll describe in § <a href="108-11.2._overview_of_the_associative_containers.html#filepos2751456">11.2.2</a> (p. <a href="108-11.2._overview_of_the_associative_containers.html#filepos2751456">425</a>). For now, what we need to know is that the operation must define a consistent order for all possible elements in the input sequence. Our <code>isShorter</code> function from § <a href="064-6.2._argument_passing.html#filepos1462468">6.2.2</a> (p. <a href="064-6.2._argument_passing.html#filepos1462468">211</a>) is an example of a function that meets these requirements, so we can pass <code>isShorter</code> to <code>sort</code>. Doing so will reorder the elements by size:</p>

```c++
// comparison function to be used to sort by word length
bool isShorter(const string &s1, const string &s2)
{
    return s1.size() < s2.size();
}
// sort on word length, shortest to longest
sort(words.begin(), words.end(), isShorter);
```

<p>If <code>words</code> contains the same data as in § <a href="099-10.2._a_first_look_at_the_algorithms.html#filepos2506543">10.2.3</a> (p. <a href="099-10.2._a_first_look_at_the_algorithms.html#filepos2506543">384</a>), this call would reorder <code>words</code> so that all the words of length 3 appear before words of length 4, which in turn are followed by words of length 5, and so on.</p>
<h5>Sorting Algorithms</h5>
<p>When we sort <code>words</code> by size, we also want to maintain alphabetic order among the elements that have the same length. To keep the words of the same length in alphabetical order we can use the <code>stable_sort</code> algorithm. A stable sort maintains the original order among equal elements.</p>
<p>Ordinarily, we don’t care about the relative order of equal elements in a sorted sequence. After all, they’re equal. However, in this case, we have defined “equal” <a id="filepos2525318"></a>to mean “have the same length.” Elements that have the same length still differ from one another when we view their contents. By calling <code>stable_sort</code>, we can maintain alphabetical order among those elements that have the same length:</p>

```c++
elimDups(words); // put words in alphabetical order and remove duplicates
// resort by length, maintaining alphabetical order among words of the same length
stable_sort(words.begin(), words.end(), isShorter);
for (const auto &s : words)  // no need to copy the strings
    cout << s << " ";  // print each element separated by a space
cout << endl;
```

<p>Assuming <code>words</code> was in alphabetical order before this call, after the call, <code>words</code> will be sorted by element size, and the words of each length remain in alphabetical order. If we run this code on our original <code>vector</code>, the output will be</p>

```
fox red the over slow jumps quick turtle
```

::: info
<p>Exercises Section 10.3.1</p>
<p><strong>Exercise 10.11:</strong> Write a program that uses <code>stable_sort</code> and <code>isShorter</code> to sort a <code>vector</code> passed to your version of <code>elimDups</code>. Print the <code>vector</code> to verify that your program is correct.</p>
<p><a id="filepos2528435"></a><strong>Exercise 10.12:</strong> Write a function named <code>compareIsbn</code> that compares the <code>isbn()</code> members of two <code>Sales_data</code> objects. Use that function to <code>sort</code> a <code>vector</code> that holds <code>Sales_data</code> objects.</p>
<p><a id="filepos2529100"></a><strong>Exercise 10.13:</strong> The library defines an algorithm named <code>partition</code> that takes a predicate and partitions the container so that values for which the predicate is <code>true</code> appear in the first part and those for which the predicate is <code>false</code> appear in the second part. The algorithm returns an iterator just past the last element for which the predicate returned <code>true</code>. Write a function that takes a <code>string</code> and returns a <code>bool</code> indicating whether the <code>string</code> has five characters or more. Use that function to partition <code>words</code>. Print the elements that have five or more characters.</p>
:::

<h4 id="filepos2530282">10.3.2. Lambda Expressions</h4>
<p>The predicates we pass to an algorithm must have exactly one or two parameters, depending on whether the algorithm takes a unary or binary predicate, respectively. However, sometimes we want to do processing that requires more arguments than the algorithm’s predicate allows. For example, the solution you wrote for the last exercise in the previous section had to hard-wire the size 5 into the predicate used to partition the sequence. It would be move useful to be able to partition a sequence without having to write a separate predicate for every possible size.</p>
<p>As a related example, we’ll revise our program from § <a href="100-10.3._customizing_operations.html#filepos2520495">10.3.1</a> (p. <a href="100-10.3._customizing_operations.html#filepos2520495">387</a>) to report how many words are of a given size or greater. We’ll also change the output so that it prints only the words of the given length or greater.</p>
<p>A sketch of this function, which we’ll name <code>biggies</code>, is as follows:</p>
<p><a id="filepos2531609"></a></p>

```c++
void biggies(vector<string> &words,
             vector<string>::size_type sz)
{
    elimDups(words); // put words in alphabetical order and remove duplicates
    // resort by length, maintaining alphabetical order among words of the same length
    stable_sort(words.begin(), words.end(), isShorter);
    // get an iterator to the first element whose size() is >= sz
    // compute the number of elements with size >= sz
    // print words of the given size or longer, each one followed by a space
}
```

<p>Our new problem is to find the first element in the <code>vector</code> that has the given size. Once we know that element, we can use its position to compute how many elements have that size or greater.</p>
<p>We can use the library <code>find_if</code> algorithm to find an element that has a particular size. Like <code>find</code> (§ <a href="098-10.1._overview.html#filepos2458324">10.1</a>, p. <a href="098-10.1._overview.html#filepos2458324">376</a>), the <code>find_if</code> algorithm takes a pair of iterators denoting a range. Unlike <code>find</code>, the third argument to <code>find_if</code> is a predicate. The <code>find_if</code> algorithm calls the given predicate on each element in the input range. It returns the first element for which the predicate returns a nonzero value, or its end iterator if no such element is found.</p>
<p>It would be easy to write a function that takes a <code>string</code> and a size and returns a <code>bool</code> indicating whether the size of a given <code>string</code> is greater than the given size. However, <code>find_if</code> takes a unary predicate—any function we pass to <code>find_if</code> must have exactly one parameter that can be called with an element from the input sequence. There is no way to pass a second argument representing the size. To solve this part of our problem we’ll need to use some additional language facilities.</p>
<h5>Introducing Lambdas</h5>
<p>We can pass any kind of <strong><a href="105-defined_terms.html#filepos2711085" id="filepos2535620">callable object</a></strong> to an algorithm. An object or expression is callable if we can apply the call operator (§ <a href="015-1.5._introducing_classes.html#filepos237516">1.5.2</a>, p. <a href="015-1.5._introducing_classes.html#filepos237516">23</a>) to it. That is, if <code>e</code> is a callable expression, we can write <code>e(args)</code> where args is a comma-separated list of zero or more arguments.</p>
<p>The only callables we’ve used so far are functions and function pointers (§ <a href="069-6.7._pointers_to_functions.html#filepos1702852">6.7</a>, p. <a href="069-6.7._pointers_to_functions.html#filepos1702852">247</a>). There are two other kinds of callables: classes that overload the function-call operator, which we’ll cover in § <a href="137-14.8._functioncall_operator.html#filepos3657799">14.8</a> (p. <a href="137-14.8._functioncall_operator.html#filepos3657799">571</a>), and <strong><a href="105-defined_terms.html#filepos2715084" id="filepos2536540">lambda expressions</a></strong>.</p>
<a id="filepos2536657"></a><img alt="Image" src="/images/00008.jpg"/>
<p>A lambda expression represents a callable unit of code. It can be thought of as an unnamed, inline function. Like any function, a lambda has a return type, a parameter list, and a function body. Unlike a function, lambdas may be defined inside a function. A lamba expression has the form</p>

```c++
[capture list] (parameter list) -> return type  { function body }
```

<p>where <em><a href="105-defined_terms.html#filepos2711463" id="filepos2537724">capture list</a></em> is an (often empty) list of local variables defined in the enclosing function; <em>return type</em>, <em>parameter list</em>, and <em>function body</em> are the same as in any ordinary function. However, unlike ordinary functions, a lambda must use a trailing return (§ <a href="065-6.3._return_types_and_the_return_statement.html#filepos1583824">6.3.3</a>, p. <a href="065-6.3._return_types_and_the_return_statement.html#filepos1583824">229</a>) to specify its return type.</p>
<p>We can omit either or both of the parameter list and return type but must always include the capture list and function body:</p>

```c++
auto f = [] { return 42; };
```

<p>Here, we’ve defined <code>f</code> as a callable object that takes no arguments and returns <code>42</code>.</p>
<p>We call a lambda the same way we call a function by using the call operator:</p>

```c++
cout << f() << endl;  // prints 42
```

<p>Omitting the parentheses and the parameter list in a lambda is equivalent to specifying an empty parameter list. Hence, when we call <code>f</code>, the argument list is empty. If we omit the return type, the lambda has an inferred return type that depends on the code in the function body. If the function body is just a <code>return</code> statement, the return type is inferred from the type of the expression that is returned. Otherwise, the return type is <code>void</code>.</p>

::: info
<p>Lambdas with function bodies that contain anything other than a single <code>return</code> statement that do not specify a return type return <code>void</code>.</p>
:::

<h5>Passing Arguments to a Lambda</h5>
<p>As with an ordinary function call, the arguments in a call to a lambda are used to initialize the lambda’s parameters. As usual, the argument and parameter types must match. Unlike ordinary functions, a lambda may not have default arguments (§ <a href="067-6.5._features_for_specialized_uses.html#filepos1631032">6.5.1</a>, p. <a href="067-6.5._features_for_specialized_uses.html#filepos1631032">236</a>). Therefore, a call to a lambda always has as many arguments as the lambda has parameters. Once the parameters are initialized, the function body executes.</p>
<p>As an example of a lambda that takes arguments, we can write a lambda that behaves like our <code>isShorter</code> function:</p>

```c++
[](const string &a, const string &b)
  { return a.size() < b.size();}
```

<p>The empty capture list indicates that this lambda will not use any local variables from the surrounding function. The lambda’s parameters, like the parameters to <code>isShorter</code>, are references to <code>const string</code>. Again like <code>isShorter</code>, the lambda’s function body compares its parameters’ <code>size()</code>s and returns a <code>bool</code> that depends on the relative sizes of the given arguments.</p>
<p>We can rewrite our call to <code>stable_sort</code> to use this lambda as follows:</p>

```c++
// sort words by size, but maintain alphabetical order for words of the same size
stable_sort(words.begin(), words.end(),
            [](const string &a, const string &b)
              { return a.size() < b.size();});
```

<p>When <code>stable_sort</code> needs to compare two elements, it will call the given lambda expression.</p>
<h5>Using the Capture List</h5>
<p>We’re now ready to solve our original problem, which is to write a callable expression that we can pass to <code>find_if</code>. We want an expression that will compare the <a id="filepos2544363"></a>length of each <code>string</code> in the input sequence with the value of the <code>sz</code> parameter in the <code>biggies</code> function.</p>
<p>Although a lambda may appear inside a function, it can use variables local to that function <em>only</em> if it specifies which variables it intends to use. A lambda specifies the variables it will use by including those local variables in its capture list. The capture list directs the lambda to include information needed to access those variables within the lambda itself.</p>
<p>In this case, our lambda will capture <code>sz</code> and will have a single <code>string</code> parameter. The body of our lambda will compare the given <code>string</code>’s size with the captured value of <code>sz</code>:</p>

```c++
[sz](const string &a)
    { return a.size() >= sz; };
```

<p>Inside the <code>[]</code> that begins a lambda we can provide a comma-separated list of names defined in the surrounding function.</p>
<p>Because this lambda captures <code>sz</code>, the body of the lambda may use <code>sz</code>. The lambda does not capture <code>words</code>, and so has no access to that variable. Had we given our lambda an empty capture list, our code would not compile:</p>

```c++
// error: sz not captured
[](const string &a)
    { return a.size() >= sz; };
```

::: info
<p>A lambda may use a variable local to its surrounding function <em>only</em> if the lambda captures that variable in its capture list.</p>
:::

<h5>Calling <code>find_if</code></h5>
<p>Using this lambda, we can find the first element whose size is at least as big as <code>sz</code>:</p>

```c++
// get an iterator to the first element whose size() is >= sz
auto wc = find_if(words.begin(), words.end(),
            [sz](const string &a)
                { return a.size() >= sz; });
```

<p>The call to <code>find_if</code> returns an iterator to the first element that is at least as long as the given <code>sz</code>, or a copy of <code>words.end()</code> if no such element exists.</p>
<p>We can use the iterator returned from <code>find_if</code> to compute how many elements appear between that iterator and the end of <code>words</code> (§ <a href="033-3.4._introducing_iterators.html#filepos839265">3.4.2</a>, p. <a href="033-3.4._introducing_iterators.html#filepos839265">111</a>):</p>

```c++
// compute the number of elements with size >= sz
auto count = words.end() - wc;
cout << count << " " << make_plural(count, "word", "s")
     << " of length " << sz << " or longer" << endl;
```

<p>Our output statement calls <code>make_plural</code> (§ <a href="065-6.3._return_types_and_the_return_statement.html#filepos1552941">6.3.2</a>, p. <a href="065-6.3._return_types_and_the_return_statement.html#filepos1552941">224</a>) to print <code>word</code> or <code>words</code>, depending on whether that size is equal to 1.</p>
<h5><a id="filepos2551054"></a>The <code>for_each</code> Algorithm</h5>
<p>The last part of our problem is to print the elements in <code>words</code> that have length <code>sz</code> or greater. To do so, we’ll use the <code>for_each</code> algorithm. This algorithm takes a callable object and calls that object on each element in the input range:</p>

```c++
// print words of the given size or longer, each one followed by a space
for_each(wc, words.end(),
         [](const string &s){cout << s << " ";});
cout << endl;
```

<p>The capture list in this lambda is empty, yet the body uses two names: its own parameter, named <code>s</code>, and <code>cout</code>.</p>
<p>The capture list is empty, because we use the capture list only for (non<code>static</code>) variables defined in the surrounding function. A lambda can use names that are defined outside the function in which the lambda appears. In this case, <code>cout</code> is not a name defined locally in <code>biggies;</code> that name is defined in the <code>iostream</code> header. So long as the <code>iostream</code> header is included in the scope in which <code>biggies</code> appears, our lambda can use <code>cout</code>.</p>

::: info
<p>The capture list is used for local non<code>static</code> variables only; lambdas can use local <code>static</code>s and variables declared outside the function directly.</p>
:::

<h5>Putting It All Together</h5>
<p>Now that we’ve looked at the program in detail, here is the program as a whole:</p>

```c++
void biggies(vector<string> &words,
             vector<string>::size_type sz)
{
    elimDups(words); // put words in alphabetical order and remove duplicates
    // sort words by size, but maintain alphabetical order for words of the same size
    stable_sort(words.begin(), words.end(),
                [](const string &a, const string &b)
                  { return a.size() < b.size();});
    // get an iterator to the first element whose size() is >= sz
    auto wc = find_if(words.begin(), words.end(),
                [sz](const string &a)
                    { return a.size() >= sz; });
    // compute the number of elements with size >= sz
    auto count = words.end() - wc;
    cout << count << " " << make_plural(count, "word", "s")
         << " of length " << sz << " or longer" << endl;
    // print words of the given size or longer, each one followed by a space
    for_each(wc, words.end(),
             [](const string &s){cout << s << " ";});
    cout << endl;
}
```

::: info
<a id="filepos2557474"></a><p>Exercises Section 10.3.2</p>
<p><strong>Exercise 10.14:</strong> Write a lambda that takes two <code>int</code>s and returns their sum.</p>
<p><strong>Exercise 10.15:</strong> Write a lambda that captures an <code>int</code> from its enclosing function and takes an <code>int</code> parameter. The lambda should return the sum of the captured <code>int</code> and the <code>int</code> parameter.</p>
<p><strong>Exercise 10.16:</strong> Write your own version of the <code>biggies</code> function using lambdas.</p>
<p><strong>Exercise 10.17:</strong> Rewrite <a href="100-10.3._customizing_operations.html#filepos2528435">exercise 10.12</a> from § <a href="100-10.3._customizing_operations.html#filepos2520495">10.3.1</a> (p. <a href="100-10.3._customizing_operations.html#filepos2520495">387</a>) to use a lambda in the call to <code>sort</code> instead of the <code>compareIsbn</code> function.</p>
<p><strong>Exercise 10.18:</strong> Rewrite <code>biggies</code> to use <code>partition</code> instead of <code>find_if</code>. We described the <code>partition</code> algorithm in <a href="100-10.3._customizing_operations.html#filepos2529100">exercise 10.13</a> in § <a href="100-10.3._customizing_operations.html#filepos2520495">10.3.1</a> (p. <a href="100-10.3._customizing_operations.html#filepos2520495">387</a>).</p>
<p><strong>Exercise 10.19:</strong> Rewrite the previous exercise to use <code>stable_partition</code>, which like <code>stable_sort</code> maintains the original element order in the paritioned sequence.</p>
:::

<h4 id="filepos2560162">10.3.3. Lambda Captures and Returns</h4>
<p>When we define a lambda, the compiler generates a new (unnamed) class type that corresponds to that lambda. We’ll see how these classes are generated in § <a href="137-14.8._functioncall_operator.html#filepos3668993">14.8.1</a> (p. <a href="137-14.8._functioncall_operator.html#filepos3668993">572</a>). For now, what’s useful to understand is that when we pass a lambda to a function, we are defining both a new type and an object of that type: The argument is an unnamed object of this compiler-generated class type. Similarly, when we use <code>auto</code> to define a variable initialized by a lambda, we are defining an object of the type generated from that lambda.</p>
<p>By default, the class generated from a lambda contains a data member corresponding to the variables captured by the lambda. Like the data members of any class, the data members of a lambda are initialized when a lambda object is created.</p>
<h5>Capture by Value</h5>
<p>Similar to parameter passing, we can capture variables by value or by reference. <a href="100-10.3._customizing_operations.html#filepos2563299">Table 10.1</a> (p. <a href="100-10.3._customizing_operations.html#filepos2563299">395</a>) covers the various ways we can form a capture list. So far, our lambdas have captured variables by value. As with a parameter passed by value, it must be possible to copy such variables. Unlike parameters, the value of a captured variable is copied when the lambda is created, not when it is called:</p>

```c++
void fcn1()
{
    size_t v1 = 42;  // local variable
    // copies v1 into the callable object named f
    auto f = [v1] { return v1; };
    v1 = 0;
    auto j = f(); // j is 42; f stored a copy of v1 when we created it
}
```

<p><a id="filepos2563299"></a>Table 10.1. Lambda Capture List</p>
<img alt="Image" src="/images/00071.jpg"/>
<p>Because the value is copied when the lambda is created, subsequent changes to a captured variable have no effect on the corresponding value inside the lambda.</p>
<h5><a id="filepos2563709"></a>Capture by Reference</h5>
<p>We can also define lambdas that capture variables by reference. For example:</p>

```c++
void fcn2()
{
    size_t v1 = 42;  // local variable
    // the object f2 contains a reference to v1
    auto f2 = [&v1] { return v1; };
    v1 = 0;
    auto j = f2(); // j is 0; f2 refers to v1; it doesn't store it
}
```

<p>The <code>&amp;</code> before <code>v1</code> indicates that <code>v1</code> should be captured as a reference. A variable captured by reference acts like any other reference. When we use the variable inside the lambda body, we are using the object to which that reference is bound. In this case, when the lambda returns <code>v1</code>, it returns the value of the object to which <code>v1</code> refers.</p>
<p>Reference captures have the same problems and restrictions as reference returns (§ <a href="065-6.3._return_types_and_the_return_statement.html#filepos1552941">6.3.2</a>, p. <a href="065-6.3._return_types_and_the_return_statement.html#filepos1552941">225</a>). If we capture a variable by reference, we must be <em>certain</em> that the referenced object exists at the time the lambda is executed. The variables captured by a lambda are local variables. These variables cease to exist once the function completes. If it is possible for a lambda to be executed after the function finishes, the local variables to which the capture refers no longer exist.</p>
<p>Reference captures are sometimes necessary. For example, we might want our <code>biggies</code> function to take a reference to an <code>ostream</code> on which to write and a character to use as the separator:</p>

```c++
void biggies(vector<string> &words,
             vector<string>::size_type sz,
             ostream &os = cout, char c = ' ')
{
    // code to reorder words as before
    // statement to print count revised to print to os
    for_each(words.begin(), words.end(),
             [&os, c](const string &s) { os << s << c; });
}
```

<p>We cannot copy <code>ostream</code> objects (§ <a href="083-8.1._the_io_classes.html#filepos2083864">8.1.1</a>, p. <a href="083-8.1._the_io_classes.html#filepos2083864">311</a>); the only way to capture <code>os</code> is by reference (or through a pointer to <code>os</code>).</p>
<p>When we pass a lambda to a function, as in this call to <code>for_each</code>, the lambda executes immediately. Capturing <code>os</code> by reference is fine, because the variables in <code>biggies</code> exist while <code>for_each</code> is running.</p>
<p>We can also return a lambda from a function. The function might directly return a callable object or the function might return an object of a class that has a callable object as a data member. If the function returns a lambda, then—for the same reasons that a function must not return a reference to a local variable—that lambda must not contain reference captures.</p>

::: warning
<p>Warning</p>
<p>When we capture a variable by reference, we must ensure that the variable exists at the time that the lambda executes.</p>
:::

::: info
<a id="filepos2570357"></a><p>Advice: Keep Your Lambda Captures Simple</p>
<p>A lambda capture stores information between the time the lambda is created (i.e., when the code that defines the lambda is executed) and the time (or times) the lambda itself is executed. It is the programmer’s responsibility to ensure that whatever information is captured has the intended meaning each time the lambda is executed.</p>
<p>Capturing an ordinary variable—an <code>int</code>, a <code>string</code>, or other nonpointer type—by value is usually straightforward. In this case, we only need to care whether the variable has the value we need when we capture it.</p>
<p>If we capture a pointer or iterator, or capture a variable by reference, we must ensure that the object bound to that iterator, pointer, or reference still exists, whenever the lambda <em>executes.</em> Moreover, we need to ensure that the object has the intended value. Code that executes between when the lambda is created and when it executes might change the value of the object to which the lambda capture points (or refers). The value of the object at the time the pointer (or reference) was captured might have been what we wanted. The value of that object when the lambda executes might be quite different.</p>
<p>As a rule, we can avoid potential problems with captures by minimizing the data we capture. Moreover, if possible, avoid capturing pointers or references.</p>
:::

<h5>Implicit Captures</h5>
<p>Rather than explicitly listing the variables we want to use from the enclosing function, we can let the compiler infer which variables we use from the code in the lambda’s body. To direct the compiler to infer the capture list, we use an <code>&amp;</code> or <code>=</code> in the capture list. The <code>&amp;</code> tells the compiler to capture by reference, and the <code>=</code> says the values are captured by value. For example, we can rewrite the lambda that we passed to <code>find_if</code> as</p>

```c++
// sz implicitly captured by value
wc = find_if(words.begin(), words.end(),
             [=](const string &s)
                { return s.size() >= sz; });
```

<p>If we want to capture some variables by value and others by reference, we can mix implicit and explicit captures:</p>

```c++
void biggies(vector<string> &words,
             vector<string>::size_type sz,
             ostream &os = cout, char c = ' ')
{
    // other processing as before
    // os implicitly captured by reference; c explicitly captured by value
    for_each(words.begin(), words.end(),
             [&, c](const string &s) { os << s << c; });
    // os explicitly captured by reference; c implicitly captured by value
    for_each(words.begin(), words.end(),
             [=, &os](const string &s) { os << s << c; });
}
```

<p><a id="filepos2576136"></a>When we mix implicit and explicit captures, the first item in the capture list must be an <code>&amp;</code> or <code>=</code>. That symbol sets the default capture mode as by reference or by value, respectively.</p>
<p>When we mix implicit and explicit captures, the explicitly captured variables must use the alternate form. That is, if the implicit capture is by reference (using <code>&amp;</code>), then the explicitly named variables must be captured by value; hence their names may not be preceded by an <code>&amp;</code>. Alternatively, if the implicit capture is by value (using <code>=</code>), then the explicitly named variables must be preceded by an <code>&amp;</code> to indicate that they are to be captured by reference.</p>
<h5>Mutable Lambdas</h5>
<p>By default, a lambda may not change the value of a variable that it copies by value. If we want to be able to change the value of a captured variable, we must follow the parameter list with the keyword <code>mutable</code>. Lambdas that are mutable may not omit the parameter list:</p>

```c++
void fcn3()
{
    size_t v1 = 42; // local variable
    // f can change the value of the variables it captures
    auto f = [v1] () mutable { return ++v1; };
    v1 = 0;
    auto j = f(); // j is 43
}
```

<p>Whether a variable captured by reference can be changed (as usual) depends only on whether that reference refers to a <code>const</code> or non<code>const</code> type:</p>
<p><a id="filepos2579056"></a></p>

```c++
void fcn4()
{
    size_t v1 = 42;  // local variable
    // v1 is a reference to a non const variable
    // we can change that variable through the reference inside f2
    auto f2 = [&v1] { return ++v1; };
    v1 = 0;
    auto j = f2(); // j is 1
}
```

<h5>Specifying the Lambda Return Type</h5>
<p>The lambdas we’ve written so far contain only a single <code>return</code> statement. As a result, we haven’t had to specify the return type. By default, if a lambda body contains any statements other than a <code>return</code>, that lambda is assumed to return <code>void</code>. Like other functions that return <code>void</code>, lambdas inferred to return <code>void</code> may not return a value.</p>
<p>As a simple example, we might use the library <code>transform</code> algorithm and a lambda to replace each negative value in a sequence with its absolute value:</p>

```c++
transform(vi.begin(), vi.end(), vi.begin(),
          [](int i) { return i < 0 ? -i : i; });
```

<p>The <code>transform</code> function takes three iterators and a callable. The first two iterators denote an input sequence and the third is a destination. The algorithm calls the given callable on each element in the input sequence and writes the result to the destination. As in this call, the destination iterator can be the same as the iterator denoting the start of the input. When the input iterator and the destination iterator are the same, <code>transform</code> replaces each element in the input range with the result of calling the callable on that element.</p>
<p>In this call, we passed a lambda that returns the absolute value of its parameter. The lambda body is a single <code>return</code> statement that returns the result of a conditional expression. We need not specify the return type, because that type can be inferred from the type of the conditional operator.</p>
<p>However, if we write the seemingly equivalent program using an <code>if</code> statement, our code won’t compile:</p>

```c++
// error: cannot deduce the return type for the lambda
transform(vi.begin(), vi.end(), vi.begin(),
          [](int i) { if (i < 0) return -i; else return i; });
```

<p>This version of our lambda infers the return type as <code>void</code> but we returned a value.</p>
<a id="filepos2584038"></a><img alt="Image" src="/images/00008.jpg"/>
<p>When we need to define a return type for a lambda, we must use a trailing return type (§ <a href="065-6.3._return_types_and_the_return_statement.html#filepos1583824">6.3.3</a>, p. <a href="065-6.3._return_types_and_the_return_statement.html#filepos1583824">229</a>):</p>

```c++
transform(vi.begin(), vi.end(), vi.begin(),
          [](int i) -> int
          { if (i < 0) return -i; else return i; });
```

<p>In this case, the fourth argument to <code>transform</code> is a lambda with an empty capture list, which takes a single parameter of type <code>int</code> and returns a value of type <code>int</code>. Its function body is an <code>if</code> statement that returns the absolute value of its parameter.</p>

::: info
<a id="filepos2585437"></a><p>Exercises Section 10.3.3</p>
<p><strong>Exercise 10.20:</strong> The library defines an algorithm named <code>count_if</code>. Like <code>find_if</code>, this function takes a pair of iterators denoting an input range and a predicate that it applies to each element in the given range. <code>count_if</code> returns a count of how often the predicate is true. Use <code>count_if</code> to rewrite the portion of our program that counted how many words are greater than length 6.</p>
<p><strong>Exercise 10.21:</strong> Write a lambda that captures a local <code>int</code> variable and decrements that variable until it reaches 0. Once the variable is 0 additional calls should no longer decrement the variable. The lambda should return a <code>bool</code> that indicates whether the captured variable is 0.</p>
:::

<h4 id="filepos2586884">10.3.4. Binding Arguments</h4>
<img alt="Image" src="/images/00010.jpg"/>
<p>Lambda expressions are most useful for simple operations that we do not need to use in more than one or two places. If we need to do the same operation in many places, we should usually define a function rather than writing the same lambda expression multiple times. Similarly, if an operation requires many statements, it is ordinarily better to use a function.</p>
<p>It is usually straightforward to use a function in place of a lambda that has an empty capture list. As we’ve seen, we can use either a lambda or our <code>isShorter</code> function to order the <code>vector</code> on word length. Similarly, it would be easy to replace the lambda that printed the contents of our <code>vector</code> by writing a function that takes a <code>string</code> and prints the given <code>string</code> to the standard output.</p>
<p>However, it is not so easy to write a function to replace a lambda that captures local variables. For example, the lambda that we used in the call to <code>find_if</code> compared a <code>string</code> with a given size. We can easily write a function to do the same work:</p>

```c++
bool check_size(const string &s, string::size_type sz)
{
    return s.size() >= sz;
}
```

<p>However, we can’t use this function as an argument to <code>find_if</code>. As we’ve seen, <code>find_if</code> takes a unary predicate, so the callable passed to <code>find_if</code> must take a single argument. The lambda that <code>biggies</code> passed to <code>find_if</code> used its capture list to store <code>sz</code>. In order to use <code>check_size</code> in place of that lambda, we have to figure out how to pass an argument to the <code>sz</code> parameter.</p>
<h5>The Library <code>bind</code> Function</h5>
<a id="filepos2590269"></a><img alt="Image" src="/images/00008.jpg"/>
<p>We can solve the problem of passing a size argument to <code>check_size</code> by using a new library function named <code>bind</code>, which is defined in the <code>functional</code> header. The <code>bind</code> function can be thought of as a general-purpose function adaptor (§ <a href="094-9.6._container_adaptors.html#filepos2426063">9.6</a>, p. <a href="094-9.6._container_adaptors.html#filepos2426063">368</a>). It takes a callable object and generates a new callable that “adapts” the parameter list of the original object.</p>
<p><a id="filepos2591212"></a>The general form of a call to <code>bind</code> is:</p>

```c++
auto newCallable = bind(callable, arg_list);
```

<p>where <em>newCallable</em> is itself a callable object and <em>arg_list</em> is a comma-separated list of arguments that correspond to the parameters of the given <em>callable</em>. That is, when we call <em>newCallable</em>, <em>newCallable</em> calls <em>callable</em>, passing the arguments in <em>arg_list</em>.</p>
<p>The arguments in <em>arg_list</em> may include names of the form <code>_</code><em>n</em>, where <em>n</em> is an integer. These arguments are “placeholders” representing the parameters of <em>newCallable</em>. They stand “in place of” the arguments that will be passed to <em>newCallable</em>. The number <em>n</em> is the position of the parameter in the generated callable: <code>_1</code> is the first parameter in <em>newCallable</em>, <code>_2</code> is the second, and so forth.</p>
<h5>Binding the <code>sz</code> Parameter of <code>check_size</code></h5>
<p>As a simple example, we’ll use <code>bind</code> to generate an object that calls <code>check_size</code> with a fixed value for its size parameter as follows:</p>

```c++
// check6 is a callable object that takes one argument of type string
// and calls check_size on its given string and the value 6
auto check6 = bind(check_size, _1, 6);
```

<p>This call to <code>bind</code> has only one placeholder, which means that <code>check6</code> takes a single argument. The placeholder appears first in <em>arg_list</em>, which means that the parameter in <code>check6</code> corresponds to the first parameter of <code>check_size</code>. That parameter is a <code>const string&amp;</code>, which means that the parameter in <code>check6</code> is also a <code>const string&amp;</code>. Thus, a call to <code>check6</code> must pass an argument of type <code>string</code>, which <code>check6</code> will pass as the first argument to <code>check_size</code>.</p>
<p>The second argument in <em>arg_list</em> (i.e., the third argument to <code>bind</code>) is the value <code>6</code>. That value is bound to the second parameter of <code>check_size</code>. Whenever we call <code>check6</code>, it will pass <code>6</code> as the second argument to <code>check_size</code>:</p>

```c++
string s = "hello";
bool b1 = check6(s);  // check6(s) calls check_size(s, 6)
```

<p>Using <code>bind</code>, we can replace our original lambda-based call to <code>find_if</code></p>

```c++
auto wc = find_if(words.begin(), words.end(),
            [sz](const string &a)
```

<p>with a version that uses <code>check_size</code>:</p>

```c++
auto wc = find_if(words.begin(), words.end(),
             bind(check_size, _1, sz));
```

<p>This call to <code>bind</code> generates a callable object that binds the second argument of <code>check_size</code> to the value of <code>sz</code>. When <code>find_if</code> calls this object on the <code>string</code>s in <code>words</code> those calls will in turn call <code>check_size</code> passing the given <code>string</code> and <code>sz</code>. So, <code>find_if</code> (effectively) will call <code>check_size</code> on each <code>string</code> in the input range and compare the size of that <code>string</code> to <code>sz</code>.</p>
<h5><a id="filepos2599897"></a>Using <code>placeholders</code> Names</h5>
<p>The <code>_</code><em>n</em> names are defined in a namespace named <code>placeholders</code>. That namespace is itself defined inside the <code>std</code> namespace (§ <a href="030-3.1._namespace_using_declarations.html#filepos638596">3.1</a>, p. <a href="030-3.1._namespace_using_declarations.html#filepos638596">82</a>). To use these names, we must supply the names of both namespaces. As with our other examples, our calls to <code>bind</code> assume the existence of appropriate <code>using</code> declarations. For example, the <code>using</code> declaration for <code>_1</code> is</p>

```c++
using std::placeholders::_1;
```

<p>This declaration says we’re using the name <code>_1</code>, which is defined in the namespace <code>placeholders</code>, which is itself defined in the namespace <code>std</code>.</p>
<p>We must provide a separate <code>using</code> declaration for each placeholder name that we use. Writing such declarations can be tedious and error-prone. Rather than separately declaring each placeholder, we can use a different form of <code>using</code> that we will cover in more detail in § <a href="172-18.2._namespaces.html#filepos4964533">18.2.2</a> (p. <a href="172-18.2._namespaces.html#filepos4964533">793</a>). This form:</p>

```c++
using namespace namespace_name;
```

<p>says that we want to make all the names from <em>namespace_name</em> accessible to our program. For example:</p>

```c++
using namespace std::placeholders;
```

<p>makes all the names defined by <code>placeholders</code> usable. Like the <code>bind</code> function, the <code>placeholders</code> namespace is defined in the <code>functional</code> header.</p>
<h5>Arguments to <code>bind</code></h5>
<p>As we’ve seen, we can use <code>bind</code> to fix the value of a parameter. More generally, we can use <code>bind</code> to bind or rearrange the parameters in the given callable. For example, assuming <code>f</code> is a callable object that has five parameters, the following call to <code>bind</code>:</p>

```c++
// g is a callable object that takes two arguments
auto g = bind(f, a, b, _2, c, _1);
```

<p>generates a new callable that takes two arguments, represented by the placeholders <code>_2</code> and <code>_1</code>. The new callable will pass its own arguments as the third and fifth arguments to <code>f</code>. The first, second, and fourth arguments to <code>f</code> are bound to the given values, <code>a</code>, <code>b</code>, and <code>c</code>, respectively.</p>
<p>The arguments to <code>g</code> are bound positionally to the placeholders. That is, the first argument to <code>g</code> is bound to <code>_1</code>, and the second argument is bound to <code>_2</code>. Thus, when we call <code>g</code>, the first argument to <code>g</code> will be passed as the last argument to <code>f</code>; the second argument to <code>g</code> will be passed as <code>g</code>’s third argument. In effect, this call to <code>bind</code> maps</p>

```c++
g(_1, _2)
```

<p>to</p>

```c++
f(a, b, _2, c, _1)
```

<p>That is, calling <code>g</code> calls <code>f</code> using <code>g</code>’s arguments for the placeholders along with the bound arguments, <code>a</code>, <code>b</code>, and <code>c</code>. For example, calling <code>g(X, Y)</code> calls</p>

```c++
f(a, b, Y, c, X)
```

<h5><a id="filepos2607928"></a>Using to <code>bind</code> to Reorder Parameters</h5>
<p>As a more concrete example of using <code>bind</code> to reorder arguments, we can use <code>bind</code> to invert the meaning of <code>isShorter</code> by writing</p>

```c++
// sort on word length, shortest to longest
sort(words.begin(), words.end(), isShorter);
// sort on word length, longest to shortest
sort(words.begin(), words.end(), bind(isShorter, _2, _1));
```

<p>In the first call, when <code>sort</code> needs to compare two elements, <code>A</code> and <code>B</code>, it will call <code>isShorter(A, B)</code>. In the second call to <code>sort</code>, the arguments to <code>isShorter</code> are swapped. In this case, when <code>sort</code> compares elements, it will be as if <code>sort</code> called <code>isShorter(B, A)</code>.</p>
<h5>Binding Reference Parameters</h5>
<p>By default, the arguments to <code>bind</code> that are not placeholders are copied into the callable object that <code>bind</code> returns. However, as with lambdas, sometimes we have arguments that we want to bind but that we want to pass by reference or we might want to bind an argument that has a type that we cannot copy.</p>
<p>For example, to replace the lambda that captured an <code>ostream</code> by reference:</p>

```c++
// os is a local variable referring to an output stream
// c is a local variable of type char
for_each(words.begin(), words.end(),
         [&os, c](const string &s) { os << s << c; });
```

<p>We can easily write a function to do the same job:</p>

```c++
ostream &print(ostream &os, const string &s, char c)
{
    return os << s << c;
}
```

<p>However, we can’t use <code>bind</code> directly to replace the capture of <code>os</code>:</p>

```c++
// error: cannot copy os
for_each(words.begin(), words.end(), bind(print, os, _1, ' '));
```

<p>because <code>bind</code> copies its arguments and we cannot copy an <code>ostream</code>. If we want to pass an object to <code>bind</code> without copying it, we must use the library <code>ref</code> function:</p>

```c++
for_each(words.begin(), words.end(),
         bind(print, ref(os), _1, ' '));
```

<p>The <code>ref</code> function returns an object that contains the given reference and that is itself copyable. There is also a <code>cref</code> function that generates a class that holds a reference to <code>const</code>. Like <code>bind</code>, the <code>ref</code> and <code>cref</code> functions are defined in the <code>functional</code> header.</p>

::: info
<a id="filepos2614920"></a><p>Backward Compatibility: Binding Arguments</p>
<p>Older versions of C++ provided a much more limited, yet more complicated, set of facilities to bind arguments to functions. The library defined two functions named <code>bind1st</code> and <code>bind2nd</code>. Like <code>bind</code>, these functions take a function and generate a new callable object that calls the given function with one of its parameters bound to a given value. However, these functions can bind only the first or second parameter, respectively. Because they are of much more limited utility, they have been <em>deprecated</em> in the new standard. A deprecated feature is one that may not be supported in future releases. Modern C++ programs should use <code>bind</code>.</p>
:::

::: info
<p>Exercises Section 10.3.4</p>
<p><strong>Exercise 10.22:</strong> Rewrite the program to count words of size 6 or less using functions in place of the lambdas.</p>
<p><strong>Exercise 10.23:</strong> How many arguments does <code>bind</code> take?</p>
<p><strong>Exercise 10.24:</strong> Use <code>bind</code> and <code>check_size</code> to find the first element in a <code>vector</code> of <code>int</code>s that has a value greater than the length of a specified <code>string</code> value.</p>
<p><strong>Exercise 10.25:</strong> In the exercises for § <a href="100-10.3._customizing_operations.html#filepos2530282">10.3.2</a> (p. <a href="100-10.3._customizing_operations.html#filepos2530282">392</a>) you wrote a version of <code>biggies</code> that uses <code>partition</code>. Rewrite that function to use <code>check_size</code> and <code>bind</code>.</p>
:::

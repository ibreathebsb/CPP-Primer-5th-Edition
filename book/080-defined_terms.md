<h3 id="filepos2054441">Defined Terms</h3><ul><li><p><a href="072-chapter_7._classes.html#filepos1745102" id="filepos2054580"><strong>abstract data type</strong></a> Data structure that encapsulates (hides) its implementation.</p></li><li><p><a href="074-7.2._access_control_and_encapsulation.html#filepos1833906" id="filepos2054821"><strong>access specifier</strong></a> Keywords <code>public</code> and <code>private</code>. Used to define whether members are accessible to users of the class or only to friends and members of the class. Specifiers may appear multiple times within a class. Each specifier sets the access of the following members up to the next specifier.</p></li><li><p><a href="077-7.5._constructors_revisited.html#filepos2013767" id="filepos2055402"><strong>aggregate class</strong></a> Class with only <code>public</code> data members that has no in-class initializers or constructors. Members of an aggregate can be initialized by a brace-enclosed list of initializers.</p></li><li><p><a href="072-chapter_7._classes.html#filepos1743917" id="filepos2055814"><strong>class</strong></a> C++ mechanism for defining our own abstract data types. Classes may have data, function, or type members. A class defines a new type and a new scope.</p></li><li><p><strong>class declaration</strong> The keyword <code>class</code> (or <code>struct</code>) followed by the class name followed by a semicolon. If a class is declared but not defined, it is an incomplete type.</p></li><li><p><a href="074-7.2._access_control_and_encapsulation.html#filepos1838019" id="filepos2056547"><strong>class keyword</strong></a> Keyword used to define a class; by default members are <code>private</code>.</p></li><li><p><strong>class scope</strong> Each class defines a scope. Class scopes are more complicated than other scopes—member functions defined within the class body may use names that appear even after the definition.</p></li><li><p><a href="073-7.1._defining_abstract_data_types.html#filepos1777780" id="filepos2057171"><strong>const member function</strong></a> A member function that may not change an object’s ordinary (i.e., neither <code>static</code> nor <code>mutable</code>) data members. The <code>this</code> pointer in a <code>const</code> member is a pointer to <code>const</code>. A member function may be overloaded based on whether the function is <code>const</code>.</p></li><li><p><a href="073-7.1._defining_abstract_data_types.html#filepos1802827" id="filepos2057980"><strong>constructor</strong></a> A special member function used to initialize objects. Each constructor should give each data member a well-defined initial value.</p></li><li><p><a href="073-7.1._defining_abstract_data_types.html#filepos1818233" id="filepos2058283"><strong>constructor initializer list</strong></a> Specifies initial values of the data members of a class. The members are initialized to the values specified in the initializer list before the body of the constructor executes. Class members that are not initialized in the initializer list are default initialized.</p></li><li><p><a href="077-7.5._constructors_revisited.html#filepos1990821" id="filepos2058739"><strong>converting constructor</strong></a> A non<code>explicit</code> constructor that can be called with a single argument. Such constructors implicitly convert from the argument’s type to the class type.</p></li><li><p><a id="filepos2059142"></a><a href="072-chapter_7._classes.html#filepos1743990" id="filepos2059150"><strong>data abstraction</strong></a> Programming technique that focuses on the interface to a type. Data abstraction lets programmers ignore the details of how a type is represented and think instead about the operations that the type can perform. Data abstraction is fundamental to both object-oriented and generic programming.</p></li><li><p><a href="073-7.1._defining_abstract_data_types.html#filepos1806598" id="filepos2059620"><strong>default constructor</strong></a> Constructor that is used if no initializer is supplied.</p></li><li><p><a href="077-7.5._constructors_revisited.html#filepos1973769" id="filepos2059857"><strong>delegating constructor</strong></a> Constructor with a constructor-initializer list that has one entry that designates another constructor of the same class to do the initialization.</p></li><li><p><a href="072-chapter_7._classes.html#filepos1744072" id="filepos2060188"><strong>encapsulation</strong></a> Separation of implementation from interface; encapsulation hides the implementation details of a type. In C++, encapsulation is enforced by putting the implementation in the <code>private</code> part of a class.</p></li><li><p><strong>explicit constructor</strong> Constructor that can be called with a single argument but cannot be used in an implicit conversion. A constructor is made explicit by prepending the keyword <code>explicit</code> to its declaration.</p></li><li><p><a href="075-7.3._additional_class_features.html#filepos1903543" id="filepos2061019"><strong>forward declaration</strong></a> Declaration of an as yet undefined name. Most often used to refer to the declaration of a class that appears prior to the definition of that class. See incomplete type.</p></li><li><p><a href="074-7.2._access_control_and_encapsulation.html#filepos1842929" id="filepos2061369"><strong>friend</strong></a> Mechanism by which a class grants access to its non<code>public</code> members. Friends have the same access rights as members. Both classes and functions may be named as friends.</p></li><li><p><a href="072-chapter_7._classes.html#filepos1744313" id="filepos2061767"><strong>implementation</strong></a> The (usually <code>private</code>) members of a class that define the data and any operations that are not intended for use by code that uses the type.</p></li><li><p><a href="075-7.3._additional_class_features.html#filepos1903983" id="filepos2062145"><strong>incomplete type</strong></a> Type that is declared but not defined. It is not possible to use an incomplete type to define a variable or class member. It is legal to define references or pointers to incomplete types.</p></li><li><p><a href="072-chapter_7._classes.html#filepos1744238" id="filepos2062510"><strong>interface</strong></a> The (<code>public</code>) operations supported by a type. Ordinarily, the interface does not include data members.</p></li><li><p><a href="073-7.1._defining_abstract_data_types.html#filepos1747562" id="filepos2062846"><strong>member function</strong></a> Class member that is a function. Ordinary member functions are bound to an object of the class type through the implicit <code>this</code> pointer. <code>static</code> member functions are not bound to an object and have no <code>this</code> pointer. Member functions may be overloaded; when they are, the implicit <code>this</code> pointer participates in the function matching.</p></li><li><p><a href="075-7.3._additional_class_features.html#filepos1868151" id="filepos2063603"><strong>mutable data member</strong></a> Data member that is never <code>const</code>, even when it is a member of a <code>const</code> object. A <code>mutable</code> member can be changed inside a <code>const</code> function.</p></li><li><p><a href="076-7.4._class_scope.html#filepos1931835" id="filepos2064170"><strong>name lookup</strong></a> Process by which the use of a name is matched to its declaration.</p></li><li><p><strong>private members</strong> Members defined after a <code>private</code> access specifier; accessible only to the friends and other class members. Data members and utility functions used by the class that are not part of the type’s interface are usually declared <code>private</code>.</p></li><li><p><strong>public members</strong> Members defined after a <code>public</code> access specifier; accessible to any user of the class. Ordinarily, only the functions that define the interface to the class should be defined in the <code>public</code> sections.</p></li><li><p><strong>struct keyword</strong> Keyword used to define a class; by default members are <code>public</code>.</p></li><li><p><a href="073-7.1._defining_abstract_data_types.html#filepos1807151" id="filepos2065640"><strong>synthesized default constructor</strong></a> The default constructor created (synthesized) by the compiler for classes that do not explicitly define any constructors. This constructor initializes the data members from their in-class initializers, if present; otherwise it default initializes the data members.</p></li><li><p><a href="073-7.1._defining_abstract_data_types.html#filepos1770061" id="filepos2066098"><strong>this pointer</strong></a> Implicit value passed as an extra argument to every non<code>static</code> member function. The <code>this</code> pointer points to the object on which the function is invoked.</p></li><li><p><a href="073-7.1._defining_abstract_data_types.html#filepos1815891" id="filepos2066549"><strong>= default</strong></a> Syntax used after the parameter list of the declaration of the default constructor inside a class to signal to the compiler that it should generate the constructor, even if the class has other constructors.</p></li>
 
</ul>

<h3 id="filepos4635323">17.3. Regular Expressions</h3>
<p>A <strong><a href="169-defined_terms.html#filepos4849177" id="filepos4635461">regular expression</a></strong> is a way of describing a sequence of characters. Regular expressions are a stunningly powerful computational device. However, describing the languages used to define regular expressions is well beyond the scope of this Primer. Instead, we’ll focus on how to use the C++ regular-expression library (RE library), which is part of the new library. The RE library, which is defined in the <code>regex</code> header, involves several components, listed in <a href="165-17.3._regular_expressions.html#filepos4636149">Table 17.4</a>.</p>
<p><a id="filepos4636149"></a>Table 17.4. Regular Expression Library Components</p>
<img alt="Image" src="/images/00112.jpg"/>
<a id="filepos4636340"></a><img alt="Image" src="/images/00008.jpg"/>

::: tip
<p>If you are not already familiar with using regular expressions, you might want to skim this section to get an idea of the kinds of things regular expressions can do.</p>
:::

<p><a id="filepos4636923"></a>The <code>regex</code> class represents a regular expression. Aside from initialization and assignment, <code>regex</code> has few operations. The operations on <code>regex</code> are listed in <a href="165-17.3._regular_expressions.html#filepos4648235">Table 17.6</a> (p. <a href="165-17.3._regular_expressions.html#filepos4648235">731</a>).</p>
<p>The functions <code>regex_match</code> and <code>regex_search</code> determine whether a given character sequence matches a given <code>regex</code>. The <code>regex_match</code> function returns <code>true</code> if the entire input sequence matches the expression; <code>regex_search</code> returns <code>true</code> if there is a substring in the input sequence that matches. There is also a <code>regex_replace</code> function that we’ll describe in § <a href="165-17.3._regular_expressions.html#filepos4699978">17.3.4</a> (p. <a href="165-17.3._regular_expressions.html#filepos4699978">741</a>).</p>
<p>The arguments to the <code>regex</code> functions are described in <a href="165-17.3._regular_expressions.html#filepos4639503">Table 17.5</a> (overleaf). These functions return a <code>bool</code> and are overloaded: One version takes an additional argument of type <code>smatch</code>. If present, these functions store additional information about a successful match in the given <code>smatch</code> object.</p>
<p><a id="filepos4639503"></a>Table 17.5. Arguments to <code>regex_search</code> and <code>regex_match</code></p>
<img alt="Image" src="/images/00113.jpg"/>
<h4 id="filepos4639938">17.3.1. Using the Regular Expression Library</h4>
<p>As a fairly simple example, we’ll look for words that violate a well-known spelling rule of thumb, “<em>i</em> before <em>e</em> except after <em>c</em>”:</p>

```c++
// find the characters ei that follow a character other than c
string pattern("[^c]ei");
// we want the whole word in which our pattern appears
pattern = "[[:alpha:]]*" + pattern + "[[:alpha:]]*";
regex r(pattern); // construct a regex to find pattern
smatch results;   // define an object to hold the results of a search
// define a string that has text that does and doesn't match pattern
string test_str = "receipt freind theif receive";
// use r to find a match to pattern in test_str
if (regex_search(test_str, results, r)) // if there is a match
    cout << results.str() << endl;      // print the matching word
```

<p>We start by defining a <code>string</code> to hold the regular expression we want to find. The regular expression <code>[^c]</code> says we want any character that is not a <code>'c'</code>, and <code>[^c]ei</code> says we want any such letter that is followed by the letters <code>ei</code>. This pattern describes strings containing exactly three characters. We want the entire word that contains this pattern. To match the word, we need a regular expression that will match the letters that come before and after our three-letter pattern.</p>
<p><a id="filepos4643761"></a>That regular expression consists of zero or more letters followed by our original three-letter pattern followed by zero or more additional characters. By default, the regular-expression language used by <code>regex</code> objects is ECMAScript. In ECMAScript, the pattern <code>[[:alpha:]]</code> matches any alphabetic character, and the symbols <code>+</code> and <code>*</code> signify that we want “one or more” or “zero or more” matches, respectively. Thus, <code>[[:alpha:]]*</code> will match zero or more characters.</p>
<p>Having stored our regular expression in <code>pattern</code>, we use it to initialize a <code>regex</code> object named <code>r</code>. We next define a <code>string</code> that we’ll use to test our regular expression. We initialize <code>test_str</code> with words that match our pattern (e.g., “freind” and “theif”) and words (e.g., “receipt” and “receive”) that don’t. We also define an <code>smatch</code> object named <code>results</code>, which we will pass to <code>regex_search</code>. If a match is found, <code>results</code> will hold the details about where the match occurred.</p>
<p>Next we call <code>regex_search</code>. If <code>regex_search</code> finds a match, it returns <code>true</code>. We use the <code>str</code> member of <code>results</code> to print the part of <code>test_str</code> that matched our pattern. The <code>regex_search</code> function stops looking as soon as it finds a matching substring in the input sequence. Thus, the output will be</p>

```
freind
```

<p>§ <a href="165-17.3._regular_expressions.html#filepos4663827">17.3.2</a> (p. <a href="165-17.3._regular_expressions.html#filepos4663827">734</a>) will show how to find all the matches in the input.</p>
<h5>Specifying Options for a <code>regex</code> Object</h5>
<p>When we define a <code>regex</code> or call <code>assign</code> on a <code>regex</code> to give it a new value, we can specify one or more flags that affect how the <code>regex</code> operates. These flags control the processing done by that object. The last six flags listed in <a href="165-17.3._regular_expressions.html#filepos4648235">Table 17.6</a> indicate the language in which the regular expression is written. Exactly one of the flags that specify a language must be set. By default, the <code>ECMAScript</code> flag is set, which causes the <code>regex</code> to use the ECMA-262 specification, which is the regular expression language that many Web browsers use.</p>
<p><a id="filepos4648235"></a>Table 17.6. <code>regex</code> (and <code>wregex</code>) Operations</p>
<img alt="Image" src="/images/00114.jpg"/>
<p>The other three flags let us specify language-independent aspects of the regular-expression processing. For example, we can indicate that we want the regular expression to be matched in a case-independent manner.</p>
<p>As one example, we can use the <code>icase</code> flag to find file names that have a particular file extension. Most operating systems recognize extensions in a case-independent manner—we can store a C++ program in a file that ends in <code>.cc</code>, or <code>.Cc</code>, or <code>.cC</code>, or <code>.CC</code>. We’ll write a regular expression to recognize any of these along with other common file extensions as follows:</p>

```c++
// one or more alphanumeric characters followed by a '.' followed by "cpp" or "cxx" or "cc"
regex r("[[:alnum:]]+\\.(cpp|cxx|cc)$", regex::icase);
smatch results;
string filename;
while (cin >> filename)
    if (regex_search(filename, results, r))
        cout << results.str() << endl;  // print the current match
```

<p>This expression will match a string of one or more letters or digits followed by a period and followed by one of three file extensions. The regular expression will match the file extensions regardless of case.</p>
<p>Just as there are special characters in C++ (§ <a href="021-2.1._primitive_builtin_types.html#filepos326709">2.1.3</a>, p. <a href="021-2.1._primitive_builtin_types.html#filepos326709">39</a>), regular-expression languages typically also have special characters. For example, the dot (.) character usually matches any character. As we do in C++, we can escape the special nature of a character by preceding it with a backslash. Because the backslash is also a special character in C++, we must use a second backslash inside a string literal to indicate to C++ that we want a backslash. Hence, we must write <code>\\</code>. to represent a regular expression that will match a period.</p>
<h5><a id="filepos4651570"></a>Errors in Specifying or Using a Regular Expression</h5>
<p>We can think of a regular expression as itself a “program” in a simple programming language. That language is not interpreted by the C++ compiler. Instead, a regular expression is “compiled” at run time when a <code>regex</code> object is initialized with or assigned a new pattern. As with any programming language, it is possible that the regular expressions we write can have errors.</p>

::: info
<p>It is important to realize that the syntactic correctness of a regular expression is evaluated at run time.</p>
:::

<p>If we make a mistake in writing a regular expression, then at <em>run time</em> the library will throw an exception (§ <a href="059-5.6._try_blocks_and_exception_handling.html#filepos1368051">5.6</a>, p. <a href="059-5.6._try_blocks_and_exception_handling.html#filepos1368051">193</a>) of type <code>regex_error</code>. Like the standard exception types, <code>regex_error</code> has a <code>what</code> operation that describes the error that occurred (§ <a href="059-5.6._try_blocks_and_exception_handling.html#filepos1377241">5.6.2</a>, p. <a href="059-5.6._try_blocks_and_exception_handling.html#filepos1377241">195</a>). A <code>regex_error</code> also has a member named <code>code</code> that returns a numeric code corresponding to the type of error that was encountered. The values <code>code</code> returns are implementation defined. The standard errors that the RE library can throw are listed in <a href="165-17.3._regular_expressions.html#filepos4653902">Table 17.7</a>.</p>
<p><a id="filepos4653902"></a>Table 17.7. Regular Expression Error Conditions</p>
<img alt="Image" src="/images/00115.jpg"/>
<p>For example, we might inadvertently omit a bracket in a pattern:</p>

```c++
try {
    // error: missing close bracket after alnum; the constructor will throw
    regex r("[[:alnum:]+\\.(cpp|cxx|cc)$", regex::icase);
} catch (regex_error e)
  { cout << e.what() << "\ncode: " << e.code() << endl; }
```

<p>When run on our system, this program generates</p>

```
regex_error(error_brack):
The expression contained mismatched [ and ].
code: 4
```

<p><a id="filepos4655563"></a>Our compiler defines the <code>code</code> member to return the position of the error as listed in <a href="165-17.3._regular_expressions.html#filepos4653902">Table 17.7</a>, counting, as usual, from zero.</p>

::: info
<p>Advice: Avoid Creating Unnecessary Regular Expressions</p>
<p>As we’ve seen, the “program” that a regular expression represents is compiled at run time, not at compile time. Compiling a regular expression can be a surprisingly slow operation, especially if you’re using the extended regular-expression grammar or are using complicated expressions. As a result, constructing a <code>regex</code> object and assigning a new regular expression to an existing <code>regex</code> can be time-consuming. To minimize this overhead, you should try to avoid creating more <code>regex</code> objects than needed. In particular, if you use a regular expression in a loop, you should create it outside the loop rather than recompiling it on each iteration.</p>
:::

<h5>Regular Expression Classes and the Input Sequence Type</h5>
<p>We can search any of several types of input sequence. The input can be ordinary <code>char</code> data or <code>wchar_t</code> data and those characters can be stored in a library <code>string</code> or in an array of <code>char</code> (or the wide character versions, <code>wstring</code> or array of <code>wchar_t</code>). The RE library defines separate types that correspond to these differing types of input sequences.</p>
<p>For example, the <code>regex</code> class holds regular expressions of type <code>char</code>. The library also defines a <code>wregex</code> class that holds type <code>wchar_t</code> and has all the same operations as <code>regex</code>. The only difference is that the initializers of a <code>wregex</code> must use <code>wchar_t</code> instead of <code>char</code>.</p>
<p>The match and iterator types (which we will cover in the following sections) are more specific. These types differ not only by the character type, but also by whether the sequence is in a library <code>string</code> or an array: <code>smatch</code> represents <code>string</code> input sequences; <code>cmatch</code>, character array sequences; <code>wsmatch</code>, wide string (<code>wstring</code>) input; and <code>wcmatch</code>, arrays of wide characters.</p>
<p>The important point is that the RE library types we use must match the type of the input sequence. <a href="165-17.3._regular_expressions.html#filepos4661017">Table 17.8</a> indicates which types correspond to which kinds of input sequences. For example:</p>

```c++
regex r("[[:alnum:]]+\\.(cpp|cxx|cc)$", regex::icase);
smatch results;  // will match a string input sequence, but not char*
if (regex_search("myfile.cc", results, r)) // error: char* input
    cout << results.str() << endl;
```

<p><a id="filepos4661017"></a>Table 17.8. Regular Expression Library Classes</p>
<img alt="Image" src="/images/00116.jpg"/>
<p><a id="filepos4661224"></a>The (C++) compiler will reject this code because the type of the match argument and the type of the input sequence do not match. If we want to search a character array, then we must use a <code>cmatch</code> object:</p>

```c++
cmatch results;  // will match character array input sequences
if (regex_search("myfile.cc", results, r))
    cout << results.str() << endl;  // print the current match
```

<p>In general, our programs will use <code>string</code> input sequences and the corresponding <code>string</code> versions of the RE library components.</p>

::: info
<p>Exercises Section 17.3.1</p>
<p><strong>Exercise 17.14:</strong> Write several regular expressions designed to trigger various errors. Run your program to see what output your compiler generates for each error.</p>
<p><strong>Exercise 17.15:</strong> Write a program using the pattern that finds words that violate the <em>“i</em> before <em>e</em> except after <em>c”</em> rule. Have your program prompt the user to supply a word and indicate whether the word is okay or not. Test your program with words that do and do not violate the rule.</p>
<p><strong>Exercise 17.16:</strong> What would happen if your <code>regex</code> object in the previous program were initialized with <code>"[^c]ei"?</code> Test your program using that pattern to see whether your expectations were correct.</p>
:::

<h4 id="filepos4663827">17.3.2. The Match and Regex Iterator Types</h4>
<p>The program on page <a href="165-17.3._regular_expressions.html#filepos4636923">729</a> that found violations of the “<em>i</em> before <em>e</em> except after <em>c</em>” grammar rule printed only the first match in its input sequence. We can get all the matches by using an <code>sregex_iterator</code>. The regex iterators are iterator adaptors (§ <a href="094-9.6._container_adaptors.html#filepos2426063">9.6</a>, p. <a href="094-9.6._container_adaptors.html#filepos2426063">368</a>) that are bound to an input sequence and a <code>regex</code> object. As described in <a href="165-17.3._regular_expressions.html#filepos4661017">Table 17.8</a> (on the previous page), there are specific regex iterator types that correspond to each of the different types of input sequences. The iterator operations are described in <a href="165-17.3._regular_expressions.html#filepos4665024">Table 17.9</a> (p. <a href="165-17.3._regular_expressions.html#filepos4665024">736</a>).</p>
<p><a id="filepos4665024"></a>Table 17.9. <code>sregex_iterator</code> Operations</p>
<img alt="Image" src="/images/00117.jpg"/>
<p>When we bind an <code>sregex_iterator</code> to a <code>string</code> and a <code>regex</code> object, the iterator is automatically positioned on the first match in the given <code>string</code>. That is, the <code>sregex_iterator</code> constructor calls <code>regex_search</code> on the given <code>string</code> and <code>regex</code>. When we dereference the iterator, we get an <code>smatch</code> object corresponding to the results from the most recent search. When we increment the iterator, it calls <code>regex_search</code> to find the next match in the input <code>string</code>.</p>
<h5>Using an <code>sregex_iterator</code></h5>
<p>As an example, we’ll extend our program to find all the violations of the “<em>i</em> before <em>e</em> except after <em>c</em>” grammar rule in a file of text. We’ll assume that the <code>string</code> named <code>file</code> holds the entire contents of the input file that we want to search. This version of the program will use the same <code>pattern</code> as our original one, but will use a <code>sregex_iterator</code> to do the search:</p>
<p><a id="filepos4667514"></a></p>

```c++
// find the characters ei that follow a character other than c
string pattern("[^c]ei");
// we want the whole word in which our pattern appears
pattern = "[[:alpha:]]*" + pattern + "[[:alpha:]]*";
regex r(pattern, regex::icase); // we'll ignore case in doing the match
// it will repeatedly call regex_search to find all matches in file
for (sregex_iterator it(file.begin(), file.end(), r), end_it;
         it != end_it; ++it)
        cout << it->str() << endl; // matched word
```

<p>The <code>for</code> loop iterates through each match to <code>r</code> inside <code>file</code>. The initializer in the <code>for</code> defines <code>it</code> and <code>end_it</code>. When we define <code>it</code>, the <code>sregex_iterator</code> constructor calls <code>regex_search</code> to position <code>it</code> on the first match in <code>file</code>. The empty <code>sregex_iterator, end_it</code>, acts as the off-the-end iterator. The increment in the <code>for</code> “advances” the iterator by calling <code>regex_search</code>. When we dereference the iterator, we get an <code>smatch</code> object representing the current match. We call the <code>str</code> member of the match to print the matching word.</p>
<p>We can think of this loop as jumping from match to match as illustrated in <a href="165-17.3._regular_expressions.html#filepos4671092">Figure 17.1</a>.</p>
<a id="filepos4671092"></a><img alt="Image" src="/images/00118.jpg"/>
<p>Figure 17.1. Using an <code>sregex_iterator</code></p>
<h5>Using the Match Data</h5>
<p>If we run this loop on <code>test_str</code> from our original program, the output would be</p>

```
freind
theif
```

<p>However, finding just the words that match our expression is not so useful. If we ran the program on a larger input sequence—for example, on the text of this chapter—we’d want to see the context within which the word occurs, such as</p>

```
hey read or write according to the type
        >>> being <<<
handled. The input operators ignore whi
```

<p>In addition to letting us print the part of the input string that was matched, the match classes give us more detailed information about the match. The operations on these types are listed in <a href="165-17.3._regular_expressions.html#filepos4673403">Table 17.10</a> (p. <a href="165-17.3._regular_expressions.html#filepos4673403">737</a>) and <a href="165-17.3._regular_expressions.html#filepos4673729">Table 17.11</a> (p. <a href="165-17.3._regular_expressions.html#filepos4673729">741</a>).</p>
<p><a id="filepos4673403"></a>Table 17.10. <code>smatch</code> Operations</p>
<img alt="Image" src="/images/00119.jpg"/>
<p><a id="filepos4673729"></a>Table 17.11. Submatch Operations</p>
<img alt="Image" src="/images/00120.jpg"/>
<p><a id="filepos4673923"></a>We’ll have more to say about the <code>smatch</code> and <code>ssub_match</code> types in the next section. For now, what we need to know is that these types let us see the context of a match. The match types have members named <code>prefix</code> and <code>suffix</code>, which return a <code>ssub_match</code> object representing the part of the input sequence ahead of and after the current match, respectively. A <code>ssub_match</code> object has members named <code>str</code> and <code>length</code>, which return the matched <code>string</code> and size of that <code>string</code>, respectively. We can use these operations to rewrite the loop of our grammar program:</p>

```c++
// same for loop header as before
for (sregex_iterator it(file.begin(), file.end(), r), end_it;
         it != end_it; ++it) {
    auto pos = it->prefix().length();   // size of the prefix
    pos = pos > 40 ? pos - 40 : 0;      // we want up to 40 characters
    cout << it->prefix().str().substr(pos)   // last part of the prefix
         << "\n\t\t>>> " << it->str() << " <<<\n" // matched word
         << it->suffix().str().substr(0, 40) // first part of the suffix
         << endl;
}
```

<p>The loop itself operates the same way as our previous program. What’s changed is the processing inside the <code>for</code>, which is illustrated in <a href="165-17.3._regular_expressions.html#filepos4677271">Figure 17.2</a>.</p>
<a id="filepos4677271"></a><img alt="Image" src="/images/00121.jpg"/>
<p>Figure 17.2. The <code>smatch</code> Object Representing a Particular Match</p>
<p>We call <code>prefix</code>, which returns an <code>ssub_match</code> object that represents the part of <code>file</code> ahead of the current match. We call <code>length</code> on that <code>ssub_match</code> to find out how many characters are in the part of <code>file</code> ahead of the match. Next we adjust <code>pos</code> to be the index of the character 40 from the end of the prefix. If the prefix has fewer than 40 characters, we set <code>pos</code> to 0, which means we’ll print the entire prefix. We use <code>substr</code> (§ <a href="093-9.5._additional_string_operations.html#filepos2374493">9.5.1</a>, p. <a href="093-9.5._additional_string_operations.html#filepos2374493">361</a>) to print from the given position to the end of the prefix.</p>
<p><a id="filepos4678845"></a>Having printed the characters that precede the match, we next print the match itself with some additional formatting so that the matched word will stand out in the output. After printing the matched portion, we print (up to) the first 40 characters in the part of <code>file</code> that comes after this match.</p>

::: info
<p>Exercises Section 17.3.2</p>
<p><strong>Exercise 17.17:</strong> Update your program so that it finds all the words in an input sequence that violiate the “ei” grammar rule.</p>
<p><strong>Exercise 17.18:</strong> Revise your program to ignore words that contain “ei” but are not misspellings, such as “albeit” and “neighbor.”</p>
:::

<h4 id="filepos4679975"><a id="filepos4680008"></a>17.3.3. Using Subexpressions</h4>
<p>A pattern in a regular expression often contains one or more <strong><a href="169-defined_terms.html#filepos4851644" id="filepos4680182">subexpressions</a></strong>. A subexpression is a part of the pattern that itself has meaning. Regular-expression grammars typically use parentheses to denote subexpressions.</p>
<p>As an example, the pattern that we used to match C++ files (§ <a href="165-17.3._regular_expressions.html#filepos4639938">17.3.1</a>, p. <a href="165-17.3._regular_expressions.html#filepos4639938">730</a>) used parentheses to group the possible file extensions. Whenever we group alternatives using parentheses, we are also declaring that those alternatives form a subexpression. We can rewrite that expression so that it gives us access to the file name, which is the part of the pattern that precedes the period, as follows:</p>

```c++
// r has two subexpressions: the first is the part of the file name before the period
// the second is the file extension
regex r("([[:alnum:]]+)\\.(cpp|cxx|cc)$", regex::icase);
```

<p>Our pattern now has two parenthesized subexpressions:</p>
<ul><li><code>([[:alnum:]]+)</code>, which is a sequence of one or more characters</li><li><code>(cpp| cxx| cc)</code>, which is the file extension</li></ul>

<p>We can also rewrite the program from § <a href="165-17.3._regular_expressions.html#filepos4639938">17.3.1</a> (p. <a href="165-17.3._regular_expressions.html#filepos4639938">730</a>) to print just the file name by changing the output statement:</p>

```c++
if (regex_search(filename, results, r))
    cout << results.str(1) << endl;  // print the first subexpression
```

<p>As in our original program, we call <code>regex_search</code> to look for our pattern <code>r</code> in the <code>string</code> named <code>filename</code>, and we pass the <code>smatch</code> object <code>results</code> to hold the results of the match. If the call succeeds, then we print the results. However, in this program, we print <code>str(1)</code>, which is the match for the first subexpression.</p>
<p>In addition to providing information about the overall match, the match objects provide access to each matched subexpression in the pattern. The submatches are accessed positionally. The first submatch, which is at position 0, represents the match for the entire pattern. Each subexpression appears in order thereafter. Hence, the file name, which is the first subexpression in our pattern, is at position 1, and the file extension is in position 2.</p>
<p>For example, if the file name is <code>foo.cpp</code>, then <code>results.str(0)</code> will hold <code>foo.cpp</code>; <code>results.str(1)</code> will be <code>foo</code>; and <code>results.str(2)</code> will be <code>cpp</code>. In this program, we want the part of the name before the period, which is the first subexpression, so we print <code>results.str(1)</code>.</p>
<h5>Subexpressions for Data Validation</h5>
<p>One common use for subexpressions is to validate data that must match a specific format. For example, U.S. phone numbers have ten digits, consisting of an area code and a seven-digit local number. The area code is often, but not always, enclosed in parentheses. The remaining seven digits can be separated by a dash, a dot, or a space; or not separated at all. We might want to allow data with any of these formats and reject numbers in other forms. We’ll do a two-step process: First, <a id="filepos4685706"></a>we’ll use a regular expression to find sequences that might be phone numbers and then we’ll call a function to complete the validation of the data.</p>
<p>Before we write our phone number pattern, we need to describe a few more aspects of the ECMAScript regular-expression language:</p>
<ul><li><code>\{d}</code> represents a single digit and <code>\{d}{</code><em>n</em><code>}</code> represents a sequence of <em>n</em> digits. (E.g., <code>\{d}{3}</code> matches a sequence of three digits.)</li><li>A collection of characters inside square brackets allows a match to any of those characters. (E.g., <code>[-. ]</code> matches a dash, a dot, or a space. Note that a dot has no special meaning inside brackets.)</li><li>A component followed by ’?’ is optional. (E.g., <code>\{d}{3}[-. ]?\{d}{4}</code> matches three digits followed by an optional dash, period, or space, followed by four more digits. This pattern would match <code>555-0132</code> or <code>555.0132</code> or <code>555 0132</code> or <code>5550132.)</code></li><li>Like C++, ECMAScript uses a backslash to indicate that a character should represent itself, rather than its special meaning. Because our pattern includes parentheses, which are special characters in ECMAScript, we must represent the parentheses that are part of our pattern as <code>\</code>(or <code>\</code>).</li></ul>

<p>Because backslash is a special character in C++, each place that a <code>\</code> appears in the pattern, we must use a second backslash to indicate to C++ that we want a backslash. Hence, we write <code>\\{d}{3}</code> to represent the regular expression <code>\{d}{3}</code>.</p>
<p>In order to validate our phone numbers, we’ll need access to the components of the pattern. For example, we’ll want to verify that if a number uses an opening parenthesis for the area code, it also uses a close parenthesis after the area code. That is, we’d like to reject a number such as <code>(908.555.1800</code>.</p>
<p>To get at the components of the match, we need to define our regular expression using subexpressions. Each subexpression is marked by a pair of parentheses:</p>

```c++
// our overall expression has seven subexpressions: ( ddd ) separator ddd separator dddd
// subexpressions 1, 3, 4, and 6 are optional; 2, 5, and 7 hold the number
"(\\()?(\\d{3})(\\))?([-. ])?(\\d{3})([-. ]?)(\\d{4})";
```

<p>Because our pattern uses parentheses, and because we must escape backslashes, this pattern can be hard to read (and write!). The easiest way to read it is to pick off each (parenthesized) subexpression:</p>
<ol>
    <li><code>(\\()?</code> an optional open parenthesis for the area code</li>
    <li><code>(\\d{3})</code> the area code</li>
    <li><code>(\\))?</code> an optional close parenthesis for the area code</li>
    <li><code>([-. ])?</code> an optional separator after the area code</li>
    <li><code>(\\d{3})</code> the next three digits of the number</li>
    <li><code>([-. ])?</code> another optional separator</li>
    <li><code>(\\d{4})</code> the final four digits of the number</li>
</ol>

<p><a id="filepos4691750"></a>The following code uses this pattern to read a file and find data that match our overall phone pattern. It will call a function named <code>valid</code> to check whether the number has a valid format:</p>

```c++
string phone =
    "(\\()?(\\d{3})(\\))?([-. ])?(\\d{3})([-. ]?)(\\d{4})";
regex r(phone);  // a regex to find our pattern
smatch m;
string s;
// read each record from the input file
while (getline(cin, s)) {
    // for each matching phone number
    for (sregex_iterator it(s.begin(), s.end(), r), end_it;
               it != end_it; ++it)
        // check whether the number's formatting is valid
        if (valid(*it))
            cout << "valid: " << it->str() << endl;
        else
            cout << "not valid: " << it->str() << endl;
    }
```

<h5>Using the Submatch Operations</h5>
<p>We’ll use submatch operations, which are outlined in <a href="165-17.3._regular_expressions.html#filepos4673729">Table 17.11</a>, to write the <code>valid</code> function. It is important to keep in mind that our <code>pattern</code> has seven subexpressions. As a result, each <code>smatch</code> object will contain eight <code>ssub_match</code> elements. The element at <code>[0]</code>represents the overall match; the elements <code>[1]</code>. . .<code>[7]</code> represent each of the corresponding subexpressions.</p>
<p>When we call <code>valid</code>, we know that we have an overall match, but we do not know which of our optional subexpressions were part of that match. The <code>matched</code> member of the <code>ssub_match</code> corresponding to a particular subexpression is <code>true</code> if that subexpression is part of the overall match.</p>
<p>In a valid phone number, the area code is either fully parenthesized or not parenthesized at all. Therefore, the work <code>valid</code> does depends on whether the number starts with a parenthesis or not:</p>

```c++
bool valid(const smatch& m)
{
    // if there is an open parenthesis before the area code
    if(m[1].matched)
        // the area code must be followed by a close parenthesis
        // and followed immediately by the rest of the number or a space
        return m[3].matched
               && (m[4].matched == 0 || m[4].str() == " ");
    else
        // then there can't be a close after the area code
        // the delimiters between the other two components must match
        return !m[3].matched
               && m[4].str() == m[6].str();
}
```

<p>We start by checking whether the first subexpression (i.e., the open parenthesis) matched. That subexpression is in <code>m[1]</code>. If it matched, then the number starts with an open parenthesis. In this case, the overall number is valid if the subexpression following the area code also matched (meaning that there was a close parenthesis after the area code). Moreover, if the number is correctly parenthesized, then the next character must be a space or the first digit in the next part of the number.</p>
<p>If <code>m[1]</code> didn’t match (i.e., there was no open parenthesis), the subexpression following the area code must also be empty. If it’s empty, then the number is valid if the remaining separators are equal and not otherwise.</p>

::: info
<p>Exercises Section 17.3.3</p>
<p><strong>Exercise 17.19:</strong> Why is it okay to call <code>m[4].str()</code> without first checking whether <code>m[4]</code> was matched?</p>
<p><strong>Exercise 17.20:</strong> Write your own version of the program to validate phone numbers.</p>
<p><strong>Exercise 17.21:</strong> Rewrite your phone number program from § <a href="085-8.3._string_streams.html#filepos2157138">8.3.2</a> (p. <a href="085-8.3._string_streams.html#filepos2157138">323</a>) to use the <code>valid</code> function defined in this section.</p>
<p><strong>Exercise 17.22:</strong> Rewrite your phone program so that it allows any number of whitespace characters to separate the three parts of a phone number.</p>
<p><strong>Exercise 17.23:</strong> Write a regular expression to find zip codes. A zip code can have five or nine digits. The first five digits can be separated from the remaining four by a dash.</p>
:::

<h4 id="filepos4699978">17.3.4. Using <code>regex_replace</code></h4>
<p>Regular expressions are often used when we need not only to find a given sequence but also to replace that sequence with another one. For example, we might want to translate U.S. phone numbers into the form “ddd.ddd.dddd,” where the area code and next three digits are separated by a dot.</p>
<p><a id="filepos4700601"></a>When we want to find and replace a regular expression in the input sequence, we call <code>regex_replace</code>. Like the search functions, <code>regex_replace</code>, which is described in <a href="165-17.3._regular_expressions.html#filepos4701298">Table 17.12</a>, takes an input character sequence and a <code>regex</code> object. We must also pass a string that describes the output we want.</p>
<p><a id="filepos4701298"></a>Table 17.12. Regular Expression Replace Operations</p>
<img alt="Image" src="/images/00122.jpg"/>
<p>We compose a replacement string by including the characters we want, intermixed with subexpressions from the matched substring. In this case, we want to use the second, fifth, and seventh subexpressions in our replacement string. We’ll ignore the first, third, fourth, and sixth, because these were used in the original formatting of the number but are not part of our replacement format. We refer to a particular subexpression by using a <code>$</code> symbol followed by the index number for a subexpression:</p>

```c++
string fmt = "$2.$5.$7"; // reformat numbers to ddd.ddd.dddd
```

<p>We can use our regular-expression pattern and the replacement string as follows:</p>

```c++
regex r(phone);  // a regex to find our pattern
string number = "(908) 555-1800";
cout << regex_replace(number, r, fmt) << endl;
```

<p>The output from this program is</p>

```
908.555.1800
```

<h5>Replacing Only Part of the Input Sequence</h5>
<p>A more interesting use of our regular-expression processing would be to replace phone numbers that are embedded in a larger file. For example, we might have a file of names and phone number that had data like this:</p>
<p><a id="filepos4704033"></a></p>

```
morgan (201) 555-2368 862-555-0123
drew (973)555.0130
lee (609) 555-0132 2015550175 800.555-0000
```

<p>that we want to transform to data like this:</p>

```
morgan 201.555.2368 862.555.0123
drew 973.555.0130
lee 609.555.0132 201.555.0175 800.555.0000
```

<p>We can generate this transformation with the following program:</p>

```c++
int main()
{
    string phone =
       "(\\()?(\\d{3})(\\))?([-. ])?(\\d{3})([-. ])?(\\d{4})";
    regex r(phone);  // a regex to find our pattern
    smatch m;
    string s;
    string fmt = "$2.$5.$7"; // reformat numbers to ddd.ddd.dddd
    // read each record from the input file
    while (getline(cin, s))
        cout << regex_replace(s, r, fmt) << endl;
    return 0;
}
```

<p>We read each record into <code>s</code> and hand that record to <code>regex_replace</code>. This function finds and transforms <em>all</em> the matches in its input sequence.</p>
<h5>Flags to Control Matches and Formatting</h5>
<p>Just as the library defines flags to direct how to process a regular expression, the library also defines flags that we can use to control the match process or the formatting done during a replacement. These values are listed in <a href="165-17.3._regular_expressions.html#filepos4707895">Table 17.13</a> (overleaf). These flags can be passed to the <code>regex_search</code> or <code>regex_match</code> functions or to the <code>format</code> members of class <code>smatch</code>.</p>
<p><a id="filepos4707895"></a>Table 17.13. Match Flags</p>
<img alt="Image" src="/images/00123.jpg"/>
<p>The match and format flags have type <code>match_flag_type</code>. These values are defined in a namespace named <code>regex_constants</code>. Like <code>placeholders</code>, which we used with <code>bind</code> (§ <a href="100-10.3._customizing_operations.html#filepos2586884">10.3.4</a>, p. <a href="100-10.3._customizing_operations.html#filepos2586884">399</a>), <code>regex_constants</code> is a namespace defined inside the <code>std</code> namespace. To use a name from <code>regex_constants</code>, we must qualify that name with the names of both namespaces:</p>

```c++
using std::regex_constants::format_no_copy;
```

<p>This declaration says that when our code uses <code>format_no_copy</code>, we want the object of that name from the namespace <code>std::regex_constants</code>. We can instead provide the alternative form of <code>using</code> that we will cover in § <a href="172-18.2._namespaces.html#filepos4964533">18.2.2</a> (p. <a href="172-18.2._namespaces.html#filepos4964533">792</a>):</p>

```c++
using namespace std::regex_constants;
```

<h5><a id="filepos4710182"></a>Using Format Flags</h5>
<p>By default, <code>regex_replace</code> outputs its entire input sequence. The parts that don’t match the regular expression are output without change; the parts that do match are formatted as indicated by the given format string. We can change this default behavior by specifying <code>format_no_copy</code> in the call to <code>regex_replace</code>:</p>

```c++
// generate just the phone numbers: use a new format string
string fmt2 = "$2.$5.$7 "; // put space after the last number as a separator
// tell regex_replace to copy only the text that it replaces
cout << regex_replace(s, r, fmt2, format_no_copy) << endl;
```

<p>Given the same input, this version of the program generates</p>

```
201.555.2368 862.555.0123
973.555.0130
609.555.0132 201.555.0175 800.555.0000
```

::: info
<p>Exercises Section 17.3.4</p>
<p><strong>Exercise 17.24:</strong> Write your own version of the program to reformat phone numbers.</p>
<p><strong>Exercise 17.25:</strong> Rewrite your phone program so that it writes only the first phone number for each person.</p>
<p><strong>Exercise 17.26:</strong> Rewrite your phone program so that it writes only the second and subsequent phone numbers for people with more than one phone number.</p>
<p><strong>Exercise 17.27:</strong> Write a program that reformats a nine-digit zip code as <code>ddddd-dddd</code>.</p>
:::

---
title: Chapter 12. Dynamic Memory
---

<h2 id="filepos2900383">Chapter 12. Dynamic Memory</h2>
<p>Contents</p><ul><li><strong><a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos2904799">Section 12.1 Dynamic Memory and Smart Pointers</a></strong></li><li><strong><a href="115-12.2._dynamic_arrays.html#filepos3086710">Section 12.2 Dynamic Arrays</a></strong></li><li><strong><a href="116-12.3._using_the_library_a_textquery_program.html#filepos3140586">Section 12.3 Using the Library: A Text-Query Program</a></strong></li><li><strong><a href="117-chapter_summary.html#filepos3185005">Chapter Summary</a></strong></li><li><strong><a href="118-defined_terms.html#filepos3186257">Defined Terms</a></strong></li></ul>

<p>The programs we’ve written so far have used objects that have well-defined lifetimes. Global objects are allocated at program start-up and destroyed when the program ends. Local, automatic objects are created and destroyed when the block in which they are defined is entered and exited. Local <code>static</code> objects are allocated before their first use and are destroyed when the program ends.</p>
<p>In addition to supporting automatic and <code>static</code> objects, C++ lets us allocate objects dynamically. Dynamically allocated objects have a lifetime that is independent of where they are created; they exist until they are explicitly freed.</p>
<p>Properly freeing dynamic objects turns out to be a surprisingly rich source of bugs. To make using dynamic objects safer, the library defines two smart pointer types that manage dynamically allocated objects. Smart pointers ensure that the objects to which they point are automatically freed when it is appropriate to do so.</p>
<p><a id="filepos2902740"></a><em>Our programs</em> have used only static or stack memory. Static memory is used for local <code>static</code> objects (§ <a href="063-6.1._function_basics.html#filepos1431793">6.1.1</a>, p. <a href="063-6.1._function_basics.html#filepos1431793">205</a>), for class <code>static</code> data members (§ <a href="078-7.6._static_class_members.html#filepos2028441">7.6</a>, p. <a href="078-7.6._static_class_members.html#filepos2028441">300</a>), and for variables defined outside any function. Stack memory is used for non<code>static</code> objects defined inside functions. Objects allocated in static or stack memory are automatically created and destroyed by the compiler. Stack objects exist only while the block in which they are defined is executing; <code>static</code> objects are allocated before they are used, and they are destroyed when the program ends.</p>
<p>In addition to static or stack memory, every program also has a pool of memory that it can use. This memory is referred to as the <strong><a href="118-defined_terms.html#filepos3188604" id="filepos2903894">free store</a></strong> or <strong><a href="118-defined_terms.html#filepos3188850" id="filepos2903969">heap</a></strong>. Programs use the heap for objects that they <strong><a href="118-defined_terms.html#filepos3188274" id="filepos2904080">dynamically allocate</a></strong>—that is, for objects that the program allocates at run time. The program controls the lifetime of dynamic objects; our code must explicitly destroy such objects when they are no longer needed.</p>

::: warning
<p>Although necessary at times, dynamic memory is notoriously tricky to manage correctly.</p>
:::

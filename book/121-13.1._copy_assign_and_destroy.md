---
title: 13.1. Copy, Assign, and Destroy
---

<h3 id="filepos3202630">13.1. Copy, Assign, and Destroy</h3>
<p>We’ll start by covering the most basic operations, which are the copy constructor, copy-assignment operator, and destructor. We’ll cover the move operations (which were introduced by the new standard) in § <a href="126-13.6._moving_objects.html#filepos3426774">13.6</a> (p. <a href="126-13.6._moving_objects.html#filepos3426774">531</a>).</p>
<h4 id="filepos3203084">13.1.1. The Copy Constructor</h4>
<Badge type="info" text="Fundamental" />
<p>A constructor is the copy constructor if its first parameter is a reference to the class type and any additional parameters have default values:</p>

```c++
class Foo {
public:
   Foo();             // default constructor
   Foo(const Foo&);   // copy constructor
   // ...
};
```

<p>For reasons we’ll explain shortly, the first parameter must be a reference type. That parameter is almost always a reference to <code>const</code>, although we can define the copy constructor to take a reference to non<code>const</code>. The copy constructor is used implicitly in several circumstances. Hence, the copy constructor usually should not be <code>explicit</code> (§ <a href="077-7.5._constructors_revisited.html#filepos1990205">7.5.4</a>, p. <a href="077-7.5._constructors_revisited.html#filepos1990205">296</a>).</p>
<h5><a id="filepos3204898"></a>The Synthesized Copy Constructor</h5>
<p>When we do not define a copy constructor for a class, the compiler synthesizes one for us. Unlike the synthesized default constructor (§ <a href="073-7.1._defining_abstract_data_types.html#filepos1802479">7.1.4</a>, p. <a href="073-7.1._defining_abstract_data_types.html#filepos1802479">262</a>), a copy constructor is synthesized even if we define other constructors.</p>
<p>As we’ll see in § <a href="121-13.1._copy_assign_and_destroy.html#filepos3263004">13.1.6</a> (p. <a href="121-13.1._copy_assign_and_destroy.html#filepos3263004">508</a>), the <strong><a href="128-defined_terms.html#filepos3543566" id="filepos3205471">synthesized copy constructor</a></strong> for some classes prevents us from copying objects of that class type. Otherwise, the synthesized copy constructor <strong><a href="128-defined_terms.html#filepos3538527" id="filepos3205675">memberwise copies</a></strong> the members of its argument into the object being created (§ <a href="073-7.1._defining_abstract_data_types.html#filepos1827343">7.1.5</a>, p. <a href="073-7.1._defining_abstract_data_types.html#filepos1827343">267</a>). The compiler copies each non<code>static</code> member in turn from the given object into the one being created.</p>
<p>The type of each member determines how that member is copied: Members of class type are copied by the copy constructor for that class; members of built-in type are copied directly. Although we cannot directly copy an array (§ <a href="034-3.5._arrays.html#filepos855259">3.5.1</a>, p. <a href="034-3.5._arrays.html#filepos855259">114</a>), the synthesized copy constructor copies members of array type by copying each element. Elements of class type are copied by using the elements’ copy constructor.</p>
<p>As an example, the synthesized copy constructor for our <code>Sales_data</code> class is equivalent to:</p>

```c++
class Sales_data {
public:
    // other members and constructors as before
    // declaration equivalent to the synthesized copy constructor
    Sales_data(const Sales_data&);
private:
    std::string bookNo;
    int units_sold = 0;
    double revenue = 0.0;
};
// equivalent to the copy constructor that would be synthesized for Sales_data
Sales_data::Sales_data(const Sales_data &orig):
    bookNo(orig.bookNo),         // uses the string copy constructor
    units_sold(orig.units_sold), // copies orig.units_sold
    revenue(orig.revenue)        // copies orig.revenue
    {    }                       // empty body
```

<h5>Copy Initialization</h5>
<p>We are now in a position to fully understand the differences between direct initialization and copy initialization (§ <a href="031-3.2._library_string_type.html#filepos651083">3.2.1</a>, p. <a href="031-3.2._library_string_type.html#filepos651083">84</a>):</p>

```c++
string dots(10, '.');               // direct initialization
string s(dots);                     // direct initialization
string s2 = dots;                   // copy initialization
string null_book = "9-999-99999-9"; // copy initialization
string nines = string(100, '9');    // copy initialization
```

<p>When we use direct initialization, we are asking the compiler to use ordinary function matching (§ <a href="066-6.4._overloaded_functions.html#filepos1597234">6.4</a>, p. <a href="066-6.4._overloaded_functions.html#filepos1597234">233</a>) to select the constructor that best matches the arguments we provide. When we use <strong><a href="128-defined_terms.html#filepos3536714" id="filepos3210850">copy initialization</a></strong>, we are asking the compiler to copy the right-hand operand into the object being created, converting that operand if necessary (§ <a href="077-7.5._constructors_revisited.html#filepos1990205">7.5.4</a>, p. <a href="077-7.5._constructors_revisited.html#filepos1990205">294</a>).</p>
<p><a id="filepos3211194"></a>Copy initialization ordinarily uses the copy constructor. However, as we’ll see in § <a href="126-13.6._moving_objects.html#filepos3443291">13.6.2</a> (p. <a href="126-13.6._moving_objects.html#filepos3443291">534</a>), if a class has a move constructor, then copy initialization sometimes uses the move constructor instead of the copy constructor. For now, what’s useful to know is when copy initialization happens and that copy initialization requires either the copy constructor or the move constructor.</p>
<p>Copy initialization happens not only when we define variables using an <code>=</code>, but also when we</p>
<ul><li>Pass an object as an argument to a parameter of nonreference type</li><li>Return an object from a function that has a nonreference return type</li><li>Brace initialize the elements in an array or the members of an aggregate class (§ <a href="077-7.5._constructors_revisited.html#filepos2013562">7.5.5</a>, p. <a href="077-7.5._constructors_revisited.html#filepos2013562">298</a>)</li></ul>

<p>Some class types also use copy initialization for the objects they allocate. For example, the library containers copy initialize their elements when we initialize the container, or when we call an <code>insert</code> or <code>push</code> member (§ <a href="091-9.3._sequential_container_operations.html#filepos2264356">9.3.1</a>, p. <a href="091-9.3._sequential_container_operations.html#filepos2264356">342</a>). By contrast, elements created by an <code>emplace</code> member are direct initialized (§ <a href="091-9.3._sequential_container_operations.html#filepos2264356">9.3.1</a>, p. <a href="091-9.3._sequential_container_operations.html#filepos2264356">345</a>).</p>
<h5>Parameters and Return Values</h5>
<p>During a function call, parameters that have a nonreference type are copy initialized (§ <a href="064-6.2._argument_passing.html#filepos1453096">6.2.1</a>, p. <a href="064-6.2._argument_passing.html#filepos1453096">209</a>). Similarly, when a function has a nonreference return type, the return value is used to copy initialize the result of the call operator at the call site (§ <a href="065-6.3._return_types_and_the_return_statement.html#filepos1552941">6.3.2</a>, p. <a href="065-6.3._return_types_and_the_return_statement.html#filepos1552941">224</a>).</p>
<p>The fact that the copy constructor is used to initialize nonreference parameters of class type explains why the copy constructor’s own parameter must be a reference. If that parameter were not a reference, then the call would never succeed—to call the copy constructor, we’d need to use the copy constructor to copy the argument, but to copy the argument, we’d need to call the copy constructor, and so on indefinitely.</p>
<h5>Constraints on Copy Initialization</h5>
<p>As we’ve seen, whether we use copy or direct initialization matters if we use an initializer that requires conversion by an <code>explicit</code> constructor (§ <a href="077-7.5._constructors_revisited.html#filepos1990205">7.5.4</a>, p. <a href="077-7.5._constructors_revisited.html#filepos1990205">296</a>):</p>

```c++
vector<int> v1(10);  // ok: direct initialization
vector<int> v2 = 10; // error: constructor that takes a size is explicit
void f(vector<int>); // f's parameter is copy initialized
f(10); // error: can't use an explicit constructor to copy an argument
f(vector<int>(10));  // ok: directly construct a temporary vector from an int
```

<p>Directly initializing <code>v1</code> is fine, but the seemingly equivalent copy initialization of <code>v2</code> is an error, because the <code>vector</code> constructor that takes a single size parameter is <code>explicit</code>. For the same reasons that we cannot copy initialize <code>v2</code>, we cannot implicitly use an <code>explicit</code> constructor when we pass an argument or return a value from a function. If we want to use an <code>explicit</code> constructor, we must do so explicitly, as in the last line of the example above.</p>
<h5><a id="filepos3217170"></a>The Compiler Can Bypass the Copy Constructor</h5>
<p>During copy initialization, the compiler is permitted (but not obligated) to skip the copy/move constructor and create the object directly. That is, the compiler is permitted to rewrite</p>

```c++
string null_book = "9-999-99999-9"; // copy initialization
```

<p>into</p>

```c++
string null_book("9-999-99999-9"); // compiler omits the copy constructor
```

<p>However, even if the compiler omits the call to the copy/move constructor, the copy/move constructor must exist and must be accessible (e.g., not <code>private</code>) at that point in the program.</p>

::: info
<p>Exercises Section 13.1.1</p>
<p><strong>Exercise 13.1:</strong> What is a copy constructor? When is it used?</p>
<p><strong>Exercise 13.2:</strong> Explain why the following declaration is illegal:</p>

```c++
Sales_data::Sales_data(Sales_data rhs);
```

<p><strong>Exercise 13.3:</strong> What happens when we copy a <code>StrBlob?</code> What about <code>StrBlobPtr</code>s?</p>
<p><strong>Exercise 13.4:</strong> Assuming <code>Point</code> is a class type with a <code>public</code> copy constructor, identify each use of the copy constructor in this program fragment:</p>

```c++
Point global;
Point foo_bar(Point arg)
{
    Point local = arg, *heap = new Point(global);
    *heap = local;
    Point pa[ 4 ] = { local, *heap };
    return *heap;
}
```

<p><a id="filepos3220860"></a><strong>Exercise 13.5:</strong> Given the following sketch of a class, write a copy constructor that copies all the members. Your constructor should dynamically allocate a new <code>string</code> (§ <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos2959483">12.1.2</a>, p. <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos2959483">458</a>) and copy the object to which <code>ps</code> points, rather than copying <code>ps</code> itself.</p>

```c++
class HasPtr {
public:
    HasPtr(const std::string &s = std::string()):
        ps(new std::string(s)), i(0) { }
private:
    std::string *ps;
    int    i;
};
```

:::

<h4 id="filepos3222083"><a id="filepos3222116"></a>13.1.2. The Copy-Assignment Operator</h4>
<Badge type="info" text="Fundamental" />
<p>Just as a class controls how objects of that class are initialized, it also controls how objects of its class are assigned:</p>

```c++
Sales_data trans, accum;
trans = accum; // uses the Sales_data copy-assignment operator
```

<p>As with the copy constructor, the compiler synthesizes a copy-assignment operator if the class does not define its own.</p>
<h5>Introducing Overloaded Assignment</h5>
<p>Before we look at the synthesized assignment operator, we need to know a bit about <strong><a href="128-defined_terms.html#filepos3540925" id="filepos3223421">overloaded operators</a></strong>, which we cover in detail in <a href="129-chapter_14._overloaded_operations_and_conversions.html#filepos3544393">Chapter 14</a>.</p>
<p>Overloaded operators are functions that have the name <code>operator</code> followed by the symbol for the operator being defined. Hence, the assignment operator is a function named <code>operator=</code>. Like any other function, an operator function has a return type and a parameter list.</p>
<p>The parameters in an overloaded operator represent the operands of the operator. Some operators, assignment among them, must be defined as member functions. When an operator is a member function, the left-hand operand is bound to the implicit <code>this</code> parameter (§ <a href="073-7.1._defining_abstract_data_types.html#filepos1761316">7.1.2</a>, p. <a href="073-7.1._defining_abstract_data_types.html#filepos1761316">257</a>). The right-hand operand in a binary operator, such as assignment, is passed as an explicit parameter.</p>
<p>The copy-assignment operator takes an argument of the same type as the class:</p>

```c++
class Foo {
public:
    Foo& operator=(const Foo&); // assignment operator
   // ...
};
```

<p>To be consistent with assignment for the built-in types (§ <a href="042-4.4._assignment_operators.html#filepos1066463">4.4</a>, p. <a href="042-4.4._assignment_operators.html#filepos1066463">145</a>), assignment operators usually return a reference to their left-hand operand. It is also worth noting that the library generally requires that types stored in a container have assignment operators that return a reference to the left-hand operand.</p>

::: tip
<p>Best Practices</p>
<p>Assignment operators ordinarily should return a reference to their left-hand operand.</p>
:::

<h5>The Synthesized Copy-Assignment Operator</h5>
<p>Just as it does for the copy constructor, the compiler generates a <strong><a href="128-defined_terms.html#filepos3543090" id="filepos3226399">synthesized copy-assignment operator</a></strong> for a class if the class does not define its own. Analogously to the copy constructor, for some classes the synthesized copy-assignment operator disallows assignment (§ <a href="121-13.1._copy_assign_and_destroy.html#filepos3263004">13.1.6</a>, p. <a href="121-13.1._copy_assign_and_destroy.html#filepos3263004">508</a>). Otherwise, it assigns each non<code>static</code> member of the right-hand object to the corresponding member of the left-hand object using the copy-assignment operator for the type of that member. Array members are assigned by assigning each element of the array. The synthesized copy-assignment operator returns a reference to its left-hand object.</p>
<p><a id="filepos3227201"></a>As an example, the following is equivalent to the synthesized <code>Sales_data</code> copy-assignment operator:</p>

```c++
// equivalent to the synthesized copy-assignment operator
Sales_data&
Sales_data::operator=(const Sales_data &rhs)
{
    bookNo = rhs.bookNo;          // calls the string::operator=
    units_sold = rhs.units_sold;  // uses the built-in int assignment
    revenue = rhs.revenue;        // uses the built-in double assignment
    return *this;                 // return a reference to this object
}
```

::: info
<p>Exercises Section 13.1.2</p>
<p><strong>Exercise 13.6:</strong> What is a copy-assignment operator? When is this operator used? What does the synthesized copy-assignment operator do? When is it synthesized?</p>
<p><strong>Exercise 13.7:</strong> What happens when we assign one <code>StrBlob</code> to another? What about <code>StrBlobPtr</code>s?</p>
<p><strong>Exercise 13.8:</strong> Write the assignment operator for the <code>HasPtr</code> class from <a href="121-13.1._copy_assign_and_destroy.html#filepos3220860">exercise 13.5</a> in § <a href="121-13.1._copy_assign_and_destroy.html#filepos3203084">13.1.1</a> (p. <a href="121-13.1._copy_assign_and_destroy.html#filepos3203084">499</a>). As with the copy constructor, your assignment operator should copy the object to which <code>ps</code> points.</p>
:::

<h4 id="filepos3230370">13.1.3. The Destructor</h4>
<Badge type="info" text="Fundamental" />
<p>The destructor operates inversely to the constructors: Constructors initialize the non<code>static</code> data members of an object and may do other work; destructors do whatever work is needed to free the resources used by an object and destroy the non<code>static</code> data members of the object.</p>
<p>The destructor is a member function with the name of the class prefixed by a tilde (<code>~</code>). It has no return value and takes no parameters:</p>

```c++
class Foo {
public:
    ~Foo();    // destructor
   // ...
};
```

<p>Because it takes no parameters, it cannot be overloaded. There is always only one destructor for a given class.</p>
<h5>What a Destructor Does</h5>
<p>Just as a constructor has an initialization part and a function body (§ <a href="077-7.5._constructors_revisited.html#filepos1953073">7.5.1</a>, p. <a href="077-7.5._constructors_revisited.html#filepos1953073">288</a>), a destructor has a function body and a destruction part. In a constructor, members are initialized before the function body is executed, and members are initialized <a id="filepos3232251"></a>in the same order as they appear in the class. In a destructor, the function body is executed first and then the members are destroyed. Members are destroyed in reverse order from the order in which they were initialized.</p>
<p>The function body of a destructor does whatever operations the class designer wishes to have executed subsequent to the last use of an object. Typically, the destructor frees resources an object allocated during its lifetime.</p>
<p>In a destructor, there is nothing akin to the constructor initializer list to control how members are destroyed; the destruction part is implicit. What happens when a member is destroyed depends on the type of the member. Members of class type are destroyed by running the member’s own destructor. The built-in types do not have destructors, so nothing is done to destroy members of built-in type.</p>

::: info
<p>The implicit destruction of a member of built-in pointer type does <em>not</em>
<code>delete</code> the object to which that pointer points.</p>
:::

<p>Unlike ordinary pointers, the smart pointers (§ <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos2907541">12.1.1</a>, p. <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos2907541">452</a>) are class types and have destructors. As a result, unlike ordinary pointers, members that are smart pointers are automatically destroyed during the destruction phase.</p>
<h5>When a Destructor Is Called</h5>
<p>The destructor is used automatically whenever an object of its type is destroyed:</p>
<ul><li>Variables are destroyed when they go out of scope.</li><li>Members of an object are destroyed when the object of which they are a part is destroyed.</li><li>Elements in a container—whether a library container or an array—are destroyed when the container is destroyed.</li><li>Dynamically allocated objects are destroyed when the <code>delete</code> operator is applied to a pointer to the object (§ <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos2959483">12.1.2</a>, p. <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos2959483">460</a>).</li><li>Temporary objects are destroyed at the end of the full expression in which the temporary was created.</li></ul>

<p>Because destructors are run automatically, our programs can allocate resources and (usually) not worry about when those resources are released.</p>
<p>For example, the following fragment defines four <code>Sales_data</code> objects:</p>

```c++
{ // new scope
    // p and p2 point to dynamically allocated objects
    Sales_data  *p = new Sales_data;     // p is a built-in pointer
    auto p2 = make_shared<Sales_data>(); // p2 is a shared_ptr
    Sales_data item(*p);     // copy constructor copies *p into item
    vector<Sales_data> vec;  // local object
    vec.push_back(*p2);      // copies the object to which p2 points
    delete p;                // destructor called on the object pointed to by p
} // exit local scope; destructor called on item, p2, and vec
  // destroying p2 decrements its use count; if the count goes to 0, the object is freed
  // destroying vec destroys the elements in vec
```

<p><a id="filepos3239490"></a>Each of these objects contains a <code>string</code> member, which allocates dynamic memory to contain the characters in its <code>bookNo</code> member. However, the only memory our code has to manage directly is the object we directly allocated. Our code directly frees only the dynamically allocated object bound to <code>p</code>.</p>
<p>The other <code>Sales_data</code> objects are automatically destroyed when they go out of scope. When the block ends, <code>vec, p2</code>, and <code>item</code> all go out of scope, which means that the <code>vector, shared_ptr</code>, and <code>Sales_data</code> destructors will be run on those objects, respectively. The <code>vector</code> destructor will destroy the element we pushed onto <code>vec</code>. The <code>shared_ptr</code> destructor will decrement the reference count of the object to which <code>p2</code> points. In this example, that count will go to zero, so the <code>shared_ptr</code> destructor will <code>delete</code> the <code>Sales_data</code> object that <code>p2</code> allocated.</p>
<p>In all cases, the <code>Sales_data</code> destructor implicitly destroys the <code>bookNo</code> member. Destroying <code>bookNo</code> runs the <code>string</code> destructor, which frees the memory used to store the <small>ISBN</small>.</p>

::: info
<p>The destructor is <em>not</em> run when a reference or a pointer to an object goes out of scope.</p>
:::

<h5>The Synthesized Destructor</h5>
<p>The compiler defines a <strong><a href="128-defined_terms.html#filepos3544086" id="filepos3242525">synthesized destructor</a></strong> for any class that does not define its own destructor. As with the copy constructor and the copy-assignment operator, for some classes, the synthesized destructor is defined to disallow objects of the type from being destroyed (§ <a href="121-13.1._copy_assign_and_destroy.html#filepos3263004">13.1.6</a>, p. <a href="121-13.1._copy_assign_and_destroy.html#filepos3263004">508</a>). Otherwise, the synthesized destructor has an empty function body.</p>
<p>For example, the synthesized <code>Sales_data</code> destructor is equivalent to:</p>

```c++
class Sales_data {
public:
   // no work to do other than destroying the members, which happens automatically
    ~Sales_data() { }
   // other members as before
};
```

<p>The members are automatically destroyed after the (empty) destructor body is run. In particular, the <code>string</code> destructor will be run to free the memory used by the <code>bookNo</code> member.</p>
<p>It is important to realize that the destructor body does not directly destroy the members themselves. Members are destroyed as part of the implicit destruction phase that follows the destructor body. A destructor body executes <em>in addition to</em> the memberwise destruction that takes place as part of destroying an object.</p>
<h4 id="filepos3244603">13.1.4. The Rule of Three/Five</h4>
<Badge type="info" text="Fundamental" />
<p>As we’ve seen, there are three basic operations to control copies of class objects: the copy constructor, copy-assignment operator, and destructor. Moreover, as we’ll see in § <a href="126-13.6._moving_objects.html#filepos3426774">13.6</a> (p. <a href="126-13.6._moving_objects.html#filepos3426774">531</a>), under the new standard, a class can also define a move constructor and move-assignment operator.</p>

::: info
<p>Exercises Section 13.1.3</p>
<p><strong>Exercise 13.9:</strong> What is a destructor? What does the synthesized destructor do? When is a destructor synthesized?</p>
<p><strong>Exercise 13.10:</strong> What happens when a <code>StrBlob</code> object is destroyed? What about a <code>StrBlobPtr</code>?</p>
<p><strong>Exercise 13.11:</strong> Add a destructor to your <code>HasPtr</code> class from the previous exercises.</p>
<p><strong>Exercise 13.12:</strong> How many destructor calls occur in the following code fragment?</p>

```c++
bool fcn(const Sales_data *trans, Sales_data accum)
{
    Sales_data item1(*trans), item2(accum);
    return item1.isbn() != item2.isbn();
}
```

<p><strong>Exercise 13.13:</strong> A good way to understand copy-control members and constructors is to define a simple class with these members in which each member prints its name:</p>

```c++
struct X {
    X() {std::cout << "X()" << std::endl;}
    X(const X&) {std::cout << "X(const X&)" << std::endl;}
};
```

<p>Add the copy-assignment operator and destructor to <code>X</code> and write a program using <code>X</code> objects in various ways: Pass them as nonreference and reference parameters; dynamically allocate them; put them in containers; and so forth. Study the output until you are certain you understand when and why each copy-control member is used. As you read the output, remember that the compiler can omit calls to the copy constructor.</p>
:::

<p>There is no requirement that we define all of these operations: We can define one or two of them without having to define all of them. However, ordinarily these operations should be thought of as a unit. In general, it is unusual to need one without needing to define them all.</p>
<h5>Classes That Need Destructors Need Copy and Assignment</h5>
<p>One rule of thumb to use when you decide whether a class needs to define its own versions of the copy-control members is to decide first whether the class needs a destructor. Often, the need for a destructor is more obvious than the need for the copy constructor or assignment operator. If the class needs a destructor, it almost surely needs a copy constructor and copy-assignment operator as well.</p>
<p>The <code>HasPtr</code> class that we have used in the exercises is a good example (§ <a href="121-13.1._copy_assign_and_destroy.html#filepos3203084">13.1.1</a>, p. <a href="121-13.1._copy_assign_and_destroy.html#filepos3203084">499</a>). That class allocates dynamic memory in its constructor. The synthesized destructor will not <code>delete</code> a data member that is a pointer. Therefore, this class needs to define a destructor to free the memory allocated by its constructor.</p>
<p>What may be less clear—but what our rule of thumb tells us—is that <code>HasPtr</code> also needs a copy constructor and copy-assignment operator.</p>
<p><a id="filepos3250064"></a>Consider what would happen if we gave <code>HasPtr</code> a destructor but used the synthesized versions of the copy constructor and copy-assignment operator:</p>

```c++
class HasPtr {
public:
    HasPtr(const std::string &s = std::string()):
        ps(new std::string(s)), i(0) { }
    ~HasPtr() { delete ps; }
    // WRONG: HasPtr needs a copy constructor and copy-assignment operator
    // other members as before
};
```

<p>In this version of the class, the memory allocated in the constructor will be freed when a <code>HasPtr</code> object is destroyed. Unfortunately, we have introduced a serious bug! This version of the class uses the synthesized versions of copy and assignment. Those functions copy the pointer member, meaning that multiple <code>HasPtr</code> objects may be pointing to the same memory:</p>

```c++
HasPtr f(HasPtr hp)  // HasPtr passed by value, so it is copied
{
    HasPtr ret = hp; // copies the given HasPtr
    // process ret
    return ret;      // ret and hp are destroyed
}
```

<p>When <code>f</code> returns, both <code>hp</code> and <code>ret</code> are destroyed and the <code>HasPtr</code> destructor is run on each of these objects. That destructor will <code>delete</code> the pointer member in <code>ret</code> and in <code>hp</code>. But these objects contain the same pointer value. This code will <code>delete</code> that pointer twice, which is an error (§ <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos2959483">12.1.2</a>, p. <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos2959483">462</a>). What happens is undefined.</p>
<p>In addition, the caller of <code>f</code> may still be using the object that was passed to <code>f</code>:</p>

```c++
HasPtr p("some values");
f(p);        // when f completes, the memory to which p.ps points is freed
HasPtr q(p); // now both p and q point to invalid memory!
```

<p>The memory to which <code>p</code> (and <code>q</code>) points is no longer valid. It was returned to the system when <code>hp</code> (or <code>ret!)</code> was destroyed.</p>

::: tip
<p>If a class needs a destructor, it almost surely also needs the copy-assignment operator and a copy constructor.</p>
:::

<h5>Classes That Need Copy Need Assignment, and Vice Versa</h5>
<p>Although many classes need to define all of (or none of) the copy-control members, some classes have work that needs to be done to copy or assign objects but has no need for the destructor.</p>
<p>As an example, consider a class that gives each object its own, unique serial number. Such a class would need a copy constructor to generate a new, distinct serial number for the object being created. That constructor would copy all the other data members from the given object. This class would also need its own <a id="filepos3257021"></a>copy-assignment operator to avoid assigning to the serial number of the left-hand object. However, this class would have no need for a destructor.</p>
<p>This example gives rise to a second rule of thumb: If a class needs a copy constructor, it almost surely needs a copy-assignment operator. And vice versa—if the class needs an assignment operator, it almost surely needs a copy constructor as well. Nevertheless, needing either the copy constructor or the copy-assignment operator does not (necessarily) indicate the need for a destructor.</p>

::: info
<p>Exercises Section 13.1.4</p>
<p><strong>Exercise 13.14:</strong> Assume that <code>numbered</code> is a class with a default constructor that generates a unique serial number for each object, which is stored in a data member named <code>mysn</code>. Assuming <code>numbered</code> uses the synthesized copy-control members and given the following function:</p>

```c++
void f (numbered s) { cout << s.mysn << endl; }
```

<p>what output does the following code produce?</p>

```c++
numbered a, b = a, c = b;
f(a); f(b); f(c);
```

<p><strong>Exercise 13.15:</strong> Assume <code>numbered</code> has a copy constructor that generates a new serial number. Does that change the output of the calls in the previous exercise? If so, why? What output gets generated?</p>
<p><strong>Exercise 13.16:</strong> What if the parameter in <code>f</code> were <code>const numbered&amp;?</code> Does that change the output? If so, why? What output gets generated?</p>
<p><strong>Exercise 13.17:</strong> Write versions of <code>numbered</code> and <code>f</code> corresponding to the previous three exercises and check whether you correctly predicted the output.</p>
:::

<h4 id="filepos3260372">13.1.5. Using <code>= default</code></h4>
<a id="filepos3260607"></a><Badge type="tip" text="C++11" />
<p>We can explicitly ask the compiler to generate the synthesized versions of the copy-control members by defining them as <code>= default</code> (§ <a href="073-7.1._defining_abstract_data_types.html#filepos1802479">7.1.4</a>, p. <a href="073-7.1._defining_abstract_data_types.html#filepos1802479">264</a>):</p>

```c++
class Sales_data {
public:
    // copy control; use defaults
    Sales_data() = default;
    Sales_data(const Sales_data&) = default;
    Sales_data& operator=(const Sales_data &);
    ~Sales_data() = default;
    // other members as before
};
Sales_data& Sales_data::operator=(const Sales_data&) = default;
```

<p>When we specify <code>= default</code> on the declaration of the member inside the class body, the synthesized function is implicitly inline (just as is any other member <a id="filepos3262148"></a>function defined in the body of the class). If we do not want the synthesized member to be an inline function, we can specify <code>= default</code> on the member’s definition, as we do in the definition of the copy-assignment operator.</p>

::: info
<p>We can use <code>= default</code> only on member functions that have a synthesized version (i.e., the default constructor or a copy-control member).</p>
:::

<h4 id="filepos3263004">13.1.6. Preventing Copies</h4>

::: tip
<p>Best Practices</p>
<p>Most classes should define—either implicitly or explicitly—the default and copy constructors and the copy-assignment operator.</p>
:::

<p>Although most classes should (and generally do) define a copy constructor and a copy-assignment operator, for some classes, there really is no sensible meaning for these operations. In such cases, the class must be defined so as to prevent copies or assignments from being made. For example, the <code>iostream</code> classes prevent copying to avoid letting multiple objects write to or read from the same IO buffer. It might seem that we could prevent copies by not defining the copy-control members. However, this strategy doesn’t work: If our class doesn’t define these operations, the compiler will synthesize them.</p>
<h5>Defining a Function as Deleted</h5>
<a id="filepos3264432"></a><Badge type="tip" text="C++11" />
<p>Under the new standard, we can prevent copies by defining the copy constructor and copy-assignment operator as <strong><a href="128-defined_terms.html#filepos3537295" id="filepos3264638">deleted functions</a></strong>. A deleted function is one that is declared but may not be used in any other way. We indicate that we want to define a function as deleted by following its parameter list with <code>= delete</code>:</p>

```c++
struct NoCopy {
    NoCopy() = default;    // use the synthesized default constructor
    NoCopy(const NoCopy&) = delete;            // no copy
    NoCopy &operator=(const NoCopy&) = delete; // no assignment
    ~NoCopy() = default;   // use the synthesized destructor
    // other members
};
```

<p>The <code>= delete</code> signals to the compiler (and to readers of our code) that we are intentionally <em>not defining</em> these members.</p>
<p>Unlike <code>= default, = delete</code> must appear on the first declaration of a deleted function. This difference follows logically from the meaning of these declarations. A defaulted member affects only what code the compiler generates; hence the <code>= default</code> is not needed until the compiler generates code. On the other hand, the compiler needs to know that a function is deleted in order to prohibit operations that attempt to use it.</p>
<p>Also unlike <code>= default</code>, we can specify <code>= delete</code> on any function (we can use <code>= default</code> only on the default constructor or a copy-control member that the compiler can synthesize). Although the primary use of deleted functions is to <a id="filepos3267436"></a>suppress the copy-control members, deleted functions are sometimes also useful when we want to guide the function-matching process.</p>
<h5>The Destructor Should Not be a Deleted Member</h5>
<p>It is worth noting that we did not delete the destructor. If the destructor is deleted, then there is no way to destroy objects of that type. The compiler will not let us define variables or create temporaries of a type that has a deleted destructor. Moreover, we cannot define variables or temporaries of a class that has a member whose type has a deleted destructor. If a member has a deleted destructor, then that member cannot be destroyed. If a member can’t be destroyed, the object as a whole can’t be destroyed.</p>
<p>Although we cannot define variables or members of such types, we can dynamically allocate objects with a deleted destructor. However, we cannot free them:</p>

```c++
struct NoDtor {
    NoDtor() =  default;  // use the synthesized default constructor
    ~NoDtor() = delete;  // we can't destroy objects of type NoDtor
};
NoDtor nd;  // error: NoDtor destructor is deleted
NoDtor *p = new NoDtor();   // ok: but we can't delete p
delete p; // error: NoDtor destructor is deleted
```

::: warning
<p>It is not possible to define an object or delete a pointer to a dynamically allocated object of a type with a deleted destructor.</p>
:::

<h5>The Copy-Control Members May Be Synthesized as Deleted</h5>
<p>As we’ve seen, if we do not define the copy-control members, the compiler defines them for us. Similarly, if a class defines no constructors, the compiler synthesizes a default constructor for that class (§ <a href="073-7.1._defining_abstract_data_types.html#filepos1802479">7.1.4</a>, p. <a href="073-7.1._defining_abstract_data_types.html#filepos1802479">262</a>). For some classes, the compiler defines these synthesized members as deleted functions:</p>
<ul><li>The synthesized destructor is defined as deleted if the class has a member whose own destructor is deleted or is inaccessible (e.g., <code>private</code>).</li><li>The synthesized copy constructor is defined as deleted if the class has a member whose own copy constructor is deleted or inaccessible. It is also deleted if the class has a member with a deleted or inaccessible destructor.</li><li>The synthesized copy-assignment operator is defined as deleted if a member has a deleted or inaccessible copy-assignment operator, or if the class has a <code>const</code> or reference member.</li><li>The synthesized default constructor is defined as deleted if the class has a member with a deleted or inaccessible destructor; or has a reference member that does not have an in-class initializer (§ <a href="026-2.6._defining_our_own_data_structures.html#filepos578460">2.6.1</a>, p. <a href="026-2.6._defining_our_own_data_structures.html#filepos578460">73</a>); or has a <code>const</code> member whose type does not explicitly define a default constructor and that member does not have an in-class initializer.</li></ul>

<p><a id="filepos3272556"></a>In essence, these rules mean that if a class has a data member that cannot be default constructed, copied, assigned, or destroyed, then the corresponding member will be a deleted function.</p>
<p>It may be surprising that a member that has a deleted or inaccessible destructor causes the synthesized default and copy constructors to be defined as deleted. The reason for this rule is that without it, we could create objects that we could not destroy.</p>
<p>It should not be surprising that the compiler will not synthesize a default constructor for a class with a reference member or a <code>const</code> member that cannot be default constructed. Nor should it be surprising that a class with a <code>const</code> member cannot use the synthesized copy-assignment operator: After all, that operator attempts to assign to every member. It is not possible to assign a new value to a <code>const</code> object.</p>
<p>Although we can assign a new value to a reference, doing so changes the value of the object to which the reference refers. If the copy-assignment operator were synthesized for such classes, the left-hand operand would continue to refer to the same object as it did before the assignment. It would not refer to the same object as the right-hand operand. Because this behavior is unlikely to be desired, the synthesized copy-assignment operator is defined as deleted if the class has a reference member.</p>
<p>We’ll see in § <a href="126-13.6._moving_objects.html#filepos3443291">13.6.2</a> (p. <a href="126-13.6._moving_objects.html#filepos3443291">539</a>), § <a href="148-15.7._constructors_and_copy_control.html#filepos3980968">15.7.2</a> (p. <a href="148-15.7._constructors_and_copy_control.html#filepos3980968">624</a>), and § <a href="182-19.6._union_a_spacesaving_class.html#filepos5306482">19.6</a> (p. <a href="182-19.6._union_a_spacesaving_class.html#filepos5306482">849</a>) that there are other aspects of a class that can cause its copy members to be defined as deleted.</p>

::: info
<p>In essence, the copy-control members are synthesized as deleted when it is impossible to copy, assign, or destroy a member of the class.</p>
:::

<h5><code>private</code> Copy Control</h5>
<p>Prior to the new standard, classes prevented copies by declaring their copy constructor and copy-assignment operator as <code>private</code>:</p>

```c++
class PrivateCopy {
    // no access specifier; following members are private by default; see § 7.2 (p. 268)
    // copy control is private and so is inaccessible to ordinary user code
    PrivateCopy(const PrivateCopy&);
    PrivateCopy &operator=(const PrivateCopy&);
    // other members
public:
    PrivateCopy() = default; // use the synthesized default constructor
    ~PrivateCopy(); // users can define objects of this type but not copy them
};
```

<p>Because the destructor is <code>public</code>, users will be able to define <code>PrivateCopy</code> objects. However, because the copy constructor and copy-assignment operator are <code>private</code>, user code will not be able to copy such objects. However, friends and members of the class can still make copies. To prevent copies by friends and members, we declare these members as <code>private</code> but do not define them.</p>
<p>With one exception, which we’ll cover in § <a href="143-15.2._defining_base_and_derived_classes.html#filepos3796139">15.2.1</a> (p. <a href="143-15.2._defining_base_and_derived_classes.html#filepos3796139">594</a>), it is legal to declare, but not define, a member function (§ <a href="063-6.1._function_basics.html#filepos1441405">6.1.2</a>, p. <a href="063-6.1._function_basics.html#filepos1441405">206</a>). An attempt to <em>use</em> an undefined member results in a link-time failure. By declaring (but not defining) a <code>private</code> copy constructor, we can forestall any attempt to copy an object of the class type: User code that tries to make a copy will be flagged as an error at compile time; copies made in member functions or friends will result in an error at link time.</p>

::: tip
<p>Best Practices</p>
<p>Classes that want to prevent copying should define their copy constructor and copy-assignment operators using <code>= delete</code> rather than making those members <code>private</code>.</p>
:::

::: info
<p>Exercises Section 13.1.6</p>
<p><strong>Exercise 13.18:</strong> Define an <code>Employee</code> class that contains an employee name and a unique employee identifier. Give the class a default constructor and a constructor that takes a <code>string</code> representing the employee’s name. Each constructor should generate a unique ID by incrementing a <code>static</code> data member.</p>
<p><strong>Exercise 13.19:</strong> Does your <code>Employee</code> class need to define its own versions of the copy-control members? If so, why? If not, why not? Implement whatever copy-control members you think <code>Employee</code> needs.</p>
<p><strong>Exercise 13.20:</strong> Explain what happens when we copy, assign, or destroy objects of our <code>TextQuery</code> and <code>QueryResult</code> classes from § <a href="116-12.3._using_the_library_a_textquery_program.html#filepos3140586">12.3</a> (p. <a href="116-12.3._using_the_library_a_textquery_program.html#filepos3140586">484</a>).</p>
<p><strong>Exercise 13.21:</strong> Do you think the <code>TextQuery</code> and <code>QueryResult</code> classes need to define their own versions of the copy-control members? If so, why? If not, why not? Implement whichever copy-control operations you think these classes require.</p>
:::

<h3 id="filepos4756189">17.5. The IO Library Revisited</h3>
<p>In <a href="082-chapter_8._the_io_library.html#filepos2071768">Chapter 8</a> we introduced the basic architecture and most commonly used parts of the IO library. In this section we’ll look at three of the more specialized features that the IO library supports: format control, unformatted IO, and random access.</p>

::: info
<a id="filepos4756659"></a><p>Exercises Section 17.4.2</p>
<p><strong>Exercise 17.31:</strong> What would happen if we defined <code>b</code> and <code>e</code> inside the <code>do</code> loop of the game-playing program from this section?</p>
<p><strong>Exercise 17.32:</strong> What would happen if we defined <code>resp</code> inside the loop?</p>
<p><strong>Exercise 17.33:</strong> Write a version of the word transformation program from § <a href="109-11.3._operations_on_associative_containers.html#filepos2854545">11.3.6</a> (p. <a href="109-11.3._operations_on_associative_containers.html#filepos2854545">440</a>) that allows multiple transformations for a given word and randomly selects which transformation to apply.</p>
:::

<h4 id="filepos4757882">17.5.1. Formatted Input and Output</h4>
<p>In addition to its condition state (§ <a href="083-8.1._the_io_classes.html#filepos2085669">8.1.2</a>, p. <a href="083-8.1._the_io_classes.html#filepos2085669">312</a>), each <code>iostream</code> object also maintains a format state that controls the details of how IO is formatted. The format state controls aspects of formatting such as the notational base for integral values, the precision of floating-point values, the width of an output element, and so on.</p>
<p>The library defines a set of <strong><a href="169-defined_terms.html#filepos4845936" id="filepos4758578">manipulators</a></strong> (§ <a href="012-1.2._a_first_look_at_inputoutput.html#filepos136281">1.2</a>, p. <a href="012-1.2._a_first_look_at_inputoutput.html#filepos136281">7</a>), listed in <a href="167-17.5._the_io_library_revisited.html#filepos4779193">Tables 17.17</a> (p. <a href="167-17.5._the_io_library_revisited.html#filepos4779193">757</a>) and <a href="167-17.5._the_io_library_revisited.html#filepos4792681">17.18</a> (p. <a href="167-17.5._the_io_library_revisited.html#filepos4792681">760</a>), that modify the format state of a stream. A manipulator is a function or object that affects the state of a stream and can be used as an operand to an input or output operator. Like the input and output operators, a manipulator returns the stream object to which it is applied, so we can combine manipulators and data in a single statement.</p>
<p>Our programs have already used one manipulator, <code>endl</code>, which we “write” to an output stream as if it were a value. But <code>endl</code> isn’t an ordinary value; instead, it performs an operation: It writes a newline and flushes the buffer.</p>
<h5>Many Manipulators Change the Format State</h5>
<p>Manipulators are used for two broad categories of output control: controlling the presentation of numeric values and controlling the amount and placement of padding. Most of the manipulators that change the format state provide set/unset pairs; one manipulator sets the format state to a new value and the other unsets it, restoring the normal default formatting.</p>

::: warning
<p>Manipulators that change the format state of the stream usually leave the format state changed for all subsequent IO.</p>
:::

<p>The fact that a manipulator makes a persistent change to the format state can be useful when we have a set of IO operations that want to use the same formatting. Indeed, some programs take advantage of this aspect of manipulators to reset the behavior of one or more formatting rules for all its input or output. In such cases, the fact that a manipulator changes the stream is a desirable property.</p>
<p>However, many programs (and, more importantly, programmers) expect the state of the stream to match the normal library defaults. In these cases, leaving the state of the stream in a nonstandard state can lead to errors. As a result, it is usually best to undo whatever state changes are made as soon as those changes are no longer needed.</p>
<h5><a id="filepos4761570"></a>Controlling the Format of Boolean Values</h5>
<p>One example of a manipulator that changes the formatting state of its object is the <code>boolalpha</code> manipulator. By default, <code>bool</code> values print as <code>1</code> or <code>0</code>. A <code>true</code> value is written as the integer <code>1</code> and a <code>false</code> value as <code>0</code>. We can override this formatting by applying the <code>boolalpha</code> manipulator to the stream:</p>

```c++
cout << "default bool values: " << true << " " << false
     << "\nalpha bool values: " << boolalpha
     << true << " " << false << endl;
```

<p>When executed, this program generates the following:</p>

```
default bool values: 1 0
alpha bool values: true false
```

<p>Once we “write” <code>boolalpha</code> on <code>cout</code>, we’ve changed how <code>cout</code> will print <code>bool</code> values from this point on. Subsequent operations that print <code>bool</code>s will print them as either <code>true</code> or <code>false</code>.</p>
<p>To undo the format state change to <code>cout</code>, we apply <code>noboolalpha</code>:</p>

```c++
bool bool_val = get_status();
cout << boolalpha    // sets the internal state of cout
     << bool_val
     << noboolalpha; // resets the internal state to default formatting
```

<p>Here we change the format of <code>bool</code> values only to print the value of <code>bool_val</code>. Once that value is printed, we immediately reset the stream back to its initial state.</p>
<h5>Specifying the Base for Integral Values</h5>
<p>By default, integral values are written and read in decimal notation. We can change the notational base to octal or hexadecimal or back to decimal by using the manipulators <code>hex, oct</code>, and <code>dec</code>:</p>

```c++
cout << "default: " << 20 << " " << 1024 << endl;
cout << "octal: " << oct << 20 << " " << 1024 << endl;
cout << "hex: " << hex << 20 << " " << 1024 << endl;
cout << "decimal: " << dec << 20 << " " << 1024 << endl;
```

<p>When compiled and executed, this program generates the following output:</p>

```
default: 20 1024
octal: 24 2000
hex: 14 400
decimal: 20 1024
```

<p>Notice that like <code>boolalpha</code>, these manipulators change the format state. They affect the immediately following output and all subsequent integral output until the format is reset by invoking another manipulator.</p>

::: info
<p>The <code>hex, oct</code>, and <code>dec</code> manipulators affect only integral operands; the representation of floating-point values is unaffected.</p>
:::

<h5><a id="filepos4768479"></a>Indicating Base on the Output</h5>
<p>By default, when we print numbers, there is no visual cue as to what notational base was used. Is 20, for example, really 20, or an octal representation of 16? When we print numbers in decimal mode, the number is printed as we expect. If we need to print octal or hexadecimal values, it is likely that we should also use the <code>showbase</code> manipulator. The <code>showbase</code> manipulator causes the output stream to use the same conventions as used for specifying the base of an integral constant:</p>
<ul><li>A leading 0x indicates hexadecimal.</li><li>A leading 0 indicates octal.</li><li>The absence of either indicates decimal.</li></ul>

<p>Here we’ve revised the previous program to use <code>showbase</code>:</p>

```c++
cout << showbase;    // show the base when printing integral values
cout << "default: " << 20 << " " << 1024 << endl;
cout << "in octal: " << oct  << 20 << " " << 1024 << endl;
cout << "in hex: " << hex  << 20 << " " << 1024 << endl;
cout << "in decimal: " << dec << 20 << " " << 1024 << endl;
cout << noshowbase;  // reset the state of the stream
```

<p>The revised output makes it clear what the underlying value really is:</p>

```
default: 20 1024
in octal: 024 02000
in hex: 0x14 0x400
in decimal: 20 1024
```

<p>The <code>noshowbase</code> manipulator resets <code>cout</code> so that it no longer displays the notational base of integral values.</p>
<p>By default, hexadecimal values are printed in lowercase with a lowercase x. We can display the <code>X</code> and the hex digits <code>a</code>–<code>f</code> as uppercase by applying the <code>uppercase</code> manipulator:</p>

```c++
cout << uppercase << showbase << hex
     << "printed in hexadecimal: " << 20 << " " << 1024
     << nouppercase << noshowbase << dec << endl;
```

<p>This statement generates the following output:</p>

```
printed in hexadecimal: 0X14 0X400
```

<p>We apply the <code>nouppercase, noshowbase</code>, and <code>dec</code> manipulators to return the stream to its original state.</p>
<h5>Controlling the Format of Floating-Point Values</h5>
<p>We can control three aspects of floating-point output:</p>
<ul><li>How many digits of precision are printed</li><li><a id="filepos4773809"></a>Whether the number is printed in hexadecimal, fixed decimal, or scientific notation</li><li>Whether a decimal point is printed for floating-point values that are whole numbers</li></ul>

<p>By default, floating-point values are printed using six digits of precision; the decimal point is omitted if the value has no fractional part; and they are printed in either fixed decimal or scientific notation depending on the value of the number. The library chooses a format that enhances readability of the number. Very large and very small values are printed using scientific notation. Other values are printed in fixed decimal.</p>
<h5>Specifying How Much Precision to Print</h5>
<p>By default, precision controls the total number of digits that are printed. When printed, floating-point values are rounded, not truncated, to the current precision. Thus, if the current precision is four, then <code>3.14159</code> becomes <code>3.142</code>; if the precision is three, then it is printed as <code>3.14</code>.</p>
<p>We can change the precision by calling the <code>precision</code> member of an IO object or by using the <code>setprecision</code> manipulator. The <code>precision</code> member is overloaded (§ <a href="066-6.4._overloaded_functions.html#filepos1597234">6.4</a>, p. <a href="066-6.4._overloaded_functions.html#filepos1597234">230</a>). One version takes an <code>int</code> value and sets the precision to that new value. It returns the <em>previous</em> precision value. The other version takes no arguments and returns the current precision value. The <code>setprecision</code> manipulator takes an argument, which it uses to set the precision.</p>

::: info
<p>The <code>setprecision</code> manipulators and other manipulators that take arguments are defined in the <code>iomanip</code> header.</p>
:::

<p>The following program illustrates the different ways we can control the precision used to print floating-point values:</p>

```c++
// cout.precision reports the current precision value
cout  << "Precision: " << cout.precision()
      << ", Value: "   << sqrt(2.0) << endl;
// cout.precision(12) asks that 12 digits of precision be printed
cout.precision(12);
cout << "Precision: " << cout.precision()
     << ", Value: "   << sqrt(2.0) << endl;
// alternative way to set precision using the setprecision manipulator
cout << setprecision(3);
cout << "Precision: " << cout.precision()
     << ", Value: "   << sqrt(2.0) << endl;
```

<p>When compiled and executed, the program generates the following output:</p>

```
Precision: 6, Value: 1.41421
Precision: 12, Value: 1.41421356237
Precision: 3, Value: 1.41
```

<p><a id="filepos4779185"></a><a id="filepos4779193"></a>Table 17.17. Manipulators Defined in <code>iostream</code></p>
<img alt="Image" src="/images/00127.jpg"/>
<p>This program calls the library <code>sqrt</code> function, which is found in the <code>cmath</code> header. The <code>sqrt</code> function is overloaded and can be called on either a <code>float</code>, <code>double</code>, or <code>long double</code> argument. It returns the square root of its argument.</p>
<h5>Specifying the Notation of Floating-Point Numbers</h5>

::: tip
<p>Best Practices</p>
<p>Unless you need to control the presentation of a floating-point number (e.g., to print data in columns or to print data that represents money or a percentage), it is usually best to let the library choose the notation.</p>
:::

<p>We can force a stream to use scientific, fixed, or hexadecimal notation by using the appropriate manipulator. The <code>scientific</code> manipulator changes the stream to use scientific notation. The <code>fixed</code> manipulator changes the stream to use fixed decimal.</p>
<a id="filepos4781287"></a><img alt="Image" src="/images/00008.jpg"/>
<p>Under the new library, we can also force floating-point values to use hexadecimal format by using <code>hexfloat</code>. The new library provides another manipulator, named <code>defaultfloat</code>. This manipulator returns the stream to its default state in <a id="filepos4781735"></a>which it chooses a notation based on the value being printed.</p>
<p>These manipulators also change the default meaning of the precision for the stream. After executing <code>scientific, fixed</code>, or <code>hexfloat</code>, the precision value controls the number of digits after the decimal point. By default, precision specifies the total number of digits—both before and after the decimal point. Using <code>fixed</code> or <code>scientific</code> lets us print numbers lined up in columns, with the decimal point in a fixed position relative to the fractional part being printed:</p>

```c++
cout << "default format: " << 100 * sqrt(2.0) << '\n'
     << "scientific: " << scientific << 100 * sqrt(2.0) << '\n'
     << "fixed decimal: " << fixed << 100 * sqrt(2.0) << '\n'
     << "hexadecimal: " << hexfloat << 100 * sqrt(2.0) << '\n'
     << "use defaults: " << defaultfloat << 100 * sqrt(2.0)
     << "\n\n";
```

<p>produces the following output:</p>

```
default format: 141.421
scientific: 1.414214e+002
fixed decimal: 141.421356
hexadecimal: 0x1.1ad7bcp+7
use defaults: 141.421
```

<p>By default, the hexadecimal digits and the <code>e</code> used in scientific notation are printed in lowercase. We can use the <code>uppercase</code> manipulator to show those values in uppercase.</p>
<h5>Printing the Decimal Point</h5>
<p>By default, when the fractional part of a floating-point value is 0, the decimal point is not displayed. The <code>showpoint</code> manipulator forces the decimal point to be printed:</p>

```c++
cout << 10.0 << endl;         // prints 10
cout << showpoint << 10.0     // prints 10.0000
     << noshowpoint << endl;  // revert to default format for the decimal point
```

<p>The <code>noshowpoint</code> manipulator reinstates the default behavior. The next output expression will have the default behavior, which is to suppress the decimal point if the floating-point value has a 0 fractional part.</p>
<h5>Padding the Output</h5>
<p>When we print data in columns, we often need fairly fine control over how the data are formatted. The library provides several manipulators to help us accomplish the control we might need:</p>
<ul><li><code>setw</code> to specify the minimum space for the <em>next</em> numeric or string value.</li><li><code>left</code> to left-justify the output.</li><li><code>right</code> to right-justify the output. Output is right-justified by default.</li><li><a id="filepos4787258"></a><code>internal</code> controls placement of the sign on negative values. <code>internal</code> left-justifies the sign and right-justifies the value, padding any intervening space with blanks.</li><li><code>setfill</code> lets us specify an alternative character to use to pad the output. By default, the value is a space.</li></ul>

::: info
<p><code>setw</code>, like <code>endl</code>, does not change the internal state of the output stream. It determines the size of only the <em>next</em> output.</p>
:::

<p>The following program illustrates these manipulators:</p>

```c++
int i = -16;
double d = 3.14159;
// pad the first column to use a minimum of 12 positions in the output
cout << "i: " << setw(12) << i << "next col" << '\n'
     << "d: " << setw(12) << d << "next col" << '\n';
// pad the first column and left-justify all columns
cout << left
     << "i: " << setw(12) << i << "next col" << '\n'
     << "d: " << setw(12) << d << "next col" << '\n'
     << right;                // restore normal justification
// pad the first column and right-justify all columns
cout << right
     << "i: " << setw(12) << i << "next col" << '\n'
     << "d: " << setw(12) << d << "next col" << '\n';
// pad the first column but put the padding internal to the field
cout << internal
     << "i: " << setw(12) << i << "next col" << '\n'
     << "d: " << setw(12) << d << "next col" << '\n';
// pad the first column, using # as the pad character
cout << setfill('#')
     << "i: " << setw(12) << i << "next col" << '\n'
     << "d: " << setw(12) << d << "next col" << '\n'
     << setfill(' ');   // restore the normal pad character
```

<p>When executed, this program generates</p>

```
i:          -16next col
d:      3.14159next col
i: -16         next col
d: 3.14159     next col
i:          -16next col
d:      3.14159next col
i: -         16next col
d:      3.14159next col
i: -#########16next col
d: #####3.14159next col
```

<p><a id="filepos4792673"></a><a id="filepos4792681"></a>Table 17.18. Manipulators Defined in <code>iomanip</code></p>
<img alt="Image" src="/images/00128.jpg"/>
<h5>Controlling Input Formatting</h5>
<p>By default, the input operators ignore whitespace (blank, tab, newline, formfeed, and carriage return). The following loop</p>

```c++
char ch;
while (cin >> ch)
    cout << ch;
```

<p>given the input sequence</p>

```
a b    c
d
```

<p>executes four times to read the characters <code>a</code> through <code>d</code>, skipping the intervening blanks, possible tabs, and newline characters. The output from this program is</p>

```
abcd
```

<p>The <code>noskipws</code> manipulator causes the input operator to read, rather than skip, whitespace. To return to the default behavior, we apply the <code>skipws</code> manipulator:</p>

```c++
cin >> noskipws;  // set cin so that it reads whitespace
while (cin >> ch)
    cout << ch;
cin >> skipws;    // reset cin to the default state so that it discards whitespace
```

<p>Given the same input as before, this loop makes seven iterations, reading whitespace as well as the characters in the input. This loop generates</p>

```
a b    c
d
```

::: info
<p>Exercises Section 17.5.1</p>
<p><strong>Exercise 17.34:</strong> Write a program that illustrates the use of each manipulator in <a href="167-17.5._the_io_library_revisited.html#filepos4779193">Tables 17.17</a> (p. <a href="167-17.5._the_io_library_revisited.html#filepos4779193">757</a>) and <a href="167-17.5._the_io_library_revisited.html#filepos4792681">17.18</a>.</p>
<p><strong>Exercise 17.35:</strong> Write a version of the program from page <a href="167-17.5._the_io_library_revisited.html#filepos4781735">758</a>, that printed the square root of 2 but this time print hexadecimal digits in uppercase.</p>
<p><strong>Exercise 17.36:</strong> Modify the program from the previous exercise to print the various floating-point values so that they line up in a column.</p>
:::

<h4 id="filepos4797269"><a id="filepos4797302"></a>17.5.2. Unformatted Input/Output Operations</h4>
<p>So far, our programs have used only <strong><a href="169-defined_terms.html#filepos4844292" id="filepos4797466">formatted IO</a></strong> operations. The input and output operators <code>(&lt;&lt;</code> and <code>&gt;&gt;)</code> format the data they read or write according to the type being handled. The input operators ignore whitespace; the output operators apply padding, precision, and so on.</p>
<p>The library also provides a set of low-level operations that support <strong><a href="169-defined_terms.html#filepos4852263" id="filepos4798035">unformatted IO</a></strong>. These operations let us deal with a stream as a sequence of uninterpreted bytes.</p>
<h5>Single-Byte Operations</h5>
<p>Several of the unformatted operations deal with a stream one byte at a time. These operations, which are described in <a href="167-17.5._the_io_library_revisited.html#filepos4799358">Table 17.19</a>, read rather than ignore whitespace. For example, we can use the unformatted IO operations <code>get</code> and <code>put</code> to read and write the characters one at a time:</p>

```c++
char ch;
while (cin.get(ch))
        cout.put(ch);
```

<p>This program preserves the whitespace in the input. Its output is identical to the input. It executes the same way as the previous program that used <code>noskipws</code>.</p>
<p><a id="filepos4799358"></a>Table 17.19. Single-Byte Low-Level IO Operations</p>
<img alt="Image" src="/images/00129.jpg"/>
<h5>Putting Back onto an Input Stream</h5>
<p>Sometimes we need to read a character in order to know that we aren’t ready for it. In such cases, we’d like to put the character back onto the stream. The library gives us three ways to do so, each of which has subtle differences from the others:</p>
<ul><li><code>peek</code> returns a copy of the next character on the input stream but does not change the stream. The value returned by <code>peek</code> stays on the stream.</li><li><code>unget</code> backs up the input stream so that whatever value was last returned is still on the stream. We can call <code>unget</code> even if we do not know what value was last taken from the stream.</li><li><code>putback</code> is a more specialized version of <code>unget:</code> It returns the last value read from the stream but takes an argument that must be the same as the one that was last read.</li></ul>

<p><a id="filepos4801153"></a>In general, we are guaranteed to be able to put back at most one value before the next read. That is, we are not guaranteed to be able to call <code>putback</code> or <code>unget</code> successively without an intervening read operation.</p>
<h5><code>int</code> Return Values from Input Operations</h5>
<p>The <code>peek</code> function and the version of <code>get</code> that takes no argument return a character from the input stream as an <code>int</code>. This fact can be surprising; it might seem more natural to have these functions return a <code>char</code>.</p>
<p>The reason that these functions return an <code>int</code> is to allow them to return an end-of-file marker. A given character set is allowed to use every value in the <code>char</code> range to represent an actual character. Thus, there is no extra value in that range to use to represent end-of-file.</p>
<p>The functions that return <code>int</code> convert the character they return to <code>unsigned char</code> and then promote that value to <code>int</code>. As a result, even if the character set has characters that map to negative values, the <code>int</code> returned from these operations will be a positive value (§ <a href="021-2.1._primitive_builtin_types.html#filepos304094">2.1.2</a>, p. <a href="021-2.1._primitive_builtin_types.html#filepos304094">35</a>). The library uses a negative value to represent end-of-file, which is thus guaranteed to be distinct from any legitimate character value. Rather than requiring us to know the actual value returned, the <code>iostream</code> header defines a <code>const</code> named <code>EOF</code> that we can use to test if the value returned from <code>get</code> is end-of-file. It is essential that we use an <code>int</code> to hold the return from these functions:</p>

```c++
int ch;    // use an int, not a char to hold the return from get()
// loop to read and write all the data in the input
while ((ch = cin.get()) != EOF)
         cout.put(ch);
```

<p>This program operates identically to the one on page <a href="167-17.5._the_io_library_revisited.html#filepos4797302">761</a>, the only difference being the version of <code>get</code> that is used to read the input.</p>
<h5>Multi-Byte Operations</h5>
<p>Some unformatted IO operations deal with chunks of data at a time. These operations can be important if speed is an issue, but like other low-level operations, they are error-prone. In particular, these operations require us to allocate and manage the character arrays (§ <a href="115-12.2._dynamic_arrays.html#filepos3086710">12.2</a>, p. <a href="115-12.2._dynamic_arrays.html#filepos3086710">476</a>) used to store and retrieve data. The multi-byte operations are listed in <a href="167-17.5._the_io_library_revisited.html#filepos4806114">Table 17.20</a>.</p>
<p><a id="filepos4806114"></a>Table 17.20. Multi-Byte Low-Level IO Operations</p>
<img alt="Image" src="/images/00130.jpg"/>
<p>The <code>get</code> and <code>getline</code> functions take the same parameters, and their actions are similar but not identical. In each case, <code>sink</code> is a <code>char</code> array into which the data are placed. The functions read until one of the following conditions occurs:</p>
<ul><li><code>size - 1</code> characters are read</li><li>End-of-file is encountered</li><li>The delimiter character is encountered</li></ul>

<p>The difference between these functions is the treatment of the delimiter: <code>get</code> leaves the delimiter as the next character of the <code>istream</code>, whereas <code>getline</code> reads and discards the delimiter. In either case, the delimiter is <em>not</em> stored in <code>sink</code>.</p>

::: warning
<a id="filepos4807913"></a><p>Warning</p>
<p>It is a common error to intend to remove the delimiter from the stream but to forget to do so.</p>
:::

<h5>Determining How Many Characters Were Read</h5>
<p>Several of the read operations read an unknown number of bytes from the input. We can call <code>gcount</code> to determine how many characters the last unformatted input operation read. It is essential to call <code>gcount</code> before any intervening unformatted input operation. In particular, the single-character operations that put characters back on the stream are also unformatted input operations. If <code>peek, unget</code>, or <code>putback</code> are called before calling <code>gcount</code>, then the return value will be 0.</p>
<h4 id="filepos4809250">17.5.3. Random Access to a Stream</h4>
<p>The various stream types generally support random access to the data in their associated stream. We can reposition the stream so that it skips around, reading first the last line, then the first, and so on. The library provides a pair of functions to <em>seek</em> to a given location and to <em>tell</em> the current location in the associated stream.</p>

::: info
<p>Random IO is an inherently system-dependent. To understand how to use these features, you must consult your system’s documentation.</p>
:::

<p>Although these seek and tell functions are defined for all the stream types, whether they do anything useful depends on the device to which the stream is bound. On most systems, the streams bound to <code>cin</code>, <code>cout</code>, <code>cerr</code>, and <code>clog</code> do <a id="filepos4810750"></a><em>not</em> support random access—after all, what would it mean to jump back ten places when we’re writing directly to <code>cout</code>? We can call the seek and tell functions, but these functions will fail at run time, leaving the stream in an invalid state.</p>

::: info
<p>Caution: Low-Level Routines Are Error-Prone</p>
<p>In general, we advocate using the higher-level abstractions provided by the library. The IO operations that return <code>int</code> are a good example of why.</p>
<p>It is a common programming error to assign the return, from <code>get</code> or <code>peek</code> to a <code>char</code> rather than an <code>int</code>. Doing so is an error, but an error the compiler will not detect. Instead, what happens depends on the machine and on the input data. For example, on a machine in which <code>char</code>s are implemented as <code>unsigned char</code>s, this loop will run forever:</p>

```c++
char ch;   // using a char here invites disaster!
// the return from cin.get is converted to char and then compared to an int
while ((ch = cin.get()) != EOF)
         cout.put(ch);
```

<p>The problem is that when <code>get</code> returns <code>EOF</code>, that value will be converted to an <code>unsigned char</code> value. That converted value is no longer equal to the <code>int</code> value of <code>EOF</code>, and the loop will continue forever. Such errors are likely to be caught in testing.</p>
<p>On machines for which <code>char</code>s are implemented as <code>signed char</code>s, we can’t say with confidence what the behavior of the loop might be. What happens when an out-of-bounds value is assigned to a <code>signed</code> value is up to the compiler. On many machines, this loop will appear to work, unless a character in the input matches the EOF value. Although such characters are unlikely in ordinary data, presumably low-level IO is necessary only when we read binary values that do not map directly to ordinary characters and numeric values. For example, on our machine, if the input contains a character whose value is <code>'\377'</code>, then the loop terminates prematurely. <code>'\377'</code> is the value on our machine to which −1 converts when used as a <code>signed char</code>. If the input has this value, then it will be treated as the (premature) end-of-file indicator.</p>
<p>Such bugs do not happen when we read and write typed values. If you can use the more type-safe, higher-level operations supported by the library, do so.</p>
:::

::: info
<p>Exercises Section 17.5.2</p>
<p><strong>Exercise 17.37:</strong> Use the unformatted version of <code>getline</code> to read a file a line at a time. Test your program by giving it a file that contains empty lines as well as lines that are longer than the character array that you pass to <code>getline</code>.</p>
<p><strong>Exercise 17.38:</strong> Extend your program from the previous exercise to print each word you read onto its own line.</p>
:::

::: warning
<p>Because the <code>istream</code> and <code>ostream</code> types usually do not support random access, the remainder of this section should be considered as applicable to only the <code>fstream</code> and <code>sstream</code> types.</p>
:::

<h5><a id="filepos4817560"></a>Seek and Tell Functions</h5>
<p>To support random access, the IO types maintain a marker that determines where the next read or write will happen. They also provide two functions: One repositions the marker by <em>seek</em>ing to a given position; the second <em>tell</em>s us the current position of the marker. The library actually defines two pairs of <em>seek</em> and <em>tell</em> functions, which are described in <a href="167-17.5._the_io_library_revisited.html#filepos4818715">Table 17.21</a>. One pair is used by input streams, the other by output streams. The input and output versions are distinguished by a suffix that is either a <code>g</code> or a <code>p</code>. The <code>g</code> versions indicate that we are “getting” (reading) data, and the <code>p</code> functions indicate that we are “putting” (writing) data.</p>
<p><a id="filepos4818715"></a>Table 17.21. Seek and Tell Functions</p>
<img alt="Image" src="/images/00131.jpg"/>
<p>Logically enough, we can use only the <code>g</code> versions on an <code>istream</code> and on the types <code>ifstream</code> and <code>istringstream</code> that inherit from <code>istream</code> (§ <a href="083-8.1._the_io_classes.html#filepos2076693">8.1</a>, p. <a href="083-8.1._the_io_classes.html#filepos2076693">311</a>). We can use only the <code>p</code> versions on an <code>ostream</code> and on the types that inherit from it, <code>ofstream</code> and <code>ostringstream</code>. An <code>iostream, fstream</code>, or <code>stringstream</code> can both read and write the associated stream; we can use either the <code>g</code> or <code>p</code> versions on objects of these types.</p>
<h5>There Is Only One Marker</h5>
<p>The fact that the library distinguishes between the “putting” and “getting” versions of the seek and tell functions can be misleading. Even though the library makes this distinction, it maintains only a single marker in a stream—there is <em>not</em> a distinct read marker and write marker.</p>
<p>When we’re dealing with an input-only or output-only stream, the distinction isn’t even apparent. We can use only the <code>g</code> or only the <code>p</code> versions on such streams. If we attempt to call <code>tellp</code> on an <code>ifstream</code>, the compiler will complain. Similarly, it will not let us call <code>seekg</code> on an <code>ostringstream</code>.</p>
<p>The <code>fstream</code> and <code>stringstream</code> types can read and write the same stream. In these types there is a single buffer that holds data to be read and written and a single marker denoting the current position in the buffer. The library maps both the <code>g</code> and <code>p</code> positions to this single marker.</p>

::: info
<a id="filepos4822110"></a>
<p>Because there is only a single marker, we <em>must</em> do a <code>seek</code> to reposition the marker whenever we switch between reading and writing.</p>
:::

<h5>Repositioning the Marker</h5>
<p>There are two versions of the seek functions: One moves to an “absolute” address within the file; the other moves to a byte offset from a given position:</p>

```c++
// set the marker to a fixed position
seekg(new_position);   // set the read marker to the given pos_type location
seekp(new_position);   // set the write marker to the given pos_type location

// offset some distance ahead of or behind the given starting point
seekg(offset, from);    // set the read marker offset distance from from
seekp(offset, from);    // offset has type off_type
```

<p>The possible values for <code>from</code> are listed in <a href="167-17.5._the_io_library_revisited.html#filepos4818715">Table 17.21</a> (on the previous page).</p>
<p>The arguments, <code>new_position</code> and <code>offset</code>, have machine-dependent types named <code>pos_type</code> and <code>off_type</code>, respectively. These types are defined in both <code>istream</code> and <code>ostream</code>. <code>pos_type</code> represents a file position and <code>off_type</code> represents an offset from that position. A value of type <code>off_type</code> can be positive or negative; we can <code>seek</code> forward or backward in the file.</p>
<h5>Accessing the Marker</h5>
<p>The <code>tellg</code> or <code>tellp</code> functions return a <code>pos_type</code> value denoting the current position of the stream. The tell functions are usually used to remember a location so that we can subsequently seek back to it:</p>

```c++
// remember the current write position in mark
ostringstream writeStr;  // output stringstream
ostringstream::pos_type mark = writeStr.tellp();
// ...
if (cancelEntry)
     // return to the remembered position
     writeStr.seekp(mark);
```

<h5>Reading and Writing to the Same File</h5>
<p>Let’s look at a programming example. Assume we are given a file to read. We are to write a newline at the end of the file that contains the relative position at which each line begins. For example, given the following file,</p>

```
abcd
efg
hi
j
```

<p>the program should produce the following modified file:</p>

```
abcd
efg
hi
j
5 9 12 14
```

<p>Note that our program need not write the offset for the first line—it always occurs at position 0. Also note that the offset counts must include the invisible newline character that ends each line. Finally, note that the last number in the output is the offset for the line on which our output begins. By including this offset in our output, we can distinguish our output from the file’s original contents. We can read the last number in the resulting file and seek to the corresponding offset to get to the beginning of our output.</p>
<p>Our program will read the file a line at a time. For each line, we’ll increment a counter, adding the size of the line we just read. That counter is the offset at which the next line starts:</p>

```c++
int main()
{
    // open for input and output and preposition file pointers to end-of-file
    // file mode argument see § 8.4 (p. 319)
    fstream inOut("copyOut",
                   fstream::ate | fstream::in | fstream::out);
    if (!inOut) {
        cerr << "Unable to open file!" << endl;
        return EXIT_FAILURE; // EXIT_FAILURE see § 6.3.2 (p. 227)
    }
    // inOut is opened in ate mode, so it starts out positioned at the end
    auto end_mark = inOut.tellg();// remember original end-of-file position
    inOut.seekg(0, fstream::beg); // reposition to the start of the file
    size_t cnt = 0;               // accumulator for the byte count
    string line;                  // hold each line of input
    // while we haven't hit an error and are still reading the original data
    while (inOut && inOut.tellg() != end_mark
           && getline(inOut, line)) { // and can get another line of input
        cnt += line.size() + 1;       // add 1 to account for the newline
        auto mark = inOut.tellg();    // remember the read position
        inOut.seekp(0, fstream::end); // set the write marker to the end
        inOut << cnt;                 // write the accumulated length
        // print a separator if this is not the last line
        if (mark != end_mark) inOut << " ";
        inOut.seekg(mark);            // restore the read position
    }
    inOut.seekp(0, fstream::end);     // seek to the end
    inOut << "\n";                    // write a newline at end-of-file
    return 0;
}
```

<p>Our program opens its <code>fstream</code> using the <code>in</code>, <code>out</code>, and <code>ate</code> modes (§ 8.4, p. <a href="084-8.2._file_input_and_output.html#filepos2131282">319</a>). The first two modes indicate that we intend to read and write the same file. Specifying <a id="filepos4835048"></a><code>ate</code> positions the read and write markers at the end of the file. As usual, we check that the open succeeded, and exit if it did not (§ <a href="065-6.3._return_types_and_the_return_statement.html#filepos1552941">6.3.2</a>, p. <a href="065-6.3._return_types_and_the_return_statement.html#filepos1552941">227</a>).</p>
<p>Because our program writes to its input file, we can’t use end-of-file to signal when it’s time to stop reading. Instead, our loop must end when it reaches the point at which the original input ended. As a result, we must first remember the original end-of-file position. Because we opened the file in <code>ate</code> mode, <code>inOut</code> is already positioned at the end. We store the current (i.e., the original end) position in <code>end_mark</code>. Having remembered the end position, we reposition the read marker at the beginning of the file by seeking to the position 0 bytes from the beginning of the file.</p>
<p>The <code>while</code> loop has a three-part condition: We first check that the stream is valid; if so, we check whether we’ve exhausted our original input by comparing the current read position (returned by <code>tellg</code>) with the position we remembered in <code>end_mark</code>. Finally, assuming that both tests succeeded, we call <code>getline</code> to read the next line of input. If <code>getline</code> succeeds, we perform the body of the loop.</p>
<p>The loop body starts by remembering the current position in <code>mark</code>. We save that position in order to return to it after writing the next relative offset. The call to <code>seekp</code> repositions the write marker to the end of the file. We write the counter value and then <code>seekg</code> back to the position we remembered in <code>mark</code>. Having restored the marker, we’re ready to repeat the condition in the <code>while</code>.</p>
<p>Each iteration of the loop writes the offset of the next line. Therefore, the last iteration of the loop takes care of writing the offset of the last line. However, we still need to write a newline at the end of the file. As with the other writes, we call <code>seekp</code> to position the file at the end before writing the newline.</p>

::: info
<p>Exercises Section 17.5.3</p>
<p><strong>Exercise 17.39:</strong> Write your own version of the <code>seek</code> program presented in this section.</p>
:::

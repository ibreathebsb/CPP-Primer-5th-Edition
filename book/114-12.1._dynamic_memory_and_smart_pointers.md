<h3 id="filepos2904799">12.1. Dynamic Memory and Smart Pointers</h3>
<p>In C++, dynamic memory is managed through a pair of operators: <code>new</code>, which allocates, and optionally initializes, an object in dynamic memory and returns a pointer to that object; and <code>delete</code>, which takes a pointer to a dynamic object, destroys that object, and frees the associated memory.</p>
<p>Dynamic memory is problematic because it is surprisingly hard to ensure that we free memory at the right time. Either we forget to free the memory—in which case we have a memory leak—or we free the memory when there are still pointers referring to that memory—in which case we have a pointer that refers to memory that is no longer valid.</p><a id="filepos2906041"></a><Badge type="tip" text="C++11" />
<p>To make using dynamic memory easier (and safer), the new library provides two <strong><a href="118-defined_terms.html#filepos3191364" id="filepos2906215">smart pointer</a></strong> types that manage dynamic objects. A smart pointer acts like a regular pointer with the important exception that it automatically deletes the object to which it points. The new library defines two kinds of smart pointers that differ in how they manage their underlying pointers: <code>shared_ptr</code>, which allows multiple pointers to refer to the same object, and <code>unique_ptr</code>, which “owns” the object to which it points. The library also defines a companion class named <code>weak_ptr</code> that is a weak reference to an object managed by a <code>shared_ptr</code>. All three are defined in the <code>memory</code> header.</p>
<h4 id="filepos2907541">12.1.1. The <code>shared_ptr</code> Class</h4>
<a id="filepos2907781"></a><Badge type="info" text="Fundamental" />
<p>Like <code>vector</code>s, smart pointers are templates (§ <a href="032-3.3._library_vector_type.html#filepos736471">3.3</a>, p. <a href="032-3.3._library_vector_type.html#filepos736471">96</a>). Therefore, when we create a smart pointer, we must supply additional information—in this case, the type to which the pointer can point. As with <code>vector</code>, we supply that type inside angle brackets that follow the name of the kind of smart pointer we are defining:</p>

```c++
shared_ptr<string> p1;    // shared_ptr that can point at a string
shared_ptr<list<int>> p2; // shared_ptr that can point at a list of ints
```

<p><a id="filepos2909505"></a>A default initialized smart pointer holds a null pointer (§ <a href="023-2.3._compound_types.html#filepos409391">2.3.2</a>, p. <a href="023-2.3._compound_types.html#filepos409391">53</a>). In § <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos2999606">12.1.3</a> (p. <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos2999606">464</a>), we’ll cover additional ways to initialize a smart pointer.</p>
<p>We use a smart pointer in ways that are similar to using a pointer. Dereferencing a smart pointer returns the object to which the pointer points. When we use a smart pointer in a condition, the effect is to test whether the pointer is null:</p>

```c++
// if p1 is not null, check whether it's the empty string
if (p1 && p1->empty())
    *p1 = "hi";  // if so, dereference p1 to assign a new value to that string
```

<p><a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos2911678">Table 12.1</a> (overleaf) lists operations common to <code>shared_ptr</code> and <code>unique_ptr</code>. Those that are particular to <code>shared_ptr</code> are listed in <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos2912161">Table 12.2</a> (p. <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos2912161">453</a>).</p>
<p><a id="filepos2911678"></a>Table 12.1. Operations Common to <code>shared_ptr</code> and <code>unique_ptr</code></p>

| Code                                  | Description                                                                                                                                     |
|---------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------|
| `shared_ptr<T> sp` `unique_ptr<T> up` | Null smart pointer that can point to objects of type `T`.                                                                                       |
| `p`                                   | Use `p` as a condition; `true` if `p` points to an object.                                                                                      |
| `*p`                                  | Dereference `p` to get the object to which `p` points.                                                                                          |
| `p->mem`                              | Synonym for `(*p).mem`.                                                                                                                         |
| `p.get()`                             | Returns the pointer in `p`. Use with caution; the object to which the returned pointer points will disappear when the smart pointer deletes it. |
| `swap(p, q)` `p.swap(q)`              | Swaps the pointers in `p` and `q`.                                                                                                              |

<p><a id="filepos2912161"></a>Table 12.2. Operations Specific to <code>shared_ptr</code></p>

| Code                   | Description                                                                                                                                                                                               |
|------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `make_shared<T>(args)` | Returns a `shared_ptr` pointing to a dynamically allocated object of type `T`. Uses `args` to initialize that object.                                                                                     |
| `shared_ptr<T> p(q)`   | `p` is a copy of the `shared_ptr q`; increments the count in `q`. The pointer in `q` must be convertible to `T*` (§ 4.11.2, p. 161).                                                                      |
| `p = q`                | `p` and `q` are `shared_ptrs` holding pointers that can be converted to one another. Decrements `p`'s reference count and increments `q`'s count; deletes `p`'s existing memory if `p`'s count goes to 0. |
| `p.unique()`           | Returns `true` if `p.use_count()` is one; `false` otherwise.                                                                                                                                              |
| `p.use_count()`        | Returns the number of objects sharing with `p`; may be a slow operation, intended primarily for debugging purposes.                                                                                       |

<h5>The <code>make_shared</code> Function</h5>
<p>The safest way to allocate and use dynamic memory is to call a library function named <code>make_shared</code>. This function allocates and initializes an object in dynamic memory and returns a <code>shared_ptr</code> that points to that object. Like the smart pointers, <code>make_shared</code> is defined in the <code>memory</code> header.</p>
<p>When we call <code>make_shared</code>, we must specify the type of object we want to create. We do so in the same way as we use a template class, by following the function name with a type enclosed in angle brackets:</p>

```c++
// shared_ptr that points to an int with value 42
shared_ptr<int> p3 = make_shared<int>(42);
// p4 points to a string with value 9999999999
shared_ptr<string> p4 = make_shared<string>(10, '9');
// p5 points to an int that is value initialized (§ 3.3.1 (p. 98)) to 0
shared_ptr<int> p5 = make_shared<int>();
```

<p>Like the sequential-container <code>emplace</code> members (§ <a href="091-9.3._sequential_container_operations.html#filepos2264356">9.3.1</a>, p. <a href="091-9.3._sequential_container_operations.html#filepos2264356">345</a>), <code>make_shared</code> uses its arguments to construct an object of the given type. For example, a call to <code>make_shared&lt;string&gt;</code> must pass argument(s) that match one of the <code>string</code> constructors. Calls to <code>make_shared&lt;int&gt;</code> can pass any value we can use to initialize an <code>int</code>. And so on. If we do not pass any arguments, then the object is value initialized (§ <a href="032-3.3._library_vector_type.html#filepos744172">3.3.1</a>, p. <a href="032-3.3._library_vector_type.html#filepos744172">98</a>).</p>
<p>Of course, ordinarily we use <code>auto</code> (§ <a href="025-2.5._dealing_with_types.html#filepos544751">2.5.2</a>, p. <a href="025-2.5._dealing_with_types.html#filepos544751">68</a>) to make it easier to define an object to hold the result of <code>make_shared</code>:</p>

```c++
// p6 points to a dynamically allocated, empty vector<string>
auto p6 = make_shared<vector<string>>();
```

<h5>Copying and Assigning <code>shared_ptr</code>s</h5>
<p>When we copy or assign a <code>shared_ptr</code>, each <code>shared_ptr</code> keeps track of how many other <code>shared_ptr</code>s point to the same object:</p>

```c++
auto p = make_shared<int>(42); // object to which p points has one user
auto q(p); // p and q point to the same object
           // object to which p and q point has two users
```

<p><a id="filepos2919193"></a>We can think of a <code>shared_ptr</code> as if it has an associated counter, usually referred to as a <strong><a href="118-defined_terms.html#filepos3190670" id="filepos2919362">reference count</a></strong>. Whenever we copy a <code>shared_ptr</code>, the count is incremented. For example, the counter associated with a <code>shared_ptr</code> is incremented when we use it to initialize another <code>shared_ptr</code>, when we use it as the right-hand operand of an assignment, or when we pass it to (§ <a href="064-6.2._argument_passing.html#filepos1453096">6.2.1</a>, p. <a href="064-6.2._argument_passing.html#filepos1453096">209</a>) or return it from a function by value (§ <a href="065-6.3._return_types_and_the_return_statement.html#filepos1552941">6.3.2</a>, p. <a href="065-6.3._return_types_and_the_return_statement.html#filepos1552941">224</a>). The counter is decremented when we assign a new value to the <code>shared_ptr</code> and when the <code>shared_ptr</code> itself is destroyed, such as when a local <code>shared_ptr</code> goes out of scope (§ <a href="063-6.1._function_basics.html#filepos1431793">6.1.1</a>, p. <a href="063-6.1._function_basics.html#filepos1431793">204</a>).</p>
<p>Once a <code>shared_ptr</code>’s counter goes to zero, the <code>shared_ptr</code> automatically frees the object that it manages:</p>

```c++
auto r = make_shared<int>(42); // int to which r points has one user
r = q;  // assign to r, making it point to a different address
        // increase the use count for the object to which q points
        // reduce the use count of the object to which r had pointed
        // the object r had pointed to has no users; that object is automatically freed
```

<p>Here we allocate an <code>int</code> and store a pointer to that <code>int</code> in <code>r</code>. Next, we assign a new value to <code>r</code>. In this case, <code>r</code> is the only <code>shared_ptr</code> pointing to the one we previously allocated. That <code>int</code> is automatically freed as part of assigning <code>q</code> to <code>r</code>.</p>

::: info
<p>It is up to the implementation whether to use a counter or another data structure to keep track of how many pointers share state. The key point is that the class keeps track of how many <code>shared_ptr</code>s point to the same object and automatically frees that object when appropriate.</p>
:::

<h5><code>shared_ptr</code>s Automatically Destroy Their Objects ...</h5>
<p>When the last <code>shared_ptr</code> pointing to an object is destroyed, the <code>shared_ptr</code> class automatically destroys the object to which that <code>shared_ptr</code> points. It does so through another special member function known as a <strong><a href="118-defined_terms.html#filepos3188004" id="filepos2924901">destructor</a></strong>. Analogous to its constructors, each class has a destructor. Just as a constructor controls initialization, the destructor controls what happens when objects of that class type are destroyed.</p>
<p><a id="filepos2925221"></a>Destructors generally free the resources that an object has allocated. For example, the <code>string</code> constructors (and other <code>string</code> members) allocate memory to hold the characters that compose the <code>string</code>. The <code>string</code> destructor frees that memory. Similarly, several <code>vector</code> operations allocate memory to hold the elements in the <code>vector</code>. The destructor for <code>vector</code> destroys those elements and frees the memory used for the elements.</p>
<p>The destructor for <code>shared_ptr</code> decrements the reference count of the object to which that <code>shared_ptr</code> points. If the count goes to zero, the <code>shared_ptr</code> destructor destroys the object to which the <code>shared_ptr</code> points and frees the memory used by that object.</p>
<h5>...and Automatically Free the Associated Memory</h5>
<p>The fact that the <code>shared_ptr</code> class automatically frees dynamic objects when they are no longer needed makes it fairly easy to use dynamic memory. For example, we might have a function that returns a <code>shared_ptr</code> to a dynamically allocated object of a type named <code>Foo</code> that can be initialized by an argument of type <code>T</code>:</p>

```c++
// factory returns a shared_ptr pointing to a dynamically allocated object
shared_ptr<Foo> factory(T arg)
{
    // process arg as appropriate
    // shared_ptr will take care of deleting this memory
    return make_shared<Foo>(arg);
}
```

<p>Because <code>factory</code> returns a <code>shared_ptr</code>, we can be sure that the object allocated by <code>factory</code> will be freed when appropriate. For example, the following function stores the <code>shared_ptr</code> returned by <code>factory</code> in a local variable:</p>

```c++
void use_factory(T arg)
{
    shared_ptr<Foo> p = factory(arg);
    // use p
} // p goes out of scope; the memory to which p points is automatically freed
```

<p>Because <code>p</code> is local to <code>use_factory</code>, it is destroyed when <code>use_factory</code> ends (§ <a href="063-6.1._function_basics.html#filepos1431793">6.1.1</a>, p. <a href="063-6.1._function_basics.html#filepos1431793">204</a>). When <code>p</code> is destroyed, its reference count is decremented and checked. In this case, <code>p</code> is the only object referring to the memory returned by <code>factory</code>. Because <code>p</code> is about to go away, the object to which <code>p</code> points will be destroyed and the memory in which that object resides will be freed.</p>
<p>The memory will not be freed if there is any other <code>shared_ptr</code> pointing to it:</p>

```c++
shared_ptr<Foo> use_factory(T arg)
{
    shared_ptr<Foo> p = factory(arg);
    // use p
    return p;  // reference count is incremented when we return p
} // p goes out of scope; the memory to which p points is not freed
```

<p>In this version, the <code>return</code> statement in <code>use_factory</code> returns a copy of <code>p</code> to its caller (§ <a href="065-6.3._return_types_and_the_return_statement.html#filepos1552941">6.3.2</a>, p. <a href="065-6.3._return_types_and_the_return_statement.html#filepos1552941">224</a>). Copying a <code>shared_ptr</code> adds to the reference count of that object. Now when <code>p</code> is destroyed, there will be another user for the memory to which <code>p</code> points. The <code>shared_ptr</code> class ensures that so long as there are any <code>shared_ptr</code>s attached to that memory, the memory itself will not be freed.</p>
<p>Because memory is not freed until the last <code>shared_ptr</code> goes away, it can be important to be sure that <code>shared_ptr</code>s don’t stay around after they are no longer needed. The program will execute correctly but may waste memory if you neglect to destroy <code>shared_ptr</code>s that the program does not need. One way that <code>shared_ptr</code>s might stay around after you need them is if you put <code>shared_ptr</code>s in a container and subsequently reorder the container so that you don’t need all the elements. You should be sure to <code>erase shared_ptr</code> elements once you no longer need those elements.</p>

::: info
<p>If you put <code>shared_ptr</code>s in a container, and you subsequently need to use some, but not all, of the elements, remember to <code>erase</code> the elements you no longer need.</p>
:::

<h5>Classes with Resources That Have Dynamic Lifetime</h5>
<p>Programs tend to use dynamic memory for one of three purposes:</p>
<ol>
    <li>They don’t know how many objects they’ll need</li>
    <li>They don’t know the precise type of the objects they need</li>
    <li>They want to share data between several objects</li>
</ol>
<p>The container classes are an example of classes that use dynamic memory for the first purpose and we’ll see examples of the second in <a href="141-chapter_15._objectoriented_programming.html#filepos3778984">Chapter 15</a>. In this section, we’ll define a class that uses dynamic memory in order to let several objects share the same underlying data.</p>
<p>So far, the classes we’ve used allocate resources that exist only as long as the corresponding objects. For example, each <code>vector</code> “owns” its own elements. When we copy a <code>vector</code>, the elements in the original <code>vector</code> and in the copy are separate from one another:</p>
<p><a id="filepos2936823"></a></p>

```c++
vector<string> v1; // empty vector
{ // new scope
    vector<string> v2 = {"a", "an", "the"};
    v1 = v2; // copies the elements from v2 into v1
} // v2 is destroyed, which destroys the elements in v2
  // v1 has three elements, which are copies of the ones originally in v2
```

<p>The elements allocated by a <code>vector</code> exist only while the <code>vector</code> itself exists. When a <code>vector</code> is destroyed, the elements in the <code>vector</code> are also destroyed.</p>
<p>Some classes allocate resources with a lifetime that is independent of the original object. As an example, assume we want to define a class named <code>Blob</code> that will hold a collection of elements. Unlike the containers, we want <code>Blob</code> objects that are copies of one another to share the same elements. That is, when we copy a <code>Blob</code>, the original and the copy should refer to the same underlying elements.</p>
<p>In general, when two objects share the same underlying data, we can’t unilaterally destroy the data when an object of that type goes away:</p>

```c++
Blob<string> b1;    // empty Blob
{ // new scope
    Blob<string> b2 = {"a", "an", "the"};
    b1 = b2; // b1 and b2 share the same elements
} // b2 is destroyed, but the elements in b2 must not be destroyed
  // b1 points to the elements originally created in b2
```

<p>In this example, <code>b1</code> and <code>b2</code> share the same elements. When <code>b2</code> goes out of scope, those elements must stay around, because <code>b1</code> is still using them.</p>

::: info
<p>One common reason to use dynamic memory is to allow multiple objects to share the same state.</p>
:::

<h5>Defining the <code>StrBlob</code> Class</h5>
<p>Ultimately, we’ll implement our <code>Blob</code> class as a template, but we won’t learn how to do so until § <a href="154-16.1._defining_a_template.html#filepos4193169">16.1.2</a> (p. <a href="154-16.1._defining_a_template.html#filepos4193169">658</a>). For now, we’ll define a version of our class that can manage <code>string</code>s. As a result, we’ll name this version of our class <code>StrBlob</code>.</p>
<p>The easiest way to implement a new collection type is to use one of the library containers to manage the elements. That way, we can let the library type manage the storage for the elements themselves. In this case, we’ll use a <code>vector</code> to hold our elements.</p>
<p>However, we can’t store the <code>vector</code> directly in a <code>Blob</code> object. Members of an object are destroyed when the object itself is destroyed. For example, assume that <code>b1</code> and <code>b2</code> are two <code>Blob</code>s that share the same <code>vector</code>. If that <code>vector</code> were stored in one of those <code>Blobs</code>—say, <code>b2</code>—then that <code>vector</code>, and therefore its elements, would no longer exist once <code>b2</code> goes out of scope. To ensure that the elements continue to exist, we’ll store the <code>vector</code> in dynamic memory.</p>
<p>To implement the sharing we want, we’ll give each <code>StrBlob</code> a <code>shared_ptr</code> to a dynamically allocated <code>vector</code>. That <code>shared_ptr</code> member will keep track of how many <code>StrBlobs</code> share the same <code>vector</code> and will delete the <code>vector</code> when the last <code>StrBlob</code> using that <code>vector</code> is destroyed.</p>
<p><a id="filepos2945498"></a>We still need to decide what operations our class will provide. For now, we’ll implement a small subset of the <code>vector</code> operations. We’ll also change the operations that access elements (e.g., <code>front</code> and <code>back</code>): In our class, these operations will throw an exception if a user attempts to access an element that doesn’t exist.</p>
<p>Our class will have a default constructor and a constructor that has a parameter of type <code>initializer_list&lt;string&gt;</code> (§ <a href="064-6.2._argument_passing.html#filepos1534679">6.2.6</a>, p. <a href="064-6.2._argument_passing.html#filepos1534679">220</a>). This constructor will take a braced list of initializers.</p>

```c++
class StrBlob {
public:
    typedef std::vector<std::string>::size_type size_type;
    StrBlob();
    StrBlob(std::initializer_list<std::string> il);
    size_type size() const { return data->size(); }
    bool empty() const { return data->empty(); }
    // add and remove elements
    void push_back(const std::string &t) {data->push_back(t);}
    void pop_back();
    // element access
    std::string& front();
    std::string& back();
private:
    std::shared_ptr<std::vector<std::string>> data;
    // throws msg if data[i] isn't valid
    void check(size_type i, const std::string &msg) const;
};
```

<p>Inside the class we implemented the <code>size</code>, <code>empty</code>, and <code>push_back</code> members. These members forward their work through the <code>data</code> pointer to the underlying <code>vector</code>. For example, <code>size()</code> on a <code>StrBlob</code> calls <code>data-&gt;size()</code>, and so on.</p>
<h5><code>StrBlob</code> Constructors</h5>
<p>Each constructor uses its constructor initializer list (§ <a href="073-7.1._defining_abstract_data_types.html#filepos1802479">7.1.4</a>, p. <a href="073-7.1._defining_abstract_data_types.html#filepos1802479">265</a>) to initialize its <code>data</code> member to point to a dynamically allocated <code>vector</code>. The default constructor allocates an empty <code>vector</code>:</p>

```c++
StrBlob::StrBlob(): data(make_shared<vector<string>>()) { }
StrBlob::StrBlob(initializer_list<string> il):
              data(make_shared<vector<string>>(il)) { }
```

<p>The constructor that takes an <code>initializer_list</code> passes its parameter to the corresponding <code>vector</code> constructor (§ <a href="022-2.2._variables.html#filepos350704">2.2.1</a>, p. <a href="022-2.2._variables.html#filepos350704">43</a>). That constructor initializes the <code>vector</code>’s elements by copying the values in the list.</p>
<h5>Element Access Members</h5>
<p>The <code>pop_back</code>, <code>front</code>, and <code>back</code> operations access members in the <code>vector</code>. These operations must check that an element exists before attempting to access that element. Because several members need to do the same checking, we’ve given <a id="filepos2951402"></a>our class a <code>private</code> utility function named <code>check</code> that verifies that a given index is in range. In addition to an index, <code>check</code> takes a <code>string</code> argument that it will pass to the exception handler. The <code>string</code> describes what went wrong:</p>

```c++
void StrBlob::check(size_type i, const string &msg) const
{
    if (i >= data->size())
        throw out_of_range(msg);
}
```

<p>The <code>pop_back</code> and element access members first call <code>check</code>. If <code>check</code> succeeds, these members forward their work to the underlying <code>vector</code> operation:</p>

```c++
string& StrBlob::front()
{
    // if the vector is empty, check will throw
    check(0, "front on empty StrBlob");
    return data->front();
}
string& StrBlob::back()
{
    check(0, "back on empty StrBlob");
    return data->back();
}
void StrBlob::pop_back()
{
    check(0, "pop_back on empty StrBlob");
    data->pop_back();
}
```

<p>The <code>front</code> and <code>back</code> members should be overloaded on <code>const</code> (§ <a href="075-7.3._additional_class_features.html#filepos1876631">7.3.2</a>, p. <a href="075-7.3._additional_class_features.html#filepos1876631">276</a>). Defining those versions is left as an exercise.</p>
<h5>Copying, Assigning, and Destroying <code>StrBlob</code>s</h5>
<p>Like our <code>Sales_data</code> class, <code>StrBlob</code> uses the default versions of the operations that copy, assign, and destroy objects of its type (§ <a href="073-7.1._defining_abstract_data_types.html#filepos1827343">7.1.5</a>, p. <a href="073-7.1._defining_abstract_data_types.html#filepos1827343">267</a>). By default, these operations copy, assign, and destroy the data members of the class. Our <code>StrBlob</code> has only one data member, which is a <code>shared_ptr</code>. Therefore, when we copy, assign, or destroy a <code>StrBlob</code>, its <code>shared_ptr</code> member will be copied, assigned, or destroyed.</p>
<p>As we’ve seen, copying a <code>shared_ptr</code> increments its reference count; assigning one <code>shared_ptr</code> to another increments the count of the right-hand operand and decrements the count in the left-hand operand; and destroying a <code>shared_ptr</code> decrements the count. If the count in a <code>shared_ptr</code> goes to zero, the object to which that <code>shared_ptr</code> points is automatically destroyed. Thus, the <code>vector</code> allocated by the <code>StrBlob</code> constructors will be automatically destroyed when the last <code>StrBlob</code> pointing to that <code>vector</code> is destroyed.</p>

::: info
<a id="filepos2956866"></a><p>Exercises Section 12.1.1</p>
<p><strong>Exercise 12.1:</strong> How many elements do <code>b1</code> and <code>b2</code> have at the end of this code?</p>

```c++
StrBlob b1;
{
    StrBlob b2 = {"a", "an", "the"};
    b1 = b2;
    b2.push_back("about");
}
```

<p><strong>Exercise 12.2:</strong> Write your own version of the <code>StrBlob</code> class including the <code>const</code> versions of <code>front</code> and <code>back</code>.</p>
<p><strong>Exercise 12.3:</strong> Does this class need <code>const</code> versions of <code>push_back</code> and <code>pop_back</code>? If so, add them. If not, why aren’t they needed?</p>
<p><strong>Exercise 12.4:</strong> In our <code>check</code> function we didn’t check whether <code>i</code> was greater than zero. Why is it okay to omit that check?</p>
<p><strong>Exercise 12.5:</strong> We did not make the constructor that takes an <code>initializer_list explicit</code> (§ <a href="077-7.5._constructors_revisited.html#filepos1990205">7.5.4</a>, p. <a href="077-7.5._constructors_revisited.html#filepos1990205">296</a>). Discuss the pros and cons of this design choice.</p>
:::

<h4 id="filepos2959483">12.1.2. Managing Memory Directly</h4>
<p>The language itself defines two operators that allocate and free dynamic memory. The <code>new</code> operator allocates memory, and <code>delete</code> frees memory allocated by <code>new</code>.</p>
<p>For reasons that will become clear as we describe how these operators work, using these operators to manage memory is considerably more error-prone than using a smart pointer. Moreover, classes that do manage their own memory—unlike those that use smart pointers—cannot rely on the default definitions for the members that copy, assign, and destroy class objects (§ <a href="073-7.1._defining_abstract_data_types.html#filepos1802479">7.1.4</a>, p. <a href="073-7.1._defining_abstract_data_types.html#filepos1802479">264</a>). As a result, programs that use smart pointers are likely to be easier to write and debug.</p>

::: warning
<p>Until you have read <a href="120-chapter_13._copy_control.html#filepos3197881">Chapter 13</a>, your classes should allocate dynamic memory <em>only</em> if they use smart pointers to manage that memory.</p>
:::

<h5>Using <code>new</code> to Dynamically Allocate and Initialize Objects</h5>
<p>Objects allocated on the free store are unnamed, so <code>new</code> offers no way to name the objects that it allocates. Instead, <code>new</code> returns a pointer to the object it allocates:</p>

```c++
int *pi = new int;      // pi points to a dynamically allocated,
                        // unnamed, uninitialized int
```

<p>This <code>new</code> expression constructs an object of type <code>int</code> on the free store and returns a pointer to that object.</p>
<p>By default, dynamically allocated objects are default initialized (§ <a href="022-2.2._variables.html#filepos350704">2.2.1</a>, p. <a href="022-2.2._variables.html#filepos350704">43</a>), which means that objects of built-in or compound type have undefined value; objects of class type are initialized by their default constructor:</p>
<p><a id="filepos2963288"></a></p>

```c++
string *ps = new string;  // initialized to empty string
int *pi = new int;        // pi points to an uninitialized int
```

<a id="filepos2964063"></a><Badge type="tip" text="C++11" />
<p>We can initialize a dynamically allocated object using direct initialization (§ <a href="031-3.2._library_string_type.html#filepos651083">3.2.1</a>, p. <a href="031-3.2._library_string_type.html#filepos651083">84</a>). We can use traditional construction (using parentheses), and under the new standard, we can also use list initialization (with curly braces):</p>

```c++
int *pi = new int(1024); // object to which pi points has value 1024
string *ps = new string(10, '9');   // *ps is "9999999999"
// vector with ten elements with values from 0 to 9
vector<int> *pv = new vector<int>{0,1,2,3,4,5,6,7,8,9};
```

<p>We can also value initialize (§ <a href="032-3.3._library_vector_type.html#filepos744172">3.3.1</a>, p. <a href="032-3.3._library_vector_type.html#filepos744172">98</a>) a dynamically allocated object by following the type name with a pair of empty parentheses:</p>

```c++
string *ps1 = new string;  // default initialized to the empty string
string *ps = new string(); // value initialized to the empty string
int *pi1 = new int;        // default initialized; *pi1 is undefined
int *pi2 = new int();      // value initialized to 0; *pi2 is 0
```

<p>For class types (such as <code>string</code>) that define their own constructors (§ <a href="073-7.1._defining_abstract_data_types.html#filepos1802479">7.1.4</a>, p. <a href="073-7.1._defining_abstract_data_types.html#filepos1802479">262</a>), requesting value initialization is of no consequence; regardless of form, the object is initialized by the default constructor. In the case of built-in types the difference is significant; a value-initialized object of built-in type has a well-defined value but a default-initialized object does not. Similarly, members of built-in type in classes that rely on the synthesized default constructor will also be uninitialized if those members are not initialized in the class body (§ <a href="073-7.1._defining_abstract_data_types.html#filepos1802479">7.1.4</a>, p. <a href="073-7.1._defining_abstract_data_types.html#filepos1802479">263</a>).</p>

::: tip
<p>Best Practices</p>
<p>For the same reasons as we usually initialize variables, it is also a good idea to initialize dynamically allocated objects.</p>
:::

<a id="filepos2968774"></a><Badge type="tip" text="C++11" />
<p>When we provide an initializer inside parentheses, we can use <code>auto</code> (§ <a href="025-2.5._dealing_with_types.html#filepos544751">2.5.2</a>, p. <a href="025-2.5._dealing_with_types.html#filepos544751">68</a>) to deduce the type of the object we want to allocate from that initializer. However, because the compiler uses the initializer’s type to deduce the type to allocate, we can use <code>auto</code> only with a single initializer inside parentheses:</p>

```c++
auto p1 = new auto(obj);   // p points to an object of the type of obj
                           // that object is initialized from obj
auto p2 = new auto{a,b,c}; // error: must use parentheses for the initializer
```

<p>The type of <code>p1</code> is a pointer to the <code>auto</code>-deduced type of <code>obj</code>. If <code>obj</code> is an <code>int</code>, then <code>p1</code> is <code>int*;</code> if <code>obj</code> is a <code>string</code>, then <code>p1</code> is a <code>string*;</code> and so on. The newly allocated object is initialized from the value of <code>obj</code>.</p>
<h5>Dynamically Allocated <code>const</code> Objects</h5>
<p>It is legal to use <code>new</code> to allocate <code>const</code> objects:</p>

```c++
// allocate and initialize a const int
const int *pci = new const int(1024);
// allocate a default-initialized const empty string
const string *pcs = new const string;
```

<p><a id="filepos2972849"></a>Like any other <code>const</code>, a dynamically allocated <code>const</code> object must be initialized. A <code>const</code> dynamic object of a class type that defines a default constructor (§ <a href="073-7.1._defining_abstract_data_types.html#filepos1802479">7.1.4</a>, p. <a href="073-7.1._defining_abstract_data_types.html#filepos1802479">263</a>) may be initialized implicitly. Objects of other types must be explicitly initialized. Because the allocated object is <code>const</code>, the pointer returned by <code>new</code> is a pointer to <code>const</code> (§ <a href="024-2.4._const_qualifier.html#filepos491891">2.4.2</a>, p. <a href="024-2.4._const_qualifier.html#filepos491891">62</a>).</p>
<h5>Memory Exhaustion</h5>
<p>Although modern machines tend to have huge memory capacity, it is always possible that the free store will be exhausted. Once a program has used all of its available memory, <code>new</code> expressions will fail. By default, if <code>new</code> is unable to allocate the requested storage, it throws an exception of type <code>bad_alloc</code> (§ <a href="059-5.6._try_blocks_and_exception_handling.html#filepos1368051">5.6</a>, p. <a href="059-5.6._try_blocks_and_exception_handling.html#filepos1368051">193</a>). We can prevent <code>new</code> from throwing an exception by using a different form of <code>new</code>:</p>

```c++
// if allocation fails, new returns a null pointer
int *p1 = new int; // if allocation fails, new throws std::bad_alloc
int *p2 = new (nothrow) int; // if allocation fails, new returns a null pointer
```

<p>For reasons we’ll explain in § <a href="177-19.1._controlling_memory_allocation.html#filepos5149502">19.1.2</a> (p. <a href="177-19.1._controlling_memory_allocation.html#filepos5149502">824</a>) this form of <code>new</code> is referred to as <strong><a href="118-defined_terms.html#filepos3190070" id="filepos2976074">placement new</a></strong>. A placement new expression lets us pass additional arguments to <code>new</code>. In this case, we pass an object named <code>nothrow</code> that is defined by the library. When we pass <code>nothrow</code> to <code>new</code>, we tell <code>new</code> that it must not throw an exception. If this form of <code>new</code> is unable to allocate the requested storage, it will return a null pointer. Both <code>bad_alloc</code> and <code>nothrow</code> are defined in the <code>new</code> header.</p>
<h5>Freeing Dynamic Memory</h5>
<p>In order to prevent memory exhaustion, we must return dynamically allocated memory to the system once we are finished using it. We return memory through a <code>delete</code>
<strong>expression</strong>. A <code>delete</code> expression takes a pointer to the object we want to free:</p>

```c++
delete p;      // p must point to a dynamically allocated object or be null
```

<p>Like <code>new</code>, a <code>delete</code> expression performs two actions: It destroys the object to which its given pointer points, and it frees the corresponding memory.</p>
<h5>Pointer Values and <code>delete</code></h5>
<p>The pointer we pass to <code>delete</code> must either point to dynamically allocated memory or be a null pointer (§ <a href="023-2.3._compound_types.html#filepos409391">2.3.2</a>, p. <a href="023-2.3._compound_types.html#filepos409391">53</a>). Deleting a pointer to memory that was not allocated by <code>new</code>, or deleting the same pointer value more than once, is undefined:</p>

```c++
int i, *pi1 = &i, *pi2 = nullptr;
double *pd = new double(33), *pd2 = pd;
delete i;   // error: i is not a pointer
delete pi1; // undefined: pi1 refers to a local
delete pd;  // ok
delete pd2; // undefined: the memory pointed to by pd2 was already freed
delete pi2; // ok: it is always ok to delete a null pointer
```

<p><a id="filepos2980688"></a>The compiler will generate an error for the <code>delete</code> of <code>i</code> because it knows that <code>i</code> is not a pointer. The errors associated with executing <code>delete</code> on <code>pi1</code> and <code>pd2</code> are more insidious: In general, compilers cannot tell whether a pointer points to a statically or dynamically allocated object. Similarly, the compiler cannot tell whether memory addressed by a pointer has already been freed. Most compilers will accept these <code>delete</code> expressions, even though they are in error.</p>
<p>Although the value of a <code>const</code> object cannot be modified, the object itself can be destroyed. As with any other dynamic object, a <code>const</code> dynamic object is freed by executing <code>delete</code> on a pointer that points to that object:</p>

```c++
const int *pci = new const int(1024);
delete pci;  // ok: deletes a const object
```

<h5>Dynamically Allocated Objects Exist until They Are Freed</h5>
<p>As we saw in § <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos2907541">12.1.1</a> (p. <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos2907541">452</a>), memory that is managed through a <code>shared_ptr</code> is automatically deleted when the last <code>shared_ptr</code> is destroyed. The same is not true for memory we manage using built-in pointers. A dynamic object managed through a built-in pointer exists until it is explicitly deleted.</p>
<p>Functions that return pointers (rather than smart pointers) to dynamic memory put a burden on their callers—the caller must remember to delete the memory:</p>

```c++
// factory returns a pointer to a dynamically allocated object
Foo* factory(T arg)
{
    // process arg as appropriate
    return new Foo(arg); // caller is responsible for deleting this memory
}
```

<p>Like our earlier <code>factory</code> function (§ <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos2907541">12.1.1</a>, p. <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos2907541">453</a>), this version of <code>factory</code> allocates an object but does not <code>delete</code> it. Callers of <code>factory</code> are responsible for freeing this memory when they no longer need the allocated object. Unfortunately, all too often the caller forgets to do so:</p>

```c++
void use_factory(T arg)
{
    Foo *p = factory(arg);
    // use p but do not delete it
} // p goes out of scope, but the memory to which p points is not freed!
```

<p>Here, our <code>use_factory</code> function calls <code>factory</code>, which allocates a new object of type <code>Foo</code>. When <code>use_factory</code> returns, the local variable <code>p</code> is destroyed. That variable is a built-in pointer, not a smart pointer.</p>
<p>Unlike class types, nothing happens when objects of built-in type are destroyed. In particular, when a pointer goes out of scope, nothing happens to the object to which the pointer points. If that pointer points to dynamic memory, that memory is not automatically freed.</p>

::: warning
<p>Dynamic memory managed through built-in pointers (rather than smart pointers) exists until it is explicitly freed.</p>
:::

<p><a id="filepos2987662"></a>In this example, <code>p</code> was the only pointer to the memory allocated by <code>factory</code>. Once <code>use_factory</code> returns, the program has no way to free that memory. Depending on the logic of our overall program, we should fix this bug by remembering to free the memory inside <code>use_factory</code>:</p>

```c++
void use_factory(T arg)
{
    Foo *p = factory(arg);
    // use p
    delete p;  // remember to free the memory now that we no longer need it
}
```

<p>or, if other code in our system needs to use the object allocated by <code>use_factory</code>, we should change that function to return a pointer to the memory it allocated:</p>

```c++
Foo* use_factory(T arg)
{
    Foo *p = factory(arg);
    // use p
    return p;  // caller must delete the memory
}
```

::: warning
<p>Caution: Managing Dynamic Memory Is Error-Prone</p>
<p>There are three common problems with using <code>new</code> and <code>delete</code> to manage dynamic memory:</p>
<ol>
    <li>Forgetting to <code>delete</code> memory. Neglecting to delete dynamic memory is known as a “memory leak,” because the memory is never returned to the free store. Testing for memory leaks is difficult because they usually cannot be detected until the application is run for a long enough time to actually exhaust memory.</li>
    <li>Using an object after it has been deleted. This error can sometimes be detected by making the pointer null after the delete.</li>
    <li>Deleting the same memory twice. This error can happen when two pointers address the same dynamically allocated object. If <code>delete</code> is applied to one of the pointers, then the object’s memory is returned to the free store. If we subsequently <code>delete</code> the second pointer, then the free store may be corrupted.</li>
</ol>
<p>These kinds of errors are considerably easier to make than they are to find and fix.</p>
:::
::: tip
<p>Best Practices</p>
<p>You can avoid <em>all</em> of these problems by using smart pointers exclusively. The smart pointer will take care of deleting the memory <em>only</em> when there are no remaining smart pointers pointing to that memory.</p>
:::

<h5>Resetting the Value of a Pointer after a <code>delete ...</code></h5>
<p>When we <code>delete</code> a pointer, that pointer becomes invalid. Although the pointer is invalid, on many machines the pointer continues to hold the address of the (freed) dynamic memory. After the <code>delete</code>, the pointer becomes what is referred to as a <a id="filepos2993287"></a><strong><a href="118-defined_terms.html#filepos3186618" id="filepos2993303">dangling pointer</a></strong>. A dangling pointer is one that refers to memory that once held an object but no longer does so.</p>
<p>Dangling pointers have all the problems of uninitialized pointers (§ <a href="023-2.3._compound_types.html#filepos409391">2.3.2</a>, p. <a href="023-2.3._compound_types.html#filepos409391">54</a>). We can avoid the problems with dangling pointers by deleting the memory associated with a pointer just before the pointer itself goes out of scope. That way there is no chance to use the pointer after the memory associated with the pointer is freed. If we need to keep the pointer around, we can assign <code>nullptr</code> to the pointer after we use <code>delete</code>. Doing so makes it clear that the pointer points to no object.</p>
<h5>...Provides Only Limited Protection</h5>
<p>A fundamental problem with dynamic memory is that there can be several pointers that point to the same memory. Resetting the pointer we use to <code>delete</code> that memory lets us check that particular pointer but has no effect on any of the other pointers that still point at the (freed) memory. For example:</p>

```c++
int *p(new int(42));  // p points to dynamic memory
auto q = p;           // p and q point to the same memory
delete p;    // invalidates both p and q
p = nullptr; // indicates that p is no longer bound to an object
```

<p>Here both <code>p</code> and <code>q</code> point at the same dynamically allocated object. We <code>delete</code> that memory and set <code>p</code> to <code>nullptr</code>, indicating that the pointer no longer points to an object. However, resetting <code>p</code> has no effect on <code>q</code>, which became invalid when we deleted the memory to which <code>p</code> (and <code>q</code>!) pointed. In real systems, finding all the pointers that point to the same memory is surprisingly difficult.</p>

::: info
<p>Exercises Section 12.1.2</p>
<p><strong>Exercise 12.6:</strong> Write a function that returns a dynamically allocated <code>vector</code> of <code>int</code>s. Pass that <code>vector</code> to another function that reads the standard input to give values to the elements. Pass the <code>vector</code> to another function to print the values that were read. Remember to <code>delete</code> the <code>vector</code> at the appropriate time.</p>
<p><strong>Exercise 12.7:</strong> Redo the previous exercise, this time using <code>shared_ptr</code>.</p>
<p><strong>Exercise 12.8:</strong> Explain what if anything is wrong with the following function.</p>

```c++
bool b() {
    int* p = new int;
    // ...
    return p;
}
```

<p><strong>Exercise 12.9:</strong> Explain what happens in the following code:</p>

```c++
int *q = new int(42), *r = new int(100);
r = q;
auto q2 = make_shared<int>(42), r2 = make_shared<int>(100);
r2 = q2;
```

:::

<h4 id="filepos2999606"><a id="filepos2999639"></a>12.1.3. Using <code>shared_ptr</code>s with <code>new</code></h4>
<p>As we’ve seen, if we do not initialize a smart pointer, it is initialized as a null pointer. As described in <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos3001332">Table 12.3</a>, we can also initialize a smart pointer from a pointer returned by <code>new</code>:</p>

```c++
shared_ptr<double> p1; // shared_ptr that can point at a double
shared_ptr<int> p2(new int(42)); // p2 points to an int with value 42
```

<p><a id="filepos3001332"></a>Table 12.3. Other Ways to Define and Change <code>shared_ptr</code><strong>s</strong></p>

| Code                     | Description                                                                                                                                                                                               |
|--------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `shared_ptr<T> p(q)`     | `p` manages the object to which the built-in pointer `q` points; `q` must point to memory allocated by `new` and must be convertible to `T*`.                                                             |
| `shared_ptr<T> p(u)`     | `p` assumes ownership from the `unique_ptr u`; makes `u` null.                                                                                                                                            |
| `shared_ptr<T> p(q, d)`  | `p` assumes ownership for the object to which the built-in pointer `q` points. `q` must be convertible to `T*`. `p` will use the callable object `d` (§ 10.3.2, p. 388) in place of `delete` to free `q`. |
| `shared_ptr<T> p(p2, d)` | `p` is a copy of the `shared_ptr` `p2` as described in Table 12.2 except that `p` uses the callable object `d` in place of `delete`.                                                                      |
| `p.reset()`              | If `p` is the only `shared_ptr` pointing at its object, `reset` frees `p`'s existing object.                                                                                                              |
| `p.reset(q)`             | If the optional built-in pointer `q` is passed, makes `p` point to `q`, otherwise makes `p` null.                                                                                                         |
| `p.reset(q, d)`          | If `d` is supplied, will call `d` to free `q` otherwise uses `delete` to free `q`.                                                                                                                        |

<p>The smart pointer constructors that take pointers are <code>explicit</code> (§ <a href="077-7.5._constructors_revisited.html#filepos1990205">7.5.4</a>, p. <a href="077-7.5._constructors_revisited.html#filepos1990205">296</a>). Hence, we cannot implicitly convert a built-in pointer to a smart pointer; we must use the direct form of initialization (§ <a href="031-3.2._library_string_type.html#filepos651083">3.2.1</a>, p. <a href="031-3.2._library_string_type.html#filepos651083">84</a>) to initialize a smart pointer:</p>

```c++
shared_ptr<int> p1 = new int(1024);  // error: must use direct initialization
shared_ptr<int> p2(new int(1024));   // ok: uses direct initialization
```

<p>The initialization of <code>p1</code> implicitly asks the compiler to create a <code>shared_ptr</code> from the <code>int*</code> returned by <code>new</code>. Because we can’t implicitly convert a pointer to a smart pointer, this initialization is an error. For the same reason, a function that returns a <code>shared_ptr</code> cannot implicitly convert a plain pointer in its return statement:</p>

```c++
shared_ptr<int> clone(int p) {
    return new int(p); // error: implicit conversion to shared_ptr<int>
}
```

<p>We must explicitly bind a <code>shared_ptr</code> to the pointer we want to return:</p>

```c++
shared_ptr<int> clone(int p) {
    // ok: explicitly create a shared_ptr<int> from int*
    return shared_ptr<int>(new int(p));
}
```

<p>By default, a pointer used to initialize a smart pointer must point to dynamic memory because, by default, smart pointers use <code>delete</code> to free the associated object. We can bind smart pointers to pointers to other kinds of resources. However, to do so, we must supply our own operation to use in place of <code>delete</code>. We’ll see how to supply our own deletion code in § <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos3024819">12.1.4</a> (p. <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos3024819">468</a>).</p>
<h5>Don’t Mix Ordinary Pointers and Smart Pointers ...</h5>
<Badge type="warning" text="Tricky" />
<p>A <code>shared_ptr</code> can coordinate destruction only with other <code>shared_ptr</code>s that are copies of itself. Indeed, this fact is one of the reasons we recommend using <code>make_shared</code> rather than <code>new</code>. That way, we bind a <code>shared_ptr</code> to the object at the same time that we allocate it. There is no way to inadvertently bind the same memory to more than one independently created <code>shared_ptr</code>.</p>
<p>Consider the following function that operates on a <code>shared_ptr</code>:</p>

```c++
// ptr is created and initialized when process is called
void process(shared_ptr<int> ptr)
{
    // use ptr
} // ptr goes out of scope and is destroyed
```

<p>The parameter to <code>process</code> is passed by value, so the argument to <code>process</code> is copied into <code>ptr</code>. Copying a <code>shared_ptr</code> increments its reference count. Thus, inside <code>process</code> the count is at least 2. When <code>process</code> completes, the reference count of <code>ptr</code> is decremented but cannot go to zero. Therefore, when the local variable <code>ptr</code> is destroyed, the memory to which <code>ptr</code> points will not be deleted.</p>
<p>The right way to use this function is to pass it a <code>shared_ptr</code>:</p>

```c++
shared_ptr<int> p(new int(42)); // reference count is 1
process(p); // copying p increments its count; in process the reference count is 2
int i = *p; // ok: reference count is 1
```

<p>Although we cannot pass a built-in pointer to <code>process</code>, we can pass <code>process</code> a (temporary) <code>shared_ptr</code> that we explicitly construct from a built-in pointer. However, doing so is likely to be an error:</p>

```c++
int *x(new int(1024)); // dangerous: x is a plain pointer, not a smart pointer
process(x);  // error: cannot convert int* to shared_ptr<int>
process(shared_ptr<int>(x)); // legal, but the memory will be deleted!
int j = *x;  // undefined: x is a dangling pointer!
```

<p>In this call, we passed a temporary <code>shared_ptr</code> to <code>process</code>. That temporary is destroyed when the expression in which the call appears finishes. Destroying the temporary decrements the reference count, which goes to zero. The memory to which the temporary points is freed when the temporary is destroyed.</p>
<p>But <code>x</code> continues to point to that (freed) memory; <code>x</code> is now a dangling pointer. Attempting to use the value of <code>x</code> is undefined.</p>
<p>When we bind a <code>shared_ptr</code> to a plain pointer, we give responsibility for that memory to that <code>shared_ptr</code>. Once we give <code>shared_ptr</code> responsibility for a pointer, we should no longer use a built-in pointer to access the memory to which the <code>shared_ptr</code> now points.</p>

::: warning
<a id="filepos3013215"></a>
<p>It is dangerous to use a built-in pointer to access an object owned by a smart pointer, because we may not know when that object is destroyed.</p>
:::

<h5>...and Don’t Use <code>get</code> to Initialize or Assign Another Smart Pointer</h5>
<Badge type="warning" text="Tricky" />
<p>The smart pointer types define a function named <code>get</code> (described in <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos2911678">Table 12.1</a> (p. <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos2911678">452</a>)) that returns a built-in pointer to the object that the smart pointer is managing. This function is intended for cases when we need to pass a built-in pointer to code that can’t use a smart pointer. The code that uses the return from <code>get</code> must not <code>delete</code> that pointer.</p>
<p>Although the compiler will not complain, it is an error to bind another smart pointer to the pointer returned by <code>get</code>:</p>

```c++
shared_ptr<int> p(new int(42)); // reference count is 1
int *q = p.get();  // ok: but don't use q in any way that might delete its pointer
{ // new block
// undefined: two independent shared_ptrs point to the same memory
shared_ptr<int>(q);
} // block ends, q is destroyed, and the memory to which q points is freed
int foo = *p; // undefined; the memory to which p points was freed
```

<p>In this case, both <code>p</code> and <code>q</code> point to the same memory. Because they were created independently from each other, each has a reference count of 1. When the block in which <code>q</code> was defined ends, <code>q</code> is destroyed. Destroying <code>q</code> frees the memory to which <code>q</code> points. That makes <code>p</code> into a dangling pointer, meaning that what happens when we attempt to use <code>p</code> is undefined. Moreover, when <code>p</code> is destroyed, the pointer to that memory will be <code>delete</code>d a second time.</p>

::: warning
<p>Use <code>get</code> only to pass access to the pointer to code that you know will not <code>delete</code> the pointer. In particular, never use <code>get</code> to initialize or assign to another smart pointer.</p>
:::

<h5>Other <code>shared_ptr</code> Operations</h5>
<p>The <code>shared_ptr</code> class gives us a few other operations, which are listed in <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos2912161">Table 12.2</a> (p. <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos2912161">453</a>) and <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos3001332">Table 12.3</a> (on the previous page). We can use <code>reset</code> to assign a new pointer to a <code>shared_ptr</code>:</p>

```c++
p = new int(1024);       // error: cannot assign a pointer to a shared_ptr
p.reset(new int(1024));  // ok: p points to a new object
```

<p>Like assignment, <code>reset</code> updates the reference counts and, if appropriate, deletes the object to which <code>p</code> points. The <code>reset</code> member is often used together with <code>unique</code> to control changes to the object shared among several <code>shared_ptr</code>s. Before changing the underlying object, we check whether we’re the only user. If not, we make a new copy before making the change:</p>

```c++
if (!p.unique())
    p.reset(new string(*p)); // we aren't alone; allocate a new copy
*p += newVal; // now that we know we're the only pointer, okay to change this object
```

::: info
<a id="filepos3021386"></a><p>Exercises Section 12.1.3</p>
<p><strong>Exercise 12.10:</strong> Explain whether the following call to the <code>process</code> function defined on page <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos2999639">464</a> is correct. If not, how would you correct the call?</p>

```c++
shared_ptr<int> p(new int(42));
process(shared_ptr<int>(p));
```

<p><strong>Exercise 12.11:</strong> What would happen if we called <code>process</code> as follows?</p>

```c++
process(shared_ptr<int>(p.get()));
```

<p><strong>Exercise 12.12:</strong> Using the declarations of <code>p</code> and <code>sp</code> explain each of the following calls to <code>process</code>. If the call is legal, explain what it does. If the call is illegal, explain why:</p>

```c++
auto p = new int();
auto sp = make_shared<int>();
```

<p><strong>(a)</strong>
<code>process(sp);</code></p>
<p><strong>(b)</strong>
<code>process(new int());</code></p>
<p><strong>(c)</strong>
<code>process(p);</code></p>
<p><strong>(d)</strong>
<code>process(shared_ptr&lt;int&gt;(p));</code></p>
<p><strong>Exercise 12.13</strong>: What happens if we execute the following code?</p>

```c++
auto sp = make_shared<int>();
auto p = sp.get();
delete p;
```

:::

<h4 id="filepos3024819">12.1.4. Smart Pointers and Exceptions</h4>
<Badge type="info" text="Fundamental" />
<p>In § <a href="059-5.6._try_blocks_and_exception_handling.html#filepos1377241">5.6.2</a> (p. <a href="059-5.6._try_blocks_and_exception_handling.html#filepos1377241">196</a>) we noted that programs that use exception handling to continue processing after an exception occurs need to ensure that resources are properly freed if an exception occurs. One easy way to make sure resources are freed is to use smart pointers.</p>
<p>When we use a smart pointer, the smart pointer class ensures that memory is freed when it is no longer needed even if the block is exited prematurely:</p>

```c++
void f()
{
    shared_ptr<int> sp(new int(42)); // allocate a new object
   // code that throws an exception that is not caught inside f
} // shared_ptr freed automatically when the function ends
```

<p>When a function is exited, whether through normal processing or due to an exception, all the local objects are destroyed. In this case, <code>sp</code> is a <code>shared_ptr</code>, so destroying <code>sp</code> checks its reference count. Here, <code>sp</code> is the only pointer to the memory it manages; that memory will be freed as part of destroying <code>sp</code>.</p>
<p>In contrast, memory that we manage directly is not automatically freed when an exception occurs. If we use built-in pointers to manage memory and an exception occurs after a <code>new</code> but before the corresponding <code>delete</code>, then that memory won’t be freed:</p>
<p><a id="filepos3027622"></a></p>

```c++
void f()
{
    int *ip = new int(42);     // dynamically allocate a new object
    // code that throws an exception that is not caught inside f
    delete ip;                 // free the memory before exiting
}
```

<p>If an exception happens between the <code>new</code> and the <code>delete</code>, and is not caught inside <code>f</code>, then this memory can never be freed. There is no pointer to this memory outside the function <code>f</code>. Thus, there is no way to free this memory.</p>
<h5>Smart Pointers and Dumb Classes</h5>
<Badge type="danger" text="Advanced" />
<p>Many C++ classes, including all the library classes, define destructors (§ <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos2907541">12.1.1</a>, p. <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos2907541">452</a>) that take care of cleaning up the resources used by that object. However, not all classes are so well behaved. In particular, classes that are designed to be used by both C and C++ generally require the user to specifically free any resources that are used.</p>
<p>Classes that allocate resources—and that do not define destructors to free those resources—can be subject to the same kind of errors that arise when we use dynamic memory. It is easy to forget to release the resource. Similarly, if an exception happens between when the resource is allocated and when it is freed, the program will leak that resource.</p>
<p>We can often use the same kinds of techniques we use to manage dynamic memory to manage classes that do not have well-behaved destructors. For example, imagine we’re using a network library that is used by both C and C++. Programs that use this library might contain code such as</p>

```c++
struct destination;  // represents what we are connecting to
struct connection;   // information needed to use the connection
connection connect(destination*);  // open the connection
void disconnect(connection);       // close the given connection
void f(destination &d /* other parameters */)
{
    // get a connection; must remember to close it when done
    connection c = connect(&d);
    // use the connection
    // if we forget to call disconnect before exiting f, there will be no way to close c
}
```

<p>If <code>connection</code> had a destructor, that destructor would automatically close the connection when <code>f</code> completes. However, <code>connection</code> does not have a destructor. This problem is nearly identical to our previous program that used a <code>shared_ptr</code> to avoid memory leaks. It turns out that we can also use a <code>shared_ptr</code> to ensure that the <code>connection</code> is properly closed.</p>
<h5>Using Our Own Deletion Code</h5>
<Badge type="danger" text="Advanced" />
<p>By default, <code>shared_ptr</code>s assume that they point to dynamic memory. Hence, by default, when a <code>shared_ptr</code> is destroyed, it executes <code>delete</code> on the pointer it <a id="filepos3033762"></a>holds. To use a <code>shared_ptr</code> to manage a <code>connection</code>, we must first define a function to use in place of <code>delete</code>. It must be possible to call this <strong><a href="118-defined_terms.html#filepos3187653" id="filepos3034110">deleter</a></strong> function with the pointer stored inside the <code>shared_ptr</code>. In this case, our deleter must take a single argument of type <code>connection*</code>:</p>

```c++
void end_connection(connection *p) { disconnect(*p); }
```

<p>When we create a <code>shared_ptr</code>, we can pass an optional argument that points to a deleter function (§ <a href="069-6.7._pointers_to_functions.html#filepos1702852">6.7</a>, p. <a href="069-6.7._pointers_to_functions.html#filepos1702852">247</a>):</p>

```c++
void f(destination &d /* other parameters */)
{
    connection c = connect(&d);
    shared_ptr<connection> p(&c, end_connection);
    // use the connection
    // when f exits, even if by an exception, the connection will be properly closed
}
```

<p>When <code>p</code> is destroyed, it won’t execute <code>delete</code> on its stored pointer. Instead, <code>p</code> will call <code>end_connection</code> on that pointer. In turn, <code>end_connection</code> will call <code>disconnect</code>, thus ensuring that the connection is closed. If <code>f</code> exits normally, then <code>p</code> will be destroyed as part of the return. Moreover, <code>p</code> will also be destroyed, and the connection will be closed, if an exception occurs.</p>

::: info
<p>Caution: Smart Pointer Pitfalls</p>
<p>Smart pointers can provide safety and convenience for handling dynamically allocated memory only when they are used properly. To use smart pointers correctly, we must adhere to a set of conventions:</p>
<ul>
    <li>Don’t use the same built-in pointer value to initialize (or <code>reset</code>) more than one smart pointer.</li>
    <li>Don’t <code>delete</code> the pointer returned from <code>get()</code>.</li>
    <li>Don’t use <code>get()</code> to initialize or <code>reset</code> another smart pointer.</li>
    <li>If you use a pointer returned by <code>get()</code>, remember that the pointer will become invalid when the last corresponding smart pointer goes away.</li>
    <li>If you use a smart pointer to manage a resource other than memory allocated by <code>new</code>, remember to pass a deleter (§ <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos3024819">12.1.4</a>, p. <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos3024819">468</a>, and § <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos3040235">12.1.5</a>, p. <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos3040235">471</a>).</li>
</ul>
:::

::: info
<p>Exercises Section 12.1.4</p>
<p><strong>Exercise 12.14:</strong> Write your own version of a function that uses a <code>shared_ptr</code> to manage a <code>connection</code>.</p>
<p><strong>Exercise 12.15:</strong> Rewrite the first exercise to use a lambda (§ <a href="100-10.3._customizing_operations.html#filepos2530282">10.3.2</a>, p. <a href="100-10.3._customizing_operations.html#filepos2530282">388</a>) in place of the <code>end_connection</code> function.</p>
:::

<h4 id="filepos3040235"><a id="filepos3040268"></a>12.1.5. <code>unique_ptr</code></h4>
<a id="filepos3040473"></a><Badge type="tip" text="C++11" />
<p>A <code>unique_ptr</code> “owns” the object to which it points. Unlike <code>shared_ptr</code>, only one <code>unique_ptr</code> at a time can point to a given object. The object to which a <code>unique_ptr</code> points is destroyed when the <code>unique_ptr</code> is destroyed. <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos3041443">Table 12.4</a> lists the operations specific to <code>unique_ptr</code>s. The operations common to both were covered in <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos2911678">Table 12.1</a> (p. <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos2911678">452</a>).</p>
<p><a id="filepos3041443"></a>Table 12.4. <code>unique_ptr</code> Operations (See Also <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos2911678">Table 12.1</a> (p. <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos2911678">452</a>))</p>

| Code                                        | Description                                                                                                                                 |
|---------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------|
| `unique_ptr<T> u1`                          | Null `unique_ptr` that can point to objects of type `T`. `u1` will use `delete` to free its pointer.                                        |
| `unique_ptr<T, D> u2`                       | `u2` will use a callable object of type `D` to free its pointer.                                                                            |
| `unique_ptr<T, D> u(d)`                     | Null `unique_ptr` that point to objects of type `T` that uses `d`, which must be an object of type `D` in place of `delete`.                |
| `u = nullptr`                               | Deletes the object to which `u` points; makes `u` null.                                                                                     |
| `u.release()`                               | Relinquishes control of the pointer `u` had held; returns the pointer `u` had held and makes `u` null.                                      |
| `u.reset()` `u.reset(q)` `u.reset(nullptr)` | Deletes the object to which `u` points. If the built-in pointer `q` is supplied, makes `u` point to that object.  Otherwise makes `u` null. |

<p>Unlike <code>shared_ptr</code>, there is no library function comparable to <code>make_shared</code> that returns a <code>unique_ptr</code>. Instead, when we define a <code>unique_ptr</code>, we bind it to a pointer returned by <code>new</code>. As with <code>shared_ptr</code>s, we must use the direct form of initialization:</p>

```c++
unique_ptr<double> p1;  // unique_ptr that can point at a double
unique_ptr<int> p2(new int(42)); // p2 points to int with value 42
```

<p>Because a <code>unique_ptr</code> owns the object to which it points, <code>unique_ptr</code> does not support ordinary copy or assignment:</p>

```c++
unique_ptr<string> p1(new string("Stegosaurus"));
unique_ptr<string> p2(p1);  // error: no copy for unique_ptr
unique_ptr<string> p3;
p3 = p2;                    // error: no assign for unique_ptr
```

<p>Although we can’t copy or assign a <code>unique_ptr</code>, we can transfer ownership from one (non<code>const</code>) <code>unique_ptr</code> to another by calling <code>release</code> or <code>reset</code>:</p>

```c++
// transfers ownership from p1 (which points to the string Stegosaurus) to p2
unique_ptr<string> p2(p1.release()); // release makes p1 null
unique_ptr<string> p3(new string("Trex"));
// transfers ownership from p3 to p2
p2.reset(p3.release()); // reset deletes the memory to which p2 had pointed
```

<p>The <code>release</code> member returns the pointer currently stored in the <code>unique_ptr</code> and makes that <code>unique_ptr</code> null. Thus, <code>p2</code> is initialized from the pointer value that had been stored in <code>p1</code> and <code>p1</code> becomes null.</p>
<p><a id="filepos3047668"></a>The <code>reset</code> member takes an optional pointer and repositions the <code>unique_ptr</code> to point to the given pointer. If the <code>unique_ptr</code> is not null, then the object to which the <code>unique_ptr</code> had pointed is deleted. The call to <code>reset</code> on <code>p2</code>, therefore, frees the memory used by the <code>string</code> initialized from <code>"Stegosaurus"</code>, transfers <code>p3</code>’s pointer to <code>p2</code>, and makes <code>p3</code> null.</p>
<p>Calling <code>release</code> breaks the connection between a <code>unique_ptr</code> and the object it had been managing. Often the pointer returned by <code>release</code> is used to initialize or assign another smart pointer. In that case, responsibility for managing the memory is simply transferred from one smart pointer to another. However, if we do not use another smart pointer to hold the pointer returned from <code>release</code>, our program takes over responsibility for freeing that resource:</p>

```c++
p2.release(); // WRONG: p2 won't free the memory and we've lost the pointer
auto p = p2.release(); // ok, but we must remember to delete(p)
```

<h5>Passing and Returning <code>unique_ptr</code>s</h5>
<p>There is one exception to the rule that we cannot copy a <code>unique_ptr:</code> We can copy or assign a <code>unique_ptr</code> that is about to be destroyed. The most common example is when we return a <code>unique_ptr</code> from a function:</p>

```c++
unique_ptr<int> clone(int p) {
    // ok: explicitly create a unique_ptr<int> from int*
    return unique_ptr<int>(new int(p));
}
```

<p>Alternatively, we can also return a copy of a local object:</p>

```c++
unique_ptr<int> clone(int p) {
    unique_ptr<int> ret(new int (p));
    // . . .
    return ret;
}
```

<p>In both cases, the compiler knows that the object being returned is about to be destroyed. In such cases, the compiler does a special kind of “copy” which we’ll discuss in § <a href="126-13.6._moving_objects.html#filepos3443291">13.6.2</a> (p. <a href="126-13.6._moving_objects.html#filepos3443291">534</a>).</p>

::: info
<p>Backward Compatibility: <code>auto_ptr</code></p>
<p>Earlier versions of the library included a class named <code>auto_ptr</code> that had some, but not all, of the properties of <code>unique_ptr</code>. In particular, it was not possible to store an <code>auto_ptr</code> in a container, nor could we return one from a function.</p>
<p>Although <code>auto_ptr</code> is still part of the standard library, programs should use <code>unique_ptr</code> instead.</p>
:::

<h5>Passing a Deleter to <code>unique_ptr</code></h5>
<p>Like <code>shared_ptr</code>, by default, <code>unique_ptr</code> uses <code>delete</code> to free the object to which a <code>unique_ptr</code> points. As with <code>shared_ptr</code>, we can override the default <a id="filepos3054611"></a>deleter in a <code>unique_ptr</code> (§ <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos3024819">12.1.4</a>, p. <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos3024819">468</a>). However, for reasons we’ll describe in § <a href="154-16.1._defining_a_template.html#filepos4310778">16.1.6</a> (p. <a href="154-16.1._defining_a_template.html#filepos4310778">676</a>), the way <code>unique_ptr</code> manages its deleter is differs from the way <code>shared_ptr</code> does.</p>
<p>Overridding the deleter in a <code>unique_ptr</code> affects the <code>unique_ptr</code> type as well as how we construct (or <code>reset</code>) objects of that type. Similar to overriding the comparison operation of an associative container (§ <a href="108-11.2._overview_of_the_associative_containers.html#filepos2751456">11.2.2</a>, p. <a href="108-11.2._overview_of_the_associative_containers.html#filepos2751456">425</a>), we must supply the deleter type inside the angle brackets along with the type to which the <code>unique_ptr</code> can point. We supply a callable object of the specified type when we create or <code>reset</code> an object of this type:</p>

```c++
// p points to an object of type objT and uses an object of type delT to free that object
// it will call an object named fcn of type delT
unique_ptr<objT, delT> p (new objT, fcn);
```

<p>As a somewhat more concrete example, we’ll rewrite our connection program to use a <code>unique_ptr</code> in place of a <code>shared_ptr</code> as follows:</p>

```c++
void f(destination &d /* other needed parameters */)
{
    connection c = connect(&d);  // open the connection
    // when p is destroyed, the connection will be closed
    unique_ptr<connection, decltype(end_connection)*>
        p(&c, end_connection);
    // use the connection
    // when f exits, even if by an exception, the connection will be properly closed
}
```

<p>Here we use <code>decltype</code> (§ <a href="025-2.5._dealing_with_types.html#filepos562878">2.5.3</a>, p. <a href="025-2.5._dealing_with_types.html#filepos562878">70</a>) to specify the function pointer type. Because <code>decltype(end_connection)</code> returns a function type, we must remember to add a <code>*</code> to indicate that we’re using a pointer to that type (§ <a href="069-6.7._pointers_to_functions.html#filepos1702852">6.7</a>, p. <a href="069-6.7._pointers_to_functions.html#filepos1702852">250</a>).</p>

::: info
<p>Exercises Section 12.1.5</p>
<p><strong>Exercise 12.16:</strong> Compilers don’t always give easy-to-understand error messages if we attempt to copy or assign a <code>unique_ptr</code>. Write a program that contains these errors to see how your compiler diagnoses them.</p>
<p><strong>Exercise 12.17:</strong> Which of the following <code>unique_ptr</code> declarations are illegal or likely to result in subsequent program error? Explain what the problem is with each one.</p>

```c++
int ix = 1024, *pi = &ix, *pi2 = new int(2048);
typedef unique_ptr<int> IntP;
```

<p>(a) <code>IntP p0(ix);</code></p>
<p>(b) <code>IntP p1(pi);</code></p>
<p>(c) <code>IntP p2(pi2);</code></p>
<p>(d) <code>IntP p3(&amp;ix);</code></p>
<p>(e) <code>IntP p4(new int(2048));</code></p>
<p>(f) <code>IntP p5(p2.get());</code></p>
<p><strong>Exercise 12.18:</strong> Why doesn’t <code>shared_ptr</code> have a <code>release</code> member?</p>
:::

<h4 id="filepos3062321"><a id="filepos3062354"></a>12.1.6. <code>weak_ptr</code></h4>
<Badge type="danger" text="Advanced" />
<a id="filepos3062617"></a><Badge type="tip" text="C++11" />
<p>A <code>weak_ptr</code> (<a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos3063983">Table 12.5</a>) is a smart pointer that does not control the lifetime of the object to which it points. Instead, a <code>weak_ptr</code> points to an object that is managed by a <code>shared_ptr</code>. Binding a <code>weak_ptr</code> to a <code>shared_ptr</code> does not change the reference count of that <code>shared_ptr</code>. Once the last <code>shared_ptr</code> pointing to the object goes away, the object itself will be deleted. That object will be deleted even if there are <code>weak_ptr</code>s pointing to it—hence the name <code>weak_ptr</code>, which captures the idea that a <code>weak_ptr</code> shares its object “weakly.”</p>
<p><a id="filepos3063983"></a>Table 12.5. <code>weak_ptr</code>s</p>

| Expression          | Description                                                                                                                   |
|---------------------|-------------------------------------------------------------------------------------------------------------------------------|
| `weak_ptr<T> w`     | Null `weak_ptr` that can point at objects of type `T`.                                                                        |
| `weak_ptr<T> w(sp)` | `weak_ptr` that points to the same object as the `shared_ptr` `sp`. `T` must be convertible to the type to which `sp` points. |
| `w = p`             | `p` can be a `shared_ptr` or a `weak_ptr`. After the assignment `w` shares ownership with `p`.                                |
| `w.reset()`         | Makes `w` null.                                                                                                               |
| `w.use_count()`     | The number of `shared_ptrs` that share ownership with `w`.                                                                    |
| `w.expired()`       | Returns `true` if `w.use_count()` is zero, `false` otherwise.                                                                 |
| `w.lock()`          | If `expired` is `true`, returns a null `shared_ptr`; otherwise returns a `shared_ptr` to the object to which `w` points.      |

<p>When we create a <code>weak_ptr</code>, we initialize it from a <code>shared_ptr</code>:</p>

```c++
auto p = make_shared<int>(42);
weak_ptr<int> wp(p);  // wp weakly shares with p; use count in p is unchanged
```

<p>Here both <code>wp</code> and <code>p</code> point to the same object. Because the sharing is weak, creating <code>wp</code> doesn’t change the reference count of p; it is possible that the object to which <code>wp</code> points might be deleted.</p>
<p>Because the object might no longer exist, we cannot use a <code>weak_ptr</code> to access its object directly. To access that object, we must call <code>lock</code>. The <code>lock</code> function checks whether the object to which the <code>weak_ptr</code> points still exists. If so, <code>lock</code> returns a <code>shared_ptr</code> to the shared object. As with any other <code>shared_ptr</code>, we are guaranteed that the underlying object to which that <code>shared_ptr</code> points continues to exist at least as long as that <code>shared_ptr</code> exists. For example:</p>

```c++
if (shared_ptr<int> np = wp.lock()) { // true if np is not null
    // inside the if, np shares its object with p
}
```

<p>Here we enter the body of the <code>if</code> only if the call to <code>lock</code> succeeds. Inside the <code>if</code>, it is safe to use <code>np</code> to access that object.</p>
<h5>Checked Pointer Class</h5>
<p>As an illustration of when a <code>weak_ptr</code> is useful, we’ll define a companion pointer class for our <code>StrBlob</code> class. Our pointer class, which we’ll name <code>StrBlobPtr</code>, <a id="filepos3068886"></a>will store a <code>weak_ptr</code> to the <code>data</code> member of the <code>StrBlob</code> from which it was initialized. By using a <code>weak_ptr</code>, we don’t affect the lifetime of the <code>vector</code> to which a given <code>StrBlob</code> points. However, we can prevent the user from attempting to access a <code>vector</code> that no longer exists.</p>
<p><code>StrBlobPtr</code> will have two data members: <code>wptr</code>, which is either null or points to a <code>vector</code> in a <code>StrBlob</code>; and <code>curr</code>, which is the index of the element that this object currently denotes. Like its companion <code>StrBlob</code> class, our pointer class has a <code>check</code> member to verify that it is safe to dereference the <code>StrBlobPtr</code>:</p>

```c++
// StrBlobPtr throws an exception on attempts to access a nonexistent element
class StrBlobPtr {
public:
    StrBlobPtr(): curr(0) { }
    StrBlobPtr(StrBlob &a, size_t sz = 0):
            wptr(a.data), curr(sz) { }
    std::string& deref() const;
    StrBlobPtr& incr();       // prefix version
private:
    // check returns a shared_ptr to the vector if the check succeeds
    std::shared_ptr<std::vector<std::string>>
        check(std::size_t, const std::string&) const;
    // store a weak_ptr, which means the underlying vector might be destroyed
    std::weak_ptr<std::vector<std::string>> wptr;
    std::size_t curr;      // current position within the array
};
```

<p>The default constructor generates a null <code>StrBlobPtr</code>. Its constructor initializer list (§ <a href="073-7.1._defining_abstract_data_types.html#filepos1802479">7.1.4</a>, p. <a href="073-7.1._defining_abstract_data_types.html#filepos1802479">265</a>) explicitly initializes <code>curr</code> to zero and implicitly initializes <code>wptr</code> as a null <code>weak_ptr</code>. The second constructor takes a reference to <code>StrBlob</code> and an optional index value. This constructor initializes <code>wptr</code> to point to the <code>vector</code> in the <code>shared_ptr</code> of the given <code>StrBlob</code> object and initializes <code>curr</code> to the value of <code>sz</code>. We use a default argument (§ <a href="067-6.5._features_for_specialized_uses.html#filepos1631032">6.5.1</a>, p. <a href="067-6.5._features_for_specialized_uses.html#filepos1631032">236</a>) to initialize <code>curr</code> to denote the first element by default. As we’ll see, the <code>sz</code> parameter will be used by the <code>end</code> member of <code>StrBlob</code>.</p>
<p>It is worth noting that we cannot bind a <code>StrBlobPtr</code> to a <code>const StrBlob</code> object. This restriction follows from the fact that the constructor takes a reference to a non<code>const</code> object of type <code>StrBlob</code>.</p>
<p>The <code>check</code> member of <code>StrBlobPtr</code> differs from the one in <code>StrBlob</code> because it must check whether the <code>vector</code> to which it points is still around:</p>

```c++
std::shared_ptr<std::vector<std::string>>
StrBlobPtr::check(std::size_t i, const std::string &msg) const
{
    auto ret = wptr.lock();   // is the vector still around?
    if (!ret)
        throw std::runtime_error("unbound StrBlobPtr");
    if (i >= ret->size())
        throw std::out_of_range(msg);
    return ret; // otherwise, return a shared_ptr to the vector
}
```

<p><a id="filepos3076977"></a>Because a <code>weak_ptr</code> does not participate in the reference count of its corresponding <code>shared_ptr</code>, the <code>vector</code> to which this <code>StrBlobPtr</code> points might have been deleted. If the <code>vector</code> is gone, <code>lock</code> will return a null pointer. In this case, any reference to the <code>vector</code> will fail, so we throw an exception. Otherwise, <code>check</code> verifies its given index. If that value is okay, <code>check</code> returns the <code>shared_ptr</code> it obtained from <code>lock</code>.</p>
<h5>Pointer Operations</h5>
<p>We’ll learn how to define our own operators in <a href="129-chapter_14._overloaded_operations_and_conversions.html#filepos3544393">Chapter 14</a>. For now, we’ve defined functions named <code>deref</code> and <code>incr</code> to dereference and increment the <code>StrBlobPtr</code>, respectively.</p>
<p>The <code>deref</code> member calls <code>check</code> to verify that it is safe to use the <code>vector</code> and that <code>curr</code> is in range:</p>

```c++
std::string& StrBlobPtr::deref() const
{
    auto p = check(curr, "dereference past end");
    return (*p)[curr];  // (*p) is the vector to which this object points
}
```

<p>If <code>check</code> succeeds, <code>p</code> is a <code>shared_ptr</code> to the <code>vector</code> to which this <code>StrBlobPtr</code> points. The expression <code>(*p)[curr]</code> dereferences that <code>shared_ptr</code> to get the <code>vector</code> and uses the subscript operator to fetch and return the element at <code>curr</code>.</p>
<p>The <code>incr</code> member also calls <code>check</code>:</p>

```c++
// prefix: return a reference to the incremented object
StrBlobPtr& StrBlobPtr::incr()
{
    // if curr already points past the end of the container, can't increment it
    check(curr, "increment past end of StrBlobPtr");
    ++curr;       // advance the current state
    return *this;
}
```

<p>Of course, in order to access the <code>data</code> member, our pointer class will have to be a <code>friend</code> of <code>StrBlob</code> (§ <a href="075-7.3._additional_class_features.html#filepos1906774">7.3.4</a>, p. <a href="075-7.3._additional_class_features.html#filepos1906774">279</a>). We’ll also give our <code>StrBlob</code> class <code>begin</code> and <code>end</code> operations that return a <code>StrBlobPtr</code> pointing to itself:</p>

```c++
// forward declaration needed for friend declaration in StrBlob
class StrBlobPtr;
class StrBlob {
    friend class StrBlobPtr;
    // other members as in § 12.1.1 (p. 456)
    // return StrBlobPtr to the first and one past the last elements
    StrBlobPtr begin() { return StrBlobPtr(*this); }
    StrBlobPtr end()
        { auto ret = StrBlobPtr(*this, data->size());
          return ret; }
};
```

::: info
<a id="filepos3084131"></a><p>Exercises Section 12.1.6</p>
<p><strong>Exercise 12.19:</strong> Define your own version of <code>StrBlobPtr</code> and update your <code>StrBlob</code> class with the appropriate <code>friend</code> declaration and <code>begin</code> and <code>end</code> members.</p>
<p><strong>Exercise 12.20:</strong> Write a program that reads an input file a line at a time into a <code>StrBlob</code> and uses a <code>StrBlobPtr</code> to print each element in that <code>StrBlob</code>.</p>
<p><strong>Exercise 12.21:</strong> We could have written <code>StrBlobPtr</code>’s <code>deref</code> member as follows:</p>

```c++
std::string& deref() const
{ return (*check(curr, "dereference past end"))[curr]; }
```

<p>Which version do you think is better and why?</p>
<p><a id="filepos3086152"></a><strong>Exercise 12.22:</strong> What changes would need to be made to <code>StrBlobPtr</code> to create a class that can be used with a <code>const StrBlob</code>? Define a class named <code>ConstStrBlobPtr</code> that can point to a <code>const StrBlob</code>.</p>
:::

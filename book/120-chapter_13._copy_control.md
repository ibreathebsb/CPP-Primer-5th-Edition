<h2 id="filepos3197881">Chapter 13. Copy Control</h2>
<p>Contents</p><ul><li><strong><a href="121-13.1._copy_assign_and_destroy.html#filepos3202630">Section 13.1 Copy, Assign, and Destroy</a></strong></li><li><strong><a href="122-13.2._copy_control_and_resource_management.html#filepos3281447">Section 13.2 Copy Control and Resource Management</a></strong></li><li><strong><a href="123-13.3._swap.html#filepos3315883">Section 13.3 Swap</a></strong></li><li><strong><a href="124-13.4._a_copycontrol_example.html#filepos3341274">Section 13.4 A Copy-Control Example</a></strong></li><li><strong><a href="125-13.5._classes_that_manage_dynamic_memory.html#filepos3380687">Section 13.5 Classes That Manage Dynamic Memory</a></strong></li><li><strong><a href="126-13.6._moving_objects.html#filepos3426774">Section 13.6 Moving Objects</a></strong></li><li><strong><a href="127-chapter_summary.html#filepos3533220">Chapter Summary</a></strong></li><li><strong><a href="128-defined_terms.html#filepos3534784">Defined Terms</a></strong></li></ul>

<p>As we saw in <a href="072-chapter_7._classes.html#filepos1741323">Chapter 7</a>, each class defines a new type and defines the operations that objects of that type can perform. In that chapter, we also learned that classes can define constructors, which control what happens when objects of the class type are created.</p>
<p>In this chapter we’ll learn how classes can control what happens when objects of the class type are copied, assigned, moved, or destroyed. Classes control these actions through special member functions: the copy constructor, move constructor, copy-assignment operator, move-assignment operator, and destructor.</p>
<p><a id="filepos3200221"></a><em>When we define a class,</em> we specify—explicitly or implicitly—what happens when objects of that class type are copied, moved, assigned, and destroyed. A class controls these operations by defining five special member functions: <strong><a href="128-defined_terms.html#filepos3535874" id="filepos3200484">copy constructor</a></strong>, <strong><a href="128-defined_terms.html#filepos3535314" id="filepos3200563">copy-assignment operator</a></strong>, <strong><a href="128-defined_terms.html#filepos3540251" id="filepos3200650">move constructor</a></strong>, <strong><a href="128-defined_terms.html#filepos3539809" id="filepos3200729">move-assignment operator</a></strong>, and <strong><a href="128-defined_terms.html#filepos3537752" id="filepos3200820">destructor</a></strong>. The copy and move constructors define what happens when an object is initialized from another object of the same type. The copy- and move-assignment operators define what happens when we assign an object of a class type to another object of that same class type. The destructor defines what happens when an object of the type ceases to exist. Collectively, we’ll refer to these operations as <strong><a href="128-defined_terms.html#filepos3536311" id="filepos3201291">copy control</a></strong>.</p>
<p>If a class does not define all of the copy-control members, the compiler automatically defines the missing operations. As a result, many classes can ignore copy control (§ <a href="073-7.1._defining_abstract_data_types.html#filepos1827343">7.1.5</a>, p. <a href="073-7.1._defining_abstract_data_types.html#filepos1827343">267</a>). However, for some classes, relying on the default definitions leads to disaster. Frequently, the hardest part of implementing copy-control operations is recognizing when we need to define them in the first place.</p>

::: warning
<p>Copy control is an essential part of defining any C++ class. Programmers new to C++ are often confused by having to define what happens when objects are copied, moved, assigned, or destroyed. This confusion is compounded because if we do not explicitly define these operations, the compiler defines them for us—although the compiler-defined versions might not behave as we intend.</p>
:::

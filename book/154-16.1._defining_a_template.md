<h3 id="filepos4153781">16.1. Defining a Template</h3>
<p>Imagine that we want to write a function to compare two values and indicate whether the first is less than, equal to, or greater than the second. In practice, we’d want to define several such functions, each of which will compare values of a given type. Our first attempt might be to define several overloaded functions:</p>

```c++
// returns 0 if the values are equal, -1 if v1 is smaller, 1 if v2 is smaller
int compare(const string &v1, const string &v2)
{
    if (v1 < v2) return -1;
    if (v2 < v1) return 1;
    return 0;
}
int compare(const double &v1, const double &v2)
{
    if (v1 < v2) return -1;
    if (v2 < v1) return 1;
    return 0;
}
```

<p>These functions are nearly identical: The only difference between them is the type of their parameters. The function body is the same in each function.</p>
<p>Having to repeat the body of the function for each type that we compare is tedious and error-prone. More importantly, we need to know when we write the program all the types that we might ever want to <code>compare</code>. This strategy cannot work if we want to be able to use the function on types that our users might supply.</p>
<h4 id="filepos4156441">16.1.1. Function Templates</h4>
<img alt="Image" src="/images/00009.jpg"/>
<p>Rather than defining a new function for each type, we can define a <strong><a href="160-defined_terms.html#filepos4551331" id="filepos4156704">function template</a></strong>. A function template is a formula from which we can generate type-specific versions of that function. The template version of <code>compare</code> looks like</p>

```c++
template <typename T>
int compare(const T &v1, const T &v2)
{
    if (v1 < v2) return -1;
    if (v2 < v1) return 1;
    return 0;
}
```

<p><a id="filepos4157570"></a>A template definition starts with the keyword <code>template</code> followed by a <strong><a href="160-defined_terms.html#filepos4555813" id="filepos4157718">template parameter list</a></strong>, which is a comma-separated list of one or more <strong><a href="160-defined_terms.html#filepos4555055" id="filepos4157851">template parameters</a></strong> bracketed by the less-than (<code>&lt;</code>) and greater-than (<code>&gt;</code>) tokens.</p>

::: info
<p>In a template definition, the template parameter list cannot be empty.</p>
:::

<p>The template parameter list acts much like a function parameter list. A function parameter list defines local variable(s) of a specified type but does not say how to initialize them. At run time, arguments are supplied that initialize the parameters.</p>
<p>Analogously, template parameters represent types or values used in the definition of a class or function. When we use a template, we specify—either implicitly or explicitly—<strong><a href="160-defined_terms.html#filepos4554336" id="filepos4159089">template argument(s)</a></strong> to bind to the template parameter(s).</p>
<p>Our <code>compare</code> function declares one type parameter named <code>T</code>. Inside <code>compare</code>, we use the name <code>T</code> to refer to a type. Which <em>actual type</em>
<code>T</code> represents is determined at compile time based on how <code>compare</code> is used.</p>
<h5>Instantiating a Function Template</h5>
<p>When we call a function template, the compiler (ordinarily) uses the arguments of the call to deduce the template argument(s) for us. That is, when we call <code>compare</code>, the compiler uses the type of the arguments to determine what type to bind to the template parameter <code>T</code>. For example, in this call</p>

```c++
cout << compare(1, 0) << endl;       // T is int
```

<p>the arguments have type <code>int</code>. The compiler will deduce <code>int</code> as the template argument and will bind that argument to the template parameter <code>T</code>.</p>
<p>The compiler uses the deduced template parameter(s) to <strong><a href="160-defined_terms.html#filepos4551960" id="filepos4161538">instantiate</a></strong> a specific version of the function for us. When the compiler instantiates a template, it creates a new “instance” of the template using the actual template argument(s) in place of the corresponding template parameter(s). For example, given the calls</p>

```c++
// instantiates int compare(const int&, const int&)
cout << compare(1, 0) << endl;       // T is int
// instantiates int compare(const vector<int>&, const vector<int>&)
vector<int> vec1{1, 2, 3}, vec2{4, 5, 6};
cout << compare(vec1, vec2) << endl; // T is vector<int>
```

<p>the compiler will instantiate two different versions of <code>compare</code>. For the first call, the compiler will write and compile a version of <code>compare</code> with <code>T</code> replaced by <code>int</code>:</p>

```c++
int compare(const int &v1, const int &v2)
{
    if (v1 < v2) return -1;
    if (v2 < v1) return 1;
    return 0;
}
```

<p>For the second call, it will generate a version of <code>compare</code> with <code>T</code> replaced by <code>vector&lt;int&gt;</code>. These compiler-generated functions are generally referred to as an <strong><a href="160-defined_terms.html#filepos4552485" id="filepos4164596">instantiation</a></strong> of the template.</p>
<h5><a id="filepos4164739"></a>Template Type Parameters</h5>
<p>Our <code>compare</code> function has one template <strong><a href="160-defined_terms.html#filepos4557027" id="filepos4164949">type parameter</a></strong>. In general, we can use a type parameter as a type specifier in the same way that we use a built-in or class type specifier. In particular, a type parameter can be used to name the return type or a function parameter type, and for variable declarations or casts inside the function body:</p>

```c++
// ok: same type used for the return type and parameter
template <typename T> T foo(T* p)
{
    T tmp = *p; // tmp will have the type to which p points
    // ...
    return tmp;
}
```

<p>Each type parameter must be preceded by the keyword <code>class</code> or <code>typename</code>:</p>

```c++
// error: must precede U with either typename or class
template <typename T, U> T calc(const T&, const U&);
```

<p>These keywords have the same meaning and can be used interchangeably inside a template parameter list. A template parameter list can use both keywords:</p>

```c++
// ok: no distinction between typename and class in a template parameter list
template <typename T, class U> calc (const T&, const U&);
```

<p>It may seem more intuitive to use the keyword <code>typename</code> rather than <code>class</code> to designate a template type parameter. After all, we can use built-in (nonclass) types as a template type argument. Moreover, <code>typename</code> more clearly indicates that the name that follows is a type name. However, <code>typename</code> was added to C++ after templates were already in widespread use; some programmers continue to use <code>class</code> exclusively.</p>
<h5>Nontype Template Parameters</h5>
<p>In addition to defining type parameters, we can define templates that take <strong><a href="160-defined_terms.html#filepos4552972" id="filepos4169325">nontype parameters</a></strong>. A nontype parameter represents a value rather than a type. Nontype parameters are specified by using a specific type name instead of the <code>class</code> or <code>typename</code> keyword.</p>
<p>When the template is instantiated, nontype parameters are replaced with a value supplied by the user or deduced by the compiler. These values must be constant expressions (§ <a href="024-2.4._const_qualifier.html#filepos520427">2.4.4</a>, p. <a href="024-2.4._const_qualifier.html#filepos520427">65</a>), which allows the compiler to instantiate the templates during compile time.</p>
<p>As an example, we can write a version of <code>compare</code> that will handle string literals. Such literals are arrays of <code>const char</code>. Because we cannot copy an array, we’ll define our parameters as references to an array (§ <a href="064-6.2._argument_passing.html#filepos1499104">6.2.4</a>, p. <a href="064-6.2._argument_passing.html#filepos1499104">217</a>). Because we’d like to be able to compare literals of different lengths, we’ll give our template two nontype parameters. The first template parameter will represent the size of the first array, and the second parameter will represent the size of the second array:</p>
<p><a id="filepos4170906"></a></p>

```c++
template<unsigned N, unsigned M>
int compare(const char (&p1)[N], const char (&p2)[M])
{
    return strcmp(p1, p2);
}
```

<p>When we call this version of <code>compare</code>:</p>

```c++
compare("hi", "mom")
```

<p>the compiler will use the size of the literals to instantiate a version of the template with the sizes substituted for <code>N</code> and <code>M</code>. Remembering that the compiler inserts a null terminator at the end of a string literal (§ <a href="021-2.1._primitive_builtin_types.html#filepos326709">2.1.3</a>, p. <a href="021-2.1._primitive_builtin_types.html#filepos326709">39</a>), the compiler will instantiate</p>

```c++
int compare(const char (&p1)[3], const char (&p2)[4])
```

<p>A nontype parameter may be an integral type, or a pointer or (lvalue) reference to an object or to a function type. An argument bound to a nontype integral parameter must be a constant expression. Arguments bound to a pointer or reference nontype parameter must have static lifetime (<a href="113-chapter_12._dynamic_memory.html#filepos2900383">Chapter 12</a>, p. <a href="113-chapter_12._dynamic_memory.html#filepos2900383">450</a>). We may not use an ordinary (non<code>static</code>) local object or a dynamic object as a template argument for reference or pointer nontype template parameters. A pointer parameter can also be instantiated by <code>nullptr</code> or a zero-valued constant expression.</p>
<p>A template nontype parameter is a constant value inside the template definition. A nontype parameter can be used when constant expressions are required, for example, to specify the size of an array.</p>

::: info
<p>Template arguments used for nontype template parameters must be constant expressions.</p>
:::

<h5><code>inline</code> and <code>constexpr</code> Function Templates</h5>
<p>A function template can be declared <code>inline</code> or <code>constexpr</code> in the same ways as nontemplate functions. The <code>inline</code> or <code>constexpr</code> specifier follows the template parameter list and precedes the return type:</p>

```c++
// ok: inline specifier follows the template parameter list
template <typename T> inline T min(const T&, const T&);
// error: incorrect placement of the inline specifier
inline template <typename T> T min(const T&, const T&);
```

<h5>Writing Type-Independent Code</h5>
<img alt="Image" src="/images/00011.jpg"/>
<p>Simple though it is, our initial <code>compare</code> function illustrates two important principles for writing generic code:</p>
<ul><li>The function parameters in the template are references to <code>const</code>.</li><li>The tests in the body use only <code>&lt;</code> comparisons.</li></ul>

<p><a id="filepos4176665"></a>By making the function parameters references to <code>const</code>, we ensure that our function can be used on types that cannot be copied. Most types—including the built-in types and, except for <code>unique_ptr</code> and the IO types, all the library types we’ve used—do allow copying. However, there can be class types that do not allow copying. By making our parameters references to <code>const</code>, we ensure that such types can be used with our <code>compare</code> function. Moreover, if <code>compare</code> is called with large objects, then this design will also make the function run faster.</p>
<p>You might think it would be more natural for the comparisons to be done using both the <code>&lt;</code> and <code>&gt;</code> operators:</p>

```c++
// expected comparison
if (v1 < v2) return -1;
if (v1 > v2) return 1;
return 0;
```

<p>However, by writing the code using only the <code>&lt;</code> operator, we reduce the requirements on types that can be used with our <code>compare</code> function. Those types must support <code>&lt;</code>, but they need not also support <code>&gt;</code>.</p>
<p>In fact, if we were truly concerned about type independence and portability, we probably should have defined our function using the <code>less</code> (§ <a href="137-14.8._functioncall_operator.html#filepos3679636">14.8.2</a>, p. <a href="137-14.8._functioncall_operator.html#filepos3679636">575</a>):</p>

```c++
// version of compare that will be correct even if used on pointers; see § 14.8.2 (p. 575)
template <typename T> int compare(const T &v1, const T &v2)
{
    if (less<T>()(v1, v2)) return -1;
    if (less<T>()(v2, v1)) return 1;
    return 0;
}
```

<p>The problem with our original version is that if a user calls it with two pointers and those pointers do not point to the same array, then our code is undefined.</p>

::: tip
<p>Best Practices</p>
<p>Template programs should try to minimize the number of requirements placed on the argument types.</p>
:::

<h5>Template Compilation</h5>
<img alt="Image" src="/images/00011.jpg"/>
<p>When the compiler sees the definition of a template, it does not generate code. It generates code only when we instantiate a specific instance of the template. The fact that code is generated only when we use a template (and not when we define it) affects how we organize our source code and when errors are detected.</p>
<p>Ordinarily, when we call a function, the compiler needs to see only a declaration for the function. Similarly, when we use objects of class type, the class definition must be available, but the definitions of the member functions need not be present. As a result, we put class definitions and function declarations in header files and definitions of ordinary and class-member functions in source files.</p>
<p>Templates are different: To generate an instantiation, the compiler needs to have the code that defines a function template or class template member function. As a result, unlike nontemplate code, headers for templates typically include definitions as well as declarations</p>

::: info
<a id="filepos4181999"></a>
<p>Definitions of function templates and member functions of class templates are ordinarily put into header files.</p>
:::

::: info
<p>Key Concept: Templates and Headers</p>
<p>Templates contain two kinds of names:</p>
<ul>
    <li>Those that do not depend on a template parameter</li>
    <li>Those that do depend on a template parameter</li>
</ul>
<p>It is up to the provider of a template to ensure that all names that do not depend on a template parameter are visible when the template is used. Moreover, the template provider must ensure that the definition of the template, including the definitions of the members of a class template, are visible when the template is instantiated.</p>
<p>It is up to <em>users</em> of a template to ensure that declarations for all functions, types, and operators associated with the types used to instantiate the template are visible.</p>
<p>Both of these requirements are easily satisfied by well-structured programs that make appropriate use of headers. Authors of templates should provide a header that contains the template definition along with declarations for all the names used in the class template or in the definitions of its members. Users of the template must include the header for the template and for any types used to instantiate that template.</p>
:::

<h5>Compilation Errors Are Mostly Reported during Instantiation</h5>
<p>The fact that code is not generated until a template is instantiated affects when we learn about compilation errors in the code inside the template. In general, there are three stages during which the compiler might flag an error.</p>
<p>The first stage is when we compile the template itself. The compiler generally can’t find many errors at this stage. The compiler can detect syntax errors—such as forgetting a semicolon or misspelling a variable name—but not much else.</p>
<p>The second error-detection time is when the compiler sees a use of the template. At this stage, there is still not much the compiler can check. For a call to a function template, the compiler typically will check that the number of the arguments is appropriate. It can also detect whether two arguments that are supposed to have the same type do so. For a class template, the compiler can check that the right number of template arguments are provided but not much more.</p>
<p>The third time when errors are detected is during instantiation. It is only then that type-related errors can be found. Depending on how the compiler manages instantiation, these errors may be reported at link time.</p>
<p>When we write a template, the code may not be overtly type specific, but template code usually makes some assumptions about the types that will be used. For example, the code inside our original <code>compare</code> function:</p>

```c++
if (v1 < v2) return -1;  // requires < on objects of type T
if (v2 < v1) return 1;   // requires < on objects of type T
return 0;                // returns int; not dependent on T
```

<p><a id="filepos4187356"></a>assumes that the argument type has a <code>&lt;</code> operator. When the compiler processes the body of this template, it cannot verify whether the conditions in the <code>if</code> statements are legal. If the arguments passed to <code>compare</code> have a <code>&lt;</code> operation, then the code is fine, but not otherwise. For example,</p>

```c++
Sales_data data1, data2;
cout << compare(data1, data2) << endl; // error: no < on Sales_data
```

<p>This call instantiates a version of <code>compare</code> with <code>T</code> replaced by <code>Sales_data</code>. The <code>if</code> conditions attempt to use <code>&lt;</code> on <code>Sales_data</code> objects, but there is no such operator. This instantiation generates a version of the function that will not compile. However, errors such as this one cannot be detected until the compiler instantiates the definition of <code>compare</code> on type <code>Sales_data</code>.</p>

::: warning
<p>It is up to the caller to guarantee that the arguments passed to the template support any operations that template uses, and that those operations behave correctly in the context in which the template uses them.</p>
:::

::: info
<p>Exercises Section 16.1.1</p>
<p><strong>Exercise 16.1:</strong> Define instantiation.</p>
<p><strong>Exercise 16.2:</strong> Write and test your own versions of the <code>compare</code> functions.</p>
<p><strong>Exercise 16.3:</strong> Call your <code>compare</code> function on two <code>Sales_data</code> objects to see how your compiler handles errors during instantiation.</p>
<p><strong>Exercise 16.4:</strong> Write a template that acts like the library <code>find</code> algorithm. The function will need two template type parameters, one to represent the function’s iterator parameters and the other for the type of the value. Use your function to find a given value in a <code>vector&lt;int&gt;</code> and in a <code>list&lt;string&gt;</code>.</p>
<p><strong>Exercise 16.5:</strong> Write a template version of the <code>print</code> function from § <a href="064-6.2._argument_passing.html#filepos1499104">6.2.4</a> (p. <a href="064-6.2._argument_passing.html#filepos1499104">217</a>) that takes a reference to an array and can handle arrays of any size and any element type.</p>
<p><strong>Exercise 16.6:</strong> How do you think the library <code>begin</code> and <code>end</code> functions that take an array argument work? Define your own versions of these functions.</p>
<p><strong>Exercise 16.7:</strong> Write a <code>constexpr</code> template that returns the size of a given array.</p>
<p><strong>Exercise 16.8:</strong> In the “Key Concept” box on page <a href="033-3.4._introducing_iterators.html#filepos815330">108</a>, we noted that as a matter of habit C++ programmers prefer using <code>!=</code> to using <code>&lt;</code>. Explain the rationale for this habit.</p>
:::

<h4 id="filepos4193169">16.1.2. Class Templates</h4>
<img alt="Image" src="/images/00009.jpg"/>
<p>A <strong><a href="160-defined_terms.html#filepos4549024" id="filepos4193364">class template</a></strong> is a blueprint for generating classes. Class templates differ from function templates in that the compiler cannot deduce the template parameter type(s) for a class template. Instead, as we’ve seen many times, to use a class template we must supply additional information inside angle brackets following <a id="filepos4193741"></a>the template’s name (§ <a href="032-3.3._library_vector_type.html#filepos736471">3.3</a>, p. <a href="032-3.3._library_vector_type.html#filepos736471">97</a>). That extra information is the list of template arguments to use in place of the template parameters.</p>
<h5>Defining a Class Template</h5>
<p>As an example, we’ll implement a template version of <code>StrBlob</code> (§ <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos2907541">12.1.1</a>, p. <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos2907541">456</a>). We’ll name our template <code>Blob</code> to indicate that it is no longer specific to <code>string</code>s. Like <code>StrBlob</code>, our template will provide shared (and checked) access to the elements it holds. Unlike that class, our template can be used on elements of pretty much any type. As with the library containers, our users will have to specify the element type when they use a <code>Blob</code>.</p>
<p>Like function templates, class templates begin with the keyword <code>template</code> followed by a template parameter list. In the definition of the class template (and its members), we use the template parameters as stand-ins for types or values that will be supplied when the template is used:</p>

```c++
template <typename T> class Blob {
public:
    typedef T value_type;
    typedef typename std::vector<T>::size_type size_type;
    // constructors
    Blob();
    Blob(std::initializer_list<T> il);
    // number of elements in the Blob
    size_type size() const { return data->size(); }
    bool empty() const { return data->empty(); }
    // add and remove elements
    void push_back(const T &t) {data->push_back(t);}
    // move version; see § 13.6.3 (p. 548)
    void push_back(T &&t) { data->push_back(std::move(t)); }
    void pop_back();
    // element access
    T& back();
    T& operator[](size_type i); // defined in § 14.5 (p. 566)
private:
    std::shared_ptr<std::vector<T>> data;
    // throws msg if data[i] isn't valid
    void check(size_type i, const std::string &msg) const;
};
```

<p>Our <code>Blob</code> template has one template type parameter, named <code>T</code>. We use the type parameter anywhere we refer to the element type that the <code>Blob</code> holds. For example, we define the return type of the operations that provide access to the elements in the <code>Blob</code> as <code>T&amp;</code>. When a user instantiates a <code>Blob</code>, these uses of <code>T</code> will be replaced by the specified template argument type.</p>
<p>With the exception of the template parameter list, and the use of <code>T</code> instead of <code>string</code>, this class is the same as the version we defined in § <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos2907541">12.1.1</a> (p. <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos2907541">456</a>) and updated in § <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos3062321">12.1.6</a> (p. <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos3062321">475</a>) and in <a href="120-chapter_13._copy_control.html#filepos3197881">Chapters 13</a> and <a href="129-chapter_14._overloaded_operations_and_conversions.html#filepos3544393">14</a>.</p>
<h5><a id="filepos4199389"></a>Instantiating a Class Template</h5>
<p>As we’ve seen many times, when we use a class template, we must supply extra information. We can now see that that extra information is a list of <strong>explicit template arguments</strong> that are bound to the template’s parameters. The compiler uses these template arguments to instantiate a specific class from the template.</p>
<p>For example, to define a type from our <code>Blob</code> template, we must provide the element type:</p>

```c++
Blob<int> ia;                // empty Blob<int>
Blob<int> ia2 = {0,1,2,3,4}; // Blob<int> with five elements
```

<p>Both <code>ia</code> and <code>ia2</code> use the same type-specific version of <code>Blob</code> (i.e., <code>Blob&lt;int&gt;</code>). From these definitions, the compiler will instantiate a class that is equivalent to</p>

```c++
template <> class Blob<int> {
    typedef typename std::vector<int>::size_type size_type;
    Blob();
    Blob(std::initializer_list<int> il);
    // ...
    int& operator[](size_type i);
private:
    std::shared_ptr<std::vector<int>> data;
    void check(size_type i, const std::string &msg) const;
};
```

<p>When the compiler instantiates a class from our <code>Blob</code> template, it rewrites the <code>Blob</code> template, replacing each instance of the template parameter <code>T</code> by the given template argument, which in this case is <code>int</code>.</p>
<p>The compiler generates a different class for each element type we specify:</p>

```c++
// these definitions instantiate two distinct Blob types
Blob<string> names; // Blob that holds strings
Blob<double> prices;// different element type
```

<p>These definitions would trigger instantiations of two distinct classes: The definition of <code>names</code> creates a <code>Blob</code> class in which each occurrence of <code>T</code> is replaced by <code>string</code>. The definition of <code>prices</code> generates a <code>Blob</code> with <code>T</code> replaced by <code>double</code>.</p>

::: info
<p>Each instantiation of a class template constitutes an independent class. The type <code>Blob&lt;string&gt;</code> has no relationship to, or any special access to, the members of any other <code>Blob</code> type.</p>
:::

<h5>References to a Template Type in the Scope of the Template</h5>
<img alt="Image" src="/images/00011.jpg"/>
<p>In order to read template class code, it can be helpful to remember that the name of a class template is not the name of a type (§ <a href="032-3.3._library_vector_type.html#filepos736471">3.3</a>, p. <a href="032-3.3._library_vector_type.html#filepos736471">97</a>). A class template is used to instantiate a type, and an instantiated type always includes template argument(s).</p>
<p>What can be confusing is that code in a class template generally doesn’t use the name of an actual type (or value) as a template argument. Instead, we often use the template’s own parameter(s) as the template argument(s). For example, our <a id="filepos4206136"></a><code>data</code> member uses two templates, <code>vector</code> and <code>shared_ptr</code>. Whenever we use a template, we must supply template arguments. In this case, the template argument we supply is the same type that is used to instantiate the <code>Blob</code>. Therefore, the definition of <code>data</code></p>

```c++
std::shared_ptr<std::vector<T>> data;
```

<p>uses <code>Blob</code>’s type parameter to say that <code>data</code> is the instantiation of <code>shared_ptr</code> that points to the instantiation of <code>vector</code> that holds objects of type <code>T</code>. When we instantiate a particular kind of <code>Blob</code>, such as <code>Blob&lt;string&gt;</code>, then <code>data</code> will be</p>

```c++
shared_ptr<vector<string>>
```

<p>If we instantiate <code>Blob&lt;int&gt;</code>, then <code>data</code> will be <code>shared_ptr&lt;vector&lt;int&gt;&gt;</code>, and so on.</p>
<h5>Member Functions of Class Templates</h5>
<p>As with any class, we can define the member functions of a class template either inside or outside of the class body. As with any other class, members defined inside the class body are implicitly inline.</p>
<p>A class template member function is itself an ordinary function. However, each instantiation of the class template has its own version of each member. As a result, a member function of a class template has the same template parameters as the class itself. Therefore, a member function defined outside the class template body starts with the keyword <code>template</code> followed by the class’ template parameter list.</p>
<p>As usual, when we define a member outside its class, we must say to which class the member belongs. Also as usual, the name of a class generated from a template includes its template arguments. When we define a member, the template argument(s) are the same as the template parameter(s). That is, for a given member function of <code>StrBlob</code> that was defined as</p>

```c++
ret-type StrBlob::member-name(parm-list)
```

<p>the corresponding <code>Blob</code> member will look like</p>

```c++
template <typename T>
ret-type Blob<T>::member-name(parm-list)
```

<h5>The <code>check</code> and Element Access Members</h5>
<p>We’ll start by defining the <code>check</code> member, which verifies a given index:</p>

```c++
template <typename T>
void Blob<T>::check(size_type i, const std::string &msg) const
{
    if (i >= data->size())
        throw std::out_of_range(msg);
}
```

<p>Aside from the differences in the class name and the use of the template parameter list, this function is identical to the original <code>StrBlob</code> member.</p>
<p>The subscript operator and <code>back</code> function use the template parameter to specify the return type but are otherwise unchanged:</p>
<p><a id="filepos4212631"></a></p>

```c++
template <typename T>
T& Blob<T>::back()
{
    check(0, "back on empty Blob");
    return data->back();
}
template <typename T>
T& Blob<T>::operator[](size_type i)
{
    // if i is too big, check will throw, preventing access to a nonexistent element
    check(i, "subscript out of range");
    return (*data)[i];
}
```

<p>In our original <code>StrBlob</code> class these operators returned <code>string&amp;</code>. The template versions will return a reference to whatever type is used to instantiate <code>Blob</code>.</p>
<p>The <code>pop_back</code> function is nearly identical to our original <code>StrBlob</code> member:</p>

```c++
template <typename T> void Blob<T>::pop_back()
{
    check(0, "pop_back on empty Blob");
    data->pop_back();
}
```

<p>The subscript operator and <code>back</code> members are overloaded on <code>const</code>. We leave the definition of these members, and of the <code>front</code> members, as an exercise.</p>
<h5><code>Blob</code> Constructors</h5>
<p>As with any other member defined outside a class template, a constructor starts by declaring the template parameters for the class template of which it is a member:</p>

```c++
template <typename T>
Blob<T>::Blob(): data(std::make_shared<std::vector<T>>()) { }
```

<p>Here we are defining the member named <code>Blob</code> in the scope of <code>Blob&lt;T&gt;</code>. Like our <code>StrBlob</code> default constructor (§ <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos2907541">12.1.1</a>, p. <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos2907541">456</a>), this constructor allocates an empty <code>vector</code> and stores the pointer to that <code>vector</code> in <code>data</code>. As we’ve seen, we use the class’ own type parameter as the template argument of the <code>vector</code> we allocate.</p>
<p>Similarly, the constructor that takes an <code>initializer_list</code> uses its type parameter <code>T</code> as the element type for its <code>initializer_list</code> parameter:</p>

```c++
template <typename T>
Blob<T>::Blob(std::initializer_list<T> il):
              data(std::make_shared<std::vector<T>>(il)) { }
```

<p>Like the default constructor, this constructor allocates a new <code>vector</code>. In this case, we initialize that <code>vector</code> from the parameter, <code>il</code>.</p>
<p>To use this constructor, we must pass an <code>initializer_list</code> in which the elements are compatible with the element type of the <code>Blob</code>:</p>

```c++
Blob<string> articles = {"a", "an", "the"};
```

<p>The parameter in this constructor has type <code>initializer_list&lt;string&gt;</code>. Each string literal in the list is implicitly converted to <code>string</code>.</p>
<h5><a id="filepos4219319"></a>Instantiation of Class-Template Member Functions</h5>
<p>By default, a member function of a class template is instantiated <em>only</em> if the program uses that member function. For example, this code</p>

```c++
// instantiates Blob<int> and the initializer_list<int> constructor
Blob<int> squares = {0,1,2,3,4,5,6,7,8,9};
// instantiates Blob<int>::size() const
for (size_t i = 0; i != squares.size(); ++i)
    squares[i] = i*i; // instantiates Blob<int>::operator[](size_t)
```

<p>instantiates the <code>Blob&lt;int&gt;</code> class and three of its member functions: <code>operator[]</code>, <code>size</code>, and the <code>initializer_list&lt;int&gt;</code> constructor.</p>
<p>If a member function isn’t used, it is not instantiated. The fact that members are instantiated only if we use them lets us instantiate a class with a type that may not meet the requirements for some of the template’s operations (§ <a href="090-9.2._container_library_overview.html#filepos2188055">9.2</a>, p. <a href="090-9.2._container_library_overview.html#filepos2188055">329</a>).</p>

::: info
<p>By default, a member of an instantiated class template is instantiated only if the member is used.</p>
:::

<h5>Simplifying Use of a Template Class Name inside Class Code</h5>
<p>There is one exception to the rule that we must supply template arguments when we use a class template type. Inside the scope of the class template itself, we may use the name of the template without arguments:</p>

```c++
// BlobPtr throws an exception on attempts to access a nonexistent element
template <typename T> class BlobPtr
public:
    BlobPtr(): curr(0) { }
    BlobPtr(Blob<T> &a, size_t sz = 0):
            wptr(a.data), curr(sz) { }
    T& operator*() const
    { auto p = check(curr, "dereference past end");
      return (*p)[curr];  // (*p) is the vector to which this object points
    }
    // increment and decrement
    BlobPtr& operator++();        // prefix operators
    BlobPtr& operator--();
private:
    // check returns a shared_ptr to the vector if the check succeeds
    std::shared_ptr<std::vector<T>>
        check(std::size_t, const std::string&) const;
    // store a weak_ptr, which means the underlying vector might be destroyed
    std::weak_ptr<std::vector<T>> wptr;
    std::size_t curr;      // current position within the array
};
```

<p>Careful readers will have noted that the prefix increment and decrement members of <code>BlobPtr</code> return <code>BlobPtr&amp;</code>, not <code>BlobPtr&lt;T&gt;&amp;</code>. When we are inside the scope of a class template, the compiler treats references to the template itself as if we had <a id="filepos4226009"></a>supplied template arguments matching the template’s own parameters. That is, it is as if we had written:</p>

```c++
BlobPtr<T>& operator++();
BlobPtr<T>& operator--();
```

<h5>Using a Class Template Name outside the Class Template Body</h5>
<p>When we define members outside the body of a class template, we must remember that we are not in the scope of the class until the class name is seen (§ <a href="076-7.4._class_scope.html#filepos1923787">7.4</a>, p. <a href="076-7.4._class_scope.html#filepos1923787">282</a>):</p>

```c++
// postfix: increment/decrement the object but return the unchanged value
template <typename T>
BlobPtr<T> BlobPtr<T>::operator++(int)
{
    // no check needed here; the call to prefix increment will do the check
    BlobPtr ret = *this;  // save the current value
    ++*this;    // advance one element; prefix ++ checks the increment
    return ret;  // return the saved state
}
```

<p>Because the return type appears outside the scope of the class, we must specify that the return type returns a <code>BlobPtr</code> instantiated with the same type as the class. Inside the function body, we are in the scope of the class so do not need to repeat the template argument when we define <code>ret</code>. When we do not supply template arguments, the compiler assumes that we are using the same type as the member’s instantiation. Hence, the definition of <code>ret</code> is as if we had written:</p>

```c++
BlobPtr<T> ret = *this;
```

::: info
<p>Inside the scope of a class template, we may refer to the template without specifying template argument(s).</p>
:::

<h5>Class Templates and Friends</h5>
<p>When a class contains a friend declaration (§ <a href="074-7.2._access_control_and_encapsulation.html#filepos1841962">7.2.1</a>, p. <a href="074-7.2._access_control_and_encapsulation.html#filepos1841962">269</a>), the class and the friend can independently be templates or not. A class template that has a nontemplate friend grants that friend access to all the instantiations of the template. When the friend is itself a template, the class granting friendship controls whether friendship includes all instantiations of the template or only specific instantiation(s).</p>
<h5>One-to-One Friendship</h5>
<p>The most common form of friendship from a class template to another template (class or function) establishes friendship between corresponding instantiations of the class and its friend. For example, our <code>Blob</code> class should declare the <code>BlobPtr</code> class and a template version of the <code>Blob</code> equality operator (originally defined for <code>StrBlob</code> in the exercises in § <a href="132-14.3._arithmetic_and_relational_operators.html#filepos3601039">14.3.1</a> (p. <a href="132-14.3._arithmetic_and_relational_operators.html#filepos3601039">562</a>)) as friends.</p>
<p>In order to refer to a specific instantiation of a template (class or function) we must first declare the template itself. A template declaration includes the template’s template parameter list:</p>
<p><a id="filepos4231180"></a></p>

```c++
// forward declarations needed for friend declarations in Blob
template <typename> class BlobPtr;
template <typename> class Blob; // needed for parameters in operator==
template <typename T>
    bool operator==(const Blob<T>&, const Blob<T>&);
template <typename T> class Blob {
    // each instantiation of Blob grants access to the version of
    // BlobPtr and the equality operator instantiated with the same type
    friend class BlobPtr<T>;
    friend bool operator==<T>
           (const Blob<T>&, const Blob<T>&);
    // other members as in § 12.1.1 (p. 456)
};
```

<p>We start by declaring that <code>Blob</code>, <code>BlobPtr</code>, and <code>operator==</code> are templates. These declarations are needed for the parameter declaration in the <code>operator==</code> function and the friend declarations in <code>Blob</code>.</p>
<p>The friend declarations use <code>Blob</code>’s template parameter as their own template argument. Thus, the friendship is restricted to those instantiations of <code>BlobPtr</code> and the equality operator that are instantiated with the same type:</p>

```c++
Blob<char> ca; // BlobPtr<char> and operator==<char> are friends
Blob<int> ia;  // BlobPtr<int> and operator==<int> are friends
```

<p>The members of <code>BlobPtr&lt;char&gt;</code> may access the non<code>public</code> parts of <code>ca</code> (or any other <code>Blob&lt;char&gt;</code> object), but <code>ca</code> has no special access to <code>ia</code> (or any other <code>Blob&lt;int&gt;)</code> or to any other instantiation of <code>Blob</code>.</p>
<h5>General and Specific Template Friendship</h5>
<p>A class can also make every instantiation of another template its friend, or it may limit friendship to a specific instantiation:</p>

```c++
// forward declaration necessary to befriend a specific instantiation of a template
template <typename T> class Pal;
class C {  //  C is an ordinary, nontemplate class
    friend class Pal<C>;  // Pal instantiated with class C is a friend to C
    // all instances of Pal2 are friends to C;
    // no forward declaration required when we befriend all instantiations
    template <typename T> friend class Pal2;
};
template <typename T> class C2 { // C2 is itself a class template
    // each instantiation of C2 has the same instance of Pal as a friend
    friend class Pal<T>;  // a template declaration for Pal must be in scope
    // all instances of Pal2 are friends of each instance of C2, prior declaration needed
    template <typename X> friend class Pal2;
    // Pal3 is a nontemplate class that is a friend of every instance of C2
    friend class Pal3;    // prior declaration for Pal3 not needed
};
```

<p>To allow all instantiations as friends, the friend declaration must use template parameter(s) that differ from those used by the class itself.</p>
<h5><a id="filepos4240095"></a>Befriending the Template’s Own Type Parameter</h5>
<a id="filepos4240204"></a><img alt="Image" src="/images/00008.jpg"/>
<p>Under the new standard, we can make a template type parameter a friend:</p>

```c++
template <typename Type> class Bar {
friend Type; // grants access to the type used to instantiate Bar
    //  ...
};
```

<p>Here we say that whatever type is used to instantiate <code>Bar</code> is a friend. Thus, for some type named <code>Foo, Foo</code> would be a friend of <code>Bar&lt;Foo&gt;, Sales_data</code> a friend of <code>Bar&lt;Sales_data&gt;</code>, and so on.</p>
<p>It is worth noting that even though a friend ordinarily must be a class or a function, it is okay for <code>Bar</code> to be instantiated with a built-in type. Such friendship is allowed so that we can instantiate classes such as <code>Bar</code> with built-in types.</p>
<h5>Template Type Aliases</h5>
<p>An instantiation of a class template defines a class type, and as with any other class type, we can define a <code>typedef</code> (§ <a href="025-2.5._dealing_with_types.html#filepos536134">2.5.1</a>, p. <a href="025-2.5._dealing_with_types.html#filepos536134">67</a>) that refers to that instantiated class:</p>

```c++
typedef Blob<string> StrBlob;
```

<p>This <code>typedef</code> will let us run the code we wrote in § <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos2907541">12.1.1</a> (p. <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos2907541">456</a>) using our template version of <code>Blob</code> instantiated with <code>string</code>. Because a template is not a type, we cannot define a <code>typedef</code> that refers to a template. That is, there is no way to define a <code>typedef</code> that refers to <code>Blob&lt;T&gt;</code>.</p>
<a id="filepos4243350"></a><img alt="Image" src="/images/00008.jpg"/>
<p>However, the new standard lets us define a type alias for a class template:</p>

```c++
template<typename T> using twin = pair<T, T>;
twin<string> authors; // authors is a pair<string, string>
```

<p>Here we’ve defined <code>twin</code> as a synonym for <code>pair</code>s in which the members have the same type. Users of <code>twin</code> need to specify that type only once.</p>
<p>A template type alias is a synonym for a family of classes:</p>

```c++
twin<int> win_loss;  // win_loss is a pair<int, int>
twin<double> area;   // area is a pair<double, double>
```

<p>Just as we do when we use a class template, when we use <code>twin</code>, we specify which particular kind of <code>twin</code> we want.</p>
<p>When we define a template type alias, we can fix one or more of the template parameters:</p>

```c++
template <typename T> using partNo = pair<T, unsigned>;
partNo<string> books;  // books is a pair<string, unsigned>
partNo<Vehicle> cars;  // cars is a pair<Vehicle, unsigned>
partNo<Student> kids;  // kids is a pair<Student, unsigned>
```

<p>Here we’ve defined <code>partNo</code> as a synonym for the family of types that are <code>pair</code>s in which the <code>second</code> member is an <code>unsigned</code>. Users of <code>partNo</code> specify a type for the <code>first</code> member of the <code>pair</code> but have no choice about <code>second</code>.</p>
<h5><a id="filepos4248140"></a><code>static</code> Members of Class Templates</h5>
<p>Like any other class, a class template can declare <code>static</code> members (§ <a href="078-7.6._static_class_members.html#filepos2028441">7.6</a>, p. <a href="078-7.6._static_class_members.html#filepos2028441">300</a>):</p>

```c++
template <typename T> class Foo {
public:
   static std::size_t count() { return ctr; }
   // other interface members
private:
   static std::size_t ctr;
   // other implementation members
};
```

<p>Here <code>Foo</code> is a class template that has a <code>public static</code> member function named <code>count</code> and a <code>private static</code> data member named <code>ctr</code>. Each instantiation of <code>Foo</code> has its own instance of the <code>static</code> members. That is, for any given type <code>X</code>, there is one <code>Foo&lt;X&gt;::ctr</code> and one <code>Foo&lt;X&gt;::count</code> member. All objects of type <code>Foo&lt;X&gt;</code> share the same <code>ctr</code> object and <code>count</code> function. For example,</p>

```c++
// instantiates static members Foo<string>::ctr and Foo<string>::count
Foo<string> fs;
// all three objects share the same Foo<int>::ctr and Foo<int>::count members
Foo<int> fi, fi2, fi3;
```

<p>As with any other <code>static</code> data member, there must be exactly one definition of each <code>static</code> data member of a template class. However, there is a distinct object for each instantiation of a class template. As a result, we define a <code>static</code> data member as a template similarly to how we define the member functions of that template:</p>

```c++
template <typename T>
size_t Foo<T>::ctr = 0; // define and initialize ctr
```

<p>As with any other member of a class template, we start by defining the template parameter list, followed by the type of the member we are defining and the member’s name. As usual, a member’s name includes the member’s class name, which for a class generated from a template includes its template arguments. Thus, when <code>Foo</code> is instantiated for a particular template argument type, a separate <code>ctr</code> will be instantiated for that class type and initialized to <code>0</code>.</p>
<p>As with static members of nontemplate classes, we can access a <code>static</code> member of a class template through an object of the class type or by using the scope operator to access the member directly. Of course, to use a <code>static</code> member through the class, we must refer to a specific instantiation:</p>

```c++
Foo<int> fi;                 // instantiates Foo<int> class
                             // and the static data member ctr
auto ct = Foo<int>::count(); // instantiates Foo<int>::count
ct = fi.count();             // uses Foo<int>::count
ct = Foo::count();           // error: which template instantiation?
```

<p>Like any other member function, a <code>static</code> member function is instantiated only if it is used in a program.</p>

::: info
<a id="filepos4256148"></a><p>Exercises Section 16.1.2</p>
<p><strong>Exercise 16.9:</strong> What is a function template? What is a class template?</p>
<p><strong>Exercise 16.10:</strong> What happens when a class template is instantiated?</p>
<p><strong>Exercise 16.11:</strong> The following definition of <code>List</code> is incorrect. How would you fix it?</p>

```c++
template <typename elemType> class ListItem;
template <typename elemType> class List {
public:
    List<elemType>();
    List<elemType>(const List<elemType> &);
    List<elemType>& operator=(const List<elemType> &);
    ~List();
    void insert(ListItem *ptr, elemType value);
private:
    ListItem *front, *end;
};
```

<p><strong>Exercise 16.12:</strong> Write your own version of the <code>Blob</code> and <code>BlobPtr</code> templates. including the various <code>const</code> members that were not shown in the text.</p>
<p><strong>Exercise 16.13:</strong> Explain which kind of friendship you chose for the equality and relational operators for <code>BlobPtr</code>.</p>
<p><strong>Exercise 16.14:</strong> Write a <code>Screen</code> class template that uses nontype parameters to define the height and width of the <code>Screen</code>.</p>
<p><strong>Exercise 16.15:</strong> Implement input and output operators for your <code>Screen</code> template. Which, if any, friends are necessary in class <code>Screen</code> to make the input and output operators work? Explain why each friend declaration, if any, was needed.</p>
<p><strong>Exercise 16.16:</strong> Rewrite the <code>StrVec</code> class (§ <a href="125-13.5._classes_that_manage_dynamic_memory.html#filepos3380687">13.5</a>, p. <a href="125-13.5._classes_that_manage_dynamic_memory.html#filepos3380687">526</a>) as a template named <code>Vec</code>.</p>
:::

<h4 id="filepos4259709">16.1.3. Template Parameters</h4>
<img alt="Image" src="/images/00009.jpg"/>
<p>Like the names of function parameters, a template parameter name has no intrinsic meaning. We ordinarily name type parameters <code>T</code>, but we can use any name:</p>

```c++
template <typename Foo> Foo calc(const Foo& a, const Foo& b)
{
    Foo tmp = a; // tmp has the same type as the parameters and return type
    // ...
    return tmp;  // return type and parameters have the same type
}
```

<h5>Template Parameters and Scope</h5>
<p>Template parameters follow normal scoping rules. The name of a template parameter can be used after it has been declared and until the end of the template declaration or definition. As with any other name, a template parameter hides any <a id="filepos4261375"></a>declaration of that name in an outer scope. Unlike most other contexts, however, a name used as a template parameter may not be reused within the template:</p>

```c++
typedef double A;
template <typename A, typename B> void f(A a, B b)
{
    A tmp = a; // tmp has same type as the template parameter A, not double
    double B;  // error: redeclares template parameter B
}
```

<p>Normal name hiding says that the <code>typedef</code> of <code>A</code> is hidden by the type parameter named <code>A</code>. Thus, <code>tmp</code> is not a <code>double</code>; it has whatever type gets bound to the template parameter <code>A</code> when <code>calc</code> is used. Because we cannot reuse names of template parameters, the declaration of the variable named <code>B</code> is an error.</p>
<p>Because a parameter name cannot be reused, the name of a template parameter can appear only once with in a given template parameter list:</p>

```c++
// error: illegal reuse of template parameter name V
template <typename V, typename V> // ...
```

<h5>Template Declarations</h5>
<p>A template declaration must include the template parameters :</p>

```c++
// declares but does not define compare and Blob
template <typename T> int compare(const T&, const T&);
template <typename T> class Blob;
```

<p>As with function parameters, the names of a template parameter need not be the same across the declaration(s) and the definition of the same template:</p>

```c++
// all three uses of calc refer to the same function template
template <typename T> T calc(const T&, const T&); // declaration
template <typename U> U calc(const U&, const U&); // declaration
// definition of the template
template <typename Type>
Type calc(const Type& a, const Type& b) { /* . . . */ }
```

<p>Of course, every declaration and the definition of a given template must have the same number and kind (i.e., type or nontype) of parameters.</p>

::: tip
<p>Best Practices</p>
<p>For reasons we’ll explain in § <a href="156-16.3._overloading_and_templates.html#filepos4436613">16.3</a> (p. <a href="156-16.3._overloading_and_templates.html#filepos4436613">698</a>), declarations for all the templates needed by a given file usually should appear together at the beginning of a file before any code that uses those names.</p>
:::

<h5>Using Class Members That Are Types</h5>
<p>Recall that we use the scope operator (<code>::</code>) to access both <code>static</code> members and type members (§ <a href="076-7.4._class_scope.html#filepos1923787">7.4</a>, p. <a href="076-7.4._class_scope.html#filepos1923787">282</a>, and § <a href="078-7.6._static_class_members.html#filepos2028441">7.6</a>, p. <a href="078-7.6._static_class_members.html#filepos2028441">301</a>). In ordinary (nontemplate) code, the compiler has access to the class defintion. As a result, it knows whether a name accessed through the scope operator is a type or a <code>static</code> member. For example, <a id="filepos4268006"></a>when we write <code>string::size_type</code>, the compiler has the definition of <code>string</code> and can see that <code>size_type</code> is a type.</p>
<p>Assuming <code>T</code> is a template type parameter, When the compiler sees code such as <code>T::mem</code> it won’t know until instantiation time whether <code>mem</code> is a type or a <code>static</code> data member. However, in order to process the template, the compiler must know whether a name represents a type. For example, assuming <code>T</code> is the name of a type parameter, when the compiler sees a statement of the following form:</p>

```c++
T::size_type * p;
```

<p>it needs to know whether we’re defining a variable named <code>p</code> or are multiplying a <code>static</code> data member named <code>size_type</code> by a variable named <code>p</code>.</p>
<p>By default, the language assumes that a name accessed through the scope operator is not a type. As a result, if we want to use a type member of a template type parameter, we must explicitly tell the compiler that the name is a type. We do so by using the keyword <code>typename</code>:</p>

```c++
template <typename T>
typename T::value_type top(const T& c)
{
    if (!c.empty())
        return c.back();
    else
        return typename T::value_type();
}
```

<p>Our <code>top</code> function expects a container as its argument and uses <code>typename</code> to specify its return type and to generate a value initialized element (§ <a href="077-7.5._constructors_revisited.html#filepos1979405">7.5.3</a>, p. <a href="077-7.5._constructors_revisited.html#filepos1979405">293</a>) to return if <code>c</code> has no elements.</p>

::: info
<p>When we want to inform the compiler that a name represents a type, we must use the keyword <code>typename</code>, not <code>class</code>.</p>
:::

<h5>Default Template Arguments</h5>
<p>Just as we can supply default arguments to function parameters (§ <a href="067-6.5._features_for_specialized_uses.html#filepos1631032">6.5.1</a>, p. <a href="067-6.5._features_for_specialized_uses.html#filepos1631032">236</a>), we can also supply <strong><a href="160-defined_terms.html#filepos4549642" id="filepos4272100">default template arguments</a></strong>. Under the new standard, we can supply default arguments for both function and class templates. Earlier versions of the language, allowed default arguments only with class templates.</p>
<a id="filepos4272407"></a><img alt="Image" src="/images/00008.jpg"/>
<p>As an example, we’ll rewrite <code>compare</code> to use the library <code>less</code> function-object template (§ <a href="137-14.8._functioncall_operator.html#filepos3679636">14.8.2</a>, p. <a href="137-14.8._functioncall_operator.html#filepos3679636">574</a>) by default:</p>

```c++
// compare has a default template argument, less<T>
// and a default function argument, F()
template <typename T, typename F = less<T>>
int compare(const T &v1, const T &v2, F f = F())
{
    if (f(v1, v2)) return -1;
    if (f(v2, v1)) return 1;
    return 0;
}
```

<p><a id="filepos4273865"></a>Here we’ve given our template a second type parameter, named <code>F</code>, that represents the type of a callable object (§ <a href="100-10.3._customizing_operations.html#filepos2530282">10.3.2</a>, p. <a href="100-10.3._customizing_operations.html#filepos2530282">388</a>) and defined a new function parameter, <code>f</code>, that will be bound to a callable object.</p>
<p>We’ve also provided defaults for this template parameter and its corresponding function parameter. The default template argument specifies that <code>compare</code> will use the library <code>less</code> function-object class, instantiated with the same type parameter as <code>compare</code>. The default function argument says that <code>f</code> will be a default-initialized object of type <code>F</code>.</p>
<p>When users call this version of <code>compare</code>, they may supply their own comparison operation but are not required to do so:</p>

```c++
bool i = compare(0, 42); // uses less; i is -1
// result depends on the isbns in item1 and item2
Sales_data item1(cin), item2(cin);
bool j = compare(item1, item2, compareIsbn);
```

<p>The first call uses the default function argument, which is a default-initialized object of type <code>less&lt;T&gt;</code>. In this call, <code>T</code> is <code>int</code> so that object has type <code>less&lt;int&gt;</code>. This instantiation of <code>compare</code> will use <code>less&lt;int&gt;</code> to do its comparisons.</p>
<p>In the second call, we pass <code>compareIsbn</code> (§ <a href="108-11.2._overview_of_the_associative_containers.html#filepos2751456">11.2.2</a>, p. <a href="108-11.2._overview_of_the_associative_containers.html#filepos2751456">425</a>) and two objects of type <code>Sales_data</code>. When <code>compare</code> is called with three arguments, the type of the third argument must be a callable object that returns a type that is convertible to <code>bool</code> and takes arguments of a type compatible with the types of the first two arguments. As usual, the types of the template parameters are deduced from their corresponding function arguments. In this call, the type of <code>T</code> is deduced as <code>Sales_data</code> and <code>F</code> is deduced as the type of <code>compareIsbn</code>.</p>
<p>As with function default arguments, a template parameter may have a default argument only if all of the parameters to its right also have default arguments.</p>
<h5>Template Default Arguments and Class Templates</h5>
<p>Whenever we use a class template, we must always follow the template’s name with brackets. The brackets indicate that a class must be instantiated from a template. In particular, if a class template provides default arguments for all of its template parameters, and we want to use those defaults, we must put an empty bracket pair following the template’s name:</p>

```c++
template <class T = int> class Numbers {   // by default T is int
public:
    Numbers(T v = 0): val(v) { }
    // various operations on numbers
private:
    T val;
};
Numbers<long double> lots_of_precision;
Numbers<> average_precision; // empty <> says we want the default type
```

<p>Here we instantiate two versions of <code>Numbers</code>: <code>average_precision</code> instantiates <code>Numbers</code> with <code>T</code> replaced by <code>int</code>; <code>lots_of_precision</code> instantiates <code>Numbers</code> with <code>T</code> replaced by <code>long double</code>.</p>

::: info
<a id="filepos4281155"></a><p>Exercises Section 16.1.3</p>
<p><strong>Exercise 16.17:</strong> What, if any, are the differences between a type parameter that is declared as a <code>typename</code> and one that is declared as a <code>class</code>? When must <code>typename</code> be used?</p>
<p><strong>Exercise 16.18:</strong> Explain each of the following function template declarations and identify whether any are illegal. Correct each error that you find.</p>

```c++
(a) template <typename T, U, typename V> void f1(T, U, V);
(b) template <typename T> T f2(int &T);
(c) inline template <typename T> T foo(T, unsigned int*);
(d) template <typename T> f4(T, T);
(e) typedef char Ctype;
    template <typename Ctype> Ctype f5(Ctype a);
```

<p><strong>Exercise 16.19:</strong> Write a function that takes a reference to a container and prints the elements in that container. Use the container’s <code>size_type</code> and <code>size</code> members to control the loop that prints the elements.</p>
<p><strong>Exercise 16.20:</strong> Rewrite the function from the previous exercise to use iterators returned from <code>begin</code> and <code>end</code> to control the loop.</p>
:::

<h4 id="filepos4283763">16.1.4. Member Templates</h4>
<p>A class—either an ordinary class or a class template—may have a member function that is itself a template. Such members are referred to as <strong><a href="160-defined_terms.html#filepos4552721" id="filepos4284048">member templates</a></strong>. Member templates may not be virtual.</p>
<h5>Member Templates of Ordianary (Nontemplate) Classes</h5>
<p>As an example of an ordinary class that has a member template, we’ll define a class that is similar to the default deleter type used by <code>unique_ptr</code> (§ <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos3040235">12.1.5</a>, p. <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos3040235">471</a>). Like the default deleter, our class will have an overloaded function-call operator (§ <a href="137-14.8._functioncall_operator.html#filepos3657799">14.8</a>, p. <a href="137-14.8._functioncall_operator.html#filepos3657799">571</a>) that will take a pointer and execute <code>delete</code> on the given pointer. Unlike the default deleter, our class will also print a message whenever the deleter is executed. Because we want to use our deleter with any type, we’ll make the call operator a template:</p>

```c++
// function-object class that calls delete on a given pointer
class DebugDelete {
public:
    DebugDelete(std::ostream &s = std::cerr): os(s) { }
    // as with any function template, the type of T is deduced by the compiler
    template <typename T> void operator()(T *p) const
      { os << "deleting unique_ptr" << std::endl; delete p; }
private:
    std::ostream &os;
};
```

<p><a id="filepos4286402"></a>Like any other template, a member template starts with its own template parameter list. Each <code>DebugDelete</code> object has an <code>ostream</code> member on which to write, and a member function that is itself a template. We can use this class as a replacement for <code>delete</code>:</p>

```c++
double* p = new double;
DebugDelete d;    // an object that can act like a delete expression
d(p); // calls DebugDelete::operator()(double*), which deletes p
int* ip = new int;
// calls operator()(int*) on a temporary DebugDelete object
DebugDelete()(ip);
```

<p>Because calling a <code>DebugDelete</code> object <code>delete</code>s its given pointer, we can also use <code>DebugDelete</code> as the deleter of a <code>unique_ptr</code>. To override the deleter of a <code>unique_ptr</code>, we supply the type of the deleter inside brackets and supply an object of the deleter type to the constructor (§ <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos3040235">12.1.5</a>, p. <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos3040235">471</a>):</p>

```c++
// destroying the the object to which p points
// instantiates DebugDelete::operator()<int>(int *)
unique_ptr<int, DebugDelete> p(new int, DebugDelete());
// destroying the the object to which sp points
// instantiates DebugDelete::operator()<string>(string*)
unique_ptr<string, DebugDelete> sp(new string, DebugDelete());
```

<p>Here, we’ve said that <code>p</code>’s deleter will have type <code>DebugDelete</code>, and we have supplied an unnamed object of that type in <code>p</code>’s constructor.</p>
<p>The <code>unique_ptr</code> destructor calls the <code>DebugDelete</code>’s call operator. Thus, whenever <code>unique_ptr</code>’s destructor is instantiated, <code>DebugDelete</code>’s call operator will also be instantiated: Thus, the definitions above will instantiate:</p>

```c++
// sample instantiations for member templates of DebugDelete
void DebugDelete::operator()(int *p) const { delete p; }
void DebugDelete::operator()(string *p) const { delete p; }
```

<h5>Member Templates of Class Templates</h5>
<p>We can also define a member template of a class template. In this case, both the class and the member have their own, independent, template parameters.</p>
<p>As an example, we’ll give our <code>Blob</code> class a constructor that will take two iterators denoting a range of elements to copy. Because we’d like to support iterators into varying kinds of sequences, we’ll make this constructor a template:</p>

```c++
template <typename T> class Blob {
    template <typename It> Blob(It b, It e);
    // ...
};
```

<p>This constructor has its own template type parameter, <code>It</code>, which it uses for the type of its two function parameters.</p>
<p>Unlike ordinary function members of class templates, member templates <em>are</em> function templates. When we define a member template outside the body of a <a id="filepos4293617"></a>class template, we must provide the template parameter list for the class template and for the function template. The parameter list for the class template comes first, followed by the member’s own template parameter list:</p>

```c++
template <typename T>     // type parameter for the class
template <typename It>    // type parameter for the constructor
    Blob<T>::Blob(It b, It e):
              data(std::make_shared<std::vector<T>>(b, e)) { }
```

<p>Here we are defining a member of a class template that has one template type parameter, which we have named <code>T</code>. The member itself is a function template that has a type parameter named <code>It</code>.</p>
<h5>Instantiation and Member Templates</h5>
<p>To instantiate a member template of a class template, we must supply arguments for the template parameters for both the class and the function templates. As usual, argument(s) for the class template parameter(s) are determined by the type of the object through which we call the member template. Also as usual, the compiler typically deduces template argument(s) for the member template’s own parameter(s) from the arguments passed in the call (§ <a href="154-16.1._defining_a_template.html#filepos4156441">16.1.1</a>, p. <a href="154-16.1._defining_a_template.html#filepos4156441">653</a>):</p>

```c++
int ia[] = {0,1,2,3,4,5,6,7,8,9};
vector<long> vi = {0,1,2,3,4,5,6,7,8,9};
list<const char*> w = {"now", "is", "the", "time"};
// instantiates the Blob<int> class
// and the Blob<int> constructor that has two int* parameters
Blob<int> a1(begin(ia), end(ia));
// instantiates the Blob<int> constructor that has
// two vector<long>::iterator parameters
Blob<int> a2(vi.begin(), vi.end());
// instantiates the Blob<string> class and the Blob<string>
// constructor that has two (list<const char*>::iterator parameters
Blob<string> a3(w.begin(), w.end());
```

<p>When we define <code>a1</code>, we explicitly specify that the compiler should instantiate a version of <code>Blob</code> with the template parameter bound to <code>int</code>. The type parameter for the constructor’s own parameters will be deduced from the type of <code>begin(ia)</code> and <code>end(ia)</code>. That type is <code>int*</code>. Thus, the definition of <code>a1</code> instantiates:</p>

```c++
Blob<int>::Blob(int*, int*);
```

<p>The definition of <code>a2</code> uses the already instantiated <code>Blob&lt;int&gt;</code> class, and instantiates the constructor with <code>It</code> replaced by <code>vector&lt;short&gt;::iterator</code>. The definition of <code>a3</code> (explicitly) instantiates the <code>Blob</code> with its template parameter bound to <code>string</code> and (implicitly) instantiates the member template constructor of that class with its parameter bound to <code>list&lt;const char*&gt;</code>.</p>

::: info
<a id="filepos4300047"></a><p>Exercises Section 16.1.4</p>
<p><strong>Exercise 16.21:</strong> Write your own version of <code>DebugDelete</code>.</p>
<p><strong>Exercise 16.22:</strong> Revise your <code>TextQuery</code> programs from § <a href="116-12.3._using_the_library_a_textquery_program.html#filepos3140586">12.3</a> (p. <a href="116-12.3._using_the_library_a_textquery_program.html#filepos3140586">484</a>) so that the <code>shared_ptr</code> members use a <code>DebugDelete</code> as their deleter (§ <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos3024819">12.1.4</a>, p. <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos3024819">468</a>).</p>
<p><strong>Exercise 16.23:</strong> Predict when the call operator will be executed in your main query program. If your expectations and what happens differ, be sure you understand why.</p>
<p><strong>Exercise 16.24:</strong> Add a constructor that takes two iterators to your <code>Blob</code> template.</p>
:::

<h4 id="filepos4301573">16.1.5. Controlling Instantiations</h4>
<img alt="Image" src="/images/00010.jpg"/>
<p>The fact that instantiations are generated when a template is used (§ <a href="154-16.1._defining_a_template.html#filepos4156441">16.1.1</a>, p. <a href="154-16.1._defining_a_template.html#filepos4156441">656</a>) means that the same instantiation may appear in multiple object files. When two or more separately compiled source files use the same template with the same template arguments, there is an instantiation of that template in each of those files.</p>
<a id="filepos4302204"></a><img alt="Image" src="/images/00008.jpg"/>
<p>In large systems, the overhead of instantiating the same template in multiple files can become significant. Under the new standard, we can avoid this overhead through an <strong><a href="160-defined_terms.html#filepos4549932" id="filepos4302470">explicit instantiation</a></strong>. An explicit instantiation has the form</p>

```c++
extern template declaration; // instantiation declaration
template declaration;        // instantiation definition
```

<p>where <em>declaration</em> is a class or function declaration in which all the template parameters are replaced by the template arguments. For example,</p>

```c++
// instantion declaration and definition
extern template class Blob<string>;             // declaration
template int compare(const int&, const int&);   // definition
```

<p>When the compiler sees an <code>extern</code> template declaration, it will not generate code for that instantiation in that file. Declaring an instantiation as <code>extern</code> is a promise that there will be a non<code>extern</code> use of that instantiation elsewhere in the program. There may be several <code>extern</code> declarations for a given instantiation but there must be exactly one definition for that instantiation.</p>
<p>Because the compiler automatically instantiates a template when we use it, the <code>extern</code> declaration must appear before any code that uses that instantiation:</p>

```c++
// Application.cc
// these template types must be instantiated elsewhere in the program
extern template class Blob<string>;
extern template int compare(const int&, const int&);
Blob<string> sa1, sa2; // instantiation will appear elsewhere
// Blob<int> and its initializer_list constructor instantiated in this file
Blob<int> a1 = {0,1,2,3,4,5,6,7,8,9};
Blob<int> a2(a1);  // copy constructor instantiated in this file
int i = compare(a1[0], a2[0]); // instantiation will appear elsewhere
```

<p><a id="filepos4306656"></a>The file <code>Application.o</code> will contain instantiations for <code>Blob&lt;int&gt;</code>, along with the <code>initializer_list</code> and copy constructors for that class. The <code>compare&lt;int&gt;</code> function and <code>Blob&lt;string&gt;</code> class will not be instantiated in that file. There must be definitions of these templates in some other file in the program:</p>

```c++
// templateBuild.cc
// instantiation file must provide a (nonextern) definition for every
// type and function that other files declare as extern
template int compare(const int&, const int&);
template class Blob<string>; // instantiates all members of the class template
```

<p>When the compiler sees an instantiation definition (as opposed to a declaration), it generates code. Thus, the file <code>templateBuild.o</code> will contain the definitions for <code>compare</code> instantiated with <code>int</code> and for the <code>Blob&lt;string&gt;</code> class. When we build the application, we must link <code>templateBuild.o</code> with the <code>Application.o</code> files.</p>

::: warning
<p>There must be an explicit instantiation definition somewhere in the program for every instantiation declaration.</p>
:::

<h5>Instantiation Definitions Instantiate All Members</h5>
<p>An instantiation definition for a class template instantiates <em>all</em> the members of that template including inline member functions. When the compiler sees an instantiation definition it cannot know which member functions the program uses. Hence, unlike the way it handles ordinary class template instantiations, the compiler instantiates <em>all</em> the members of that class. Even if we do not use a member, that member will be instantiated. Consequently, we can use explicit instantiation only for types that can be used with all the members of that template.</p>

::: info
<p>An instantiation definition can be used only for types that can be used with every member function of a class template.</p>
:::

<h4 id="filepos4310778">16.1.6. Efficiency and Flexibility</h4>
<img alt="Image" src="/images/00010.jpg"/>
<p>The library smart pointer types (§ <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos2904799">12.1</a>, p. <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos2904799">450</a>) offer a good illustration of design choices faced by designers of templates.</p>
<p>The obvious difference between <code>shared_ptr</code> and <code>unique_ptr</code> is the strategy they use in managing the pointer they hold—one class gives us shared ownership; the other owns the pointer that it holds. This difference is essential to what these classes do.</p>
<p>These classes also differ in how they let users override their default deleter. We can easily override the deleter of a <code>shared_ptr</code> by passing a callable object when we create or <code>reset</code> the pointer. In contrast, the type of the deleter is part of the type of a <code>unique_ptr</code> object. Users must supply that type as an explicit template argument when they define a <code>unique_ptr</code>. As a result, it is more complicated for users of <code>unique_ptr</code> to provide their own deleter.</p>

::: info
<a id="filepos4312501"></a><p>Exercises Section 16.1.5</p>
<p><strong>Exercise 16.25:</strong> Explain the meaning of these declarations:</p>

```c++
extern template class vector<string>;
template class vector<Sales_data>;
```

<p><strong>Exercise 16.26:</strong> Assuming <code>NoDefault</code> is a class that does not have a default constructor, can we explicitly instantiate <code>vector&lt;NoDefault&gt;</code>? If not, why not?</p>
<p><strong>Exercise 16.27:</strong> For each labeled statement explain what, if any, instantiations happen. If a template is instantiated, explain why; if not, explain why not.</p>

```c++
template <typename T> class Stack { };
void f1(Stack<char>);                   // (a)
class Exercise {
    Stack<double> &rsd;                 // (b)
    Stack<int>    si;                   // (c)
};
int main() {
    Stack<char> *sc;                    // (d)
    f1(*sc);                            // (e)
    int iObj = sizeof(Stack< string >); // (f)
}
```

:::

<p>The difference in how the deleter is handled is incidental to the functionality of these classes. However, as we’ll see, this difference in implementation strategy may have important performance impacts.</p>
<h5>Binding the Deleter at Run Time</h5>
<p>Although we don’t know how the library types are implemented, we can infer that <code>shared_ptr</code> must access its deleter indirectly. That is the deleter must be stored as a pointer or as a class (such as <code>function</code> (§ <a href="137-14.8._functioncall_operator.html#filepos3690557">14.8.3</a>, p. <a href="137-14.8._functioncall_operator.html#filepos3690557">577</a>)) that encapsulates a pointer.</p>
<p>We can be certain that <code>shared_ptr</code> does not hold the deleter as a direct member, because the type of the deleter isn’t known until run time. Indeed, we can change the type of the deleter in a given <code>shared_ptr</code> during that <code>shared_ptr</code>’s lifetime. We can construct a <code>shared_ptr</code> using a deleter of one type, and subsequently use <code>reset</code> to give that same <code>shared_ptr</code> a different type of deleter. In general, we cannot have a member whose type changes at run time. Hence, the deleter must be stored indirectly.</p>
<p>To think about how the deleter must work, let’s assume that <code>shared_ptr</code> stores the pointer it manages in a member named <code>p</code>, and that the deleter is accessed through a member named <code>del</code>. The <code>shared_ptr</code> destructor must include a statement such as</p>

```c++
// value of del known only at run time; call through a pointer
del ? del(p) : delete p; // del(p) requires run-time jump to del's location
```

<p><a id="filepos4318961"></a>Because the deleter is stored indirectly, the call <code>del(p)</code> requires a run-time jump to the location stored in <code>del</code> to execute the code to which <code>del</code> points.</p>
<h5>Binding the Deleter at Compile Time</h5>
<p>Now, let’s think about how <code>unique_ptr</code> might work. In this class, the type of the deleter is part of the type of the <code>unique_ptr</code>. That is, <code>unique_ptr</code> has two template parameters, one that represents the pointer that the <code>unique_ptr</code> manages and the other that represents the type of the deleter. Because the type of the deleter is part of the type of a <code>unique_ptr</code>, the type of the deleter member is known at compile time. The deleter can be stored directly in each <code>unique_ptr</code> object.</p>
<p>The <code>unique_ptr</code> destructor operates similarly to its <code>shared_ptr</code> counterpart in that it calls a user-supplied deleter or executes <code>delete</code> on its stored pointer:</p>

```c++
// del bound at compile time; direct call to the deleter is instantiated
del(p);   // no run-time overhead
```

<p>The type of <code>del</code> is either the default deleter type or a user-supplied type. It doesn’t matter; either way the code that will be executed is known at compile time. Indeed, if the deleter is something like our <code>DebugDelete</code> class (§ <a href="154-16.1._defining_a_template.html#filepos4283763">16.1.4</a>, p. <a href="154-16.1._defining_a_template.html#filepos4283763">672</a>) this call might even be inlined at compile time.</p>
<p>By binding the deleter at compile time, <code>unique_ptr</code> avoids the run-time cost of an indirect call to its deleter. By binding the deleter at run time, <code>shared_ptr</code> makes it easier for users to override the deleter.</p>

::: info
<p>Exercises Section 16.1.6</p>
<p><strong>Exercise 16.28:</strong> Write your own versions of <code>shared_ptr</code> and <code>unique_ptr</code>.</p>
<p><strong>Exercise 16.29:</strong> Revise your <code>Blob</code> class to use your version of <code>shared_ptr</code> rather than the library version.</p>
<p><strong>Exercise 16.30:</strong> Rerun some of your programs to verify your <code>shared_ptr</code> and revised <code>Blob</code> classes. (Note: Implementing the <code>weak_ptr</code> type is beyond the scope of this Primer, so you will not be able to use the <code>BlobPtr</code> class with your revised <code>Blob</code>.)</p>
<p><strong>Exercise 16.31:</strong> Explain how the compiler might inline the call to the deleter if we used <code>DebugDelete</code> with <code>unique_ptr</code>.</p>
:::

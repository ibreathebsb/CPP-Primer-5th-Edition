<h3 id="filepos853883">3.5. Arrays</h3>
<p>An array is a data structure that is similar to the library <code>vector</code> type (§ <a href="032-3.3._library_vector_type.html#filepos736471">3.3</a>, p. <a href="032-3.3._library_vector_type.html#filepos736471">96</a>) but offers a different trade-off between performance and flexibility. Like a <code>vector</code>, an array is a container of unnamed objects of a single type that we access by position. Unlike a <code>vector</code>, arrays have fixed size; we cannot add elements to an array. Because arrays have fixed size, they sometimes offer better run-time performance for specialized applications. However, that run-time advantage comes at the cost of lost flexibility.</p>

::: tip
<p>If you don’t know exactly how many elements you need, use a <code>vector</code>.</p>
:::

<h4 id="filepos855259">3.5.1. Defining and Initializing Built-in Arrays</h4>
<p>Arrays are a compound type (§ <a href="023-2.3._compound_types.html#filepos394806">2.3</a>, p. <a href="023-2.3._compound_types.html#filepos394806">50</a>). An array declarator has the form <code>a[d]</code>, where <code>a</code> is the name being defined and <code>d</code> is the dimension of the array. The dimension specifies the number of elements and must be greater than zero. The number of elements in an array is part of the array’s type. As a result, the dimension must be known at compile time, which means that the dimension must be a constant expression (§ <a href="024-2.4._const_qualifier.html#filepos520427">2.4.4</a>, p. <a href="024-2.4._const_qualifier.html#filepos520427">65</a>):</p>

```c++
unsigned cnt = 42;          // not a constant expression
constexpr unsigned sz = 42; // constant expression
                            // constexpr see § 2.4.4 (p. 66)
int arr[10];             // array of ten ints
int *parr[sz];           // array of 42 pointers to int
string bad[cnt];         // error: cnt is not a constant expression
string strs[get_size()]; // ok if get_size is constexpr, error otherwise
```

<p>By default, the elements in an array are default initialized (§ <a href="022-2.2._variables.html#filepos350704">2.2.1</a>, p. <a href="022-2.2._variables.html#filepos350704">43</a>).</p>

::: warning
<p>As with variables of built-in type, a default-initialized array of built-in type that is defined inside a function will have undefined values.</p>
:::

<p>When we define an array, we must specify a type for the array. We cannot use <code>auto</code> to deduce the type from a list of initializers. As with <code>vector</code>, arrays hold objects. Thus, there are no arrays of references.</p>
<h5><a id="filepos859478"></a>Explicitly Initializing Array Elements</h5>
<p>We can list initialize (§ <a href="032-3.3._library_vector_type.html#filepos744172">3.3.1</a>, p. <a href="032-3.3._library_vector_type.html#filepos744172">98</a>) the elements in an array. When we do so, we can omit the dimension. If we omit the dimension, the compiler infers it from the number of initializers. If we specify a dimension, the number of initializers must not exceed the specified size. If the dimension is greater than the number of initializers, the initializers are used for the first elements and any remaining elements are value initialized (§ <a href="032-3.3._library_vector_type.html#filepos744172">3.3.1</a>, p. <a href="032-3.3._library_vector_type.html#filepos744172">98</a>):</p>

```c++
const unsigned sz = 3;
int ia1[sz] = {0,1,2};        // array of three ints with values 0, 1, 2
int a2[] = {0, 1, 2};         // an array of dimension 3
int a3[5] = {0, 1, 2};        // equivalent to a3[] = {0, 1, 2, 0, 0}
string a4[3] = {"hi", "bye"}; // same as a4[] =  {"hi", "bye", ""}
int a5[2] = {0,1,2};          // error: too many initializers
```

<h5>Character Arrays Are Special</h5>
<p>Character arrays have an additional form of initialization: We can initialize such arrays from a string literal (§ <a href="021-2.1._primitive_builtin_types.html#filepos326709">2.1.3</a>, p. <a href="021-2.1._primitive_builtin_types.html#filepos326709">39</a>). When we use this form of initialization, it is important to remember that string literals end with a null character. That null character is copied into the array along with the characters in the literal:</p>

```c++
char a1[] = {'C', '+', '+'};       // list initialization, no null
char a2[] = {'C', '+', '+', '\0'}; // list initialization, explicit null
char a3[] = "C++";                 // null terminator added automatically
const char a4[6] = "Daniel";       // error: no space for the null!
```

<p>The dimension of <code>a1</code> is 3; the dimensions of <code>a2</code> and <code>a3</code> are both 4. The definition of <code>a4</code> is in error. Although the literal contains only six explicit characters, the array size must be at least seven—six to hold the literal and one for the null.</p>
<h5>No Copy or Assignment</h5>
<p>We cannot initialize an array as a copy of another array, nor is it legal to assign one array to another:</p>

```c++
int a[] = {0, 1, 2}; // array of three ints
int a2[] = a;        // error: cannot initialize one array with another
a2 = a;              // error: cannot assign one array to another
```

::: warning
<p>Some compilers allow array assignment as a <strong><a href="037-defined_terms.html#filepos979689" id="filepos865318">compiler extension</a></strong>. It is usually a good idea to avoid using nonstandard features. Programs that use such features, will not work with a different compiler.</p>
:::

<h5>Understanding Complicated Array Declarations</h5>
<p>Like <code>vector</code>s, arrays can hold objects of most any type. For example, we can have an array of pointers. Because an array is an object, we can define both pointers and references to arrays. Defining arrays that hold pointers is fairly straightforward, defining a pointer or reference to an array is a bit more complicated:</p>
<p><a id="filepos866213"></a></p>

```c++
int *ptrs[10];            //  ptrs is an array of ten pointers to int
int &refs[10] = /* ? */;  //  error: no arrays of references
int (*Parray)[10] = &arr; //  Parray points to an array of ten ints
int (&arrRef)[10] = arr;  //  arrRef refers to an array of ten ints
```

<p>By default, type modifiers bind right to left. Reading the definition of <code>ptrs</code> from right to left (§ <a href="023-2.3._compound_types.html#filepos445809">2.3.3</a>, p. <a href="023-2.3._compound_types.html#filepos445809">58</a>) is easy: We see that we’re defining an array of size 10, named <code>ptrs</code>, that holds pointers to <code>int</code>.</p>
<p>Reading the definition of <code>Parray</code> from right to left isn’t as helpful. Because the array dimension follows the name being declared, it can be easier to read array declarations from the inside out rather than from right to left. Reading from the inside out makes it much easier to understand the type of <code>Parray</code>. We start by observing that the parentheses around <code>*Parray</code> mean that <code>Parray</code> is a pointer. Looking right, we see that <code>Parray</code> points to an array of size 10. Looking left, we see that the elements in that array are <code>int</code>s. Thus, <code>Parray</code> is a pointer to an array of ten <code>int</code>s. Similarly, <code>(&amp;arrRef)</code> says that <code>arrRef</code> is a reference. The type to which it refers is an array of size 10. That array holds elements of type <code>int</code>.</p>
<p>Of course, there are no limits on how many type modifiers can be used:</p>

```c++
int *(&arry)[10] = ptrs; // arry is a reference to an array of ten pointers
```

<p>Reading this declaration from the inside out, we see that <code>arry</code> is a reference. Looking right, we see that the object to which <code>arry</code> refers is an array of size 10. Looking left, we see that the element type is pointer to <code>int</code>. Thus, <code>arry</code> is a reference to an array of ten pointers.</p>

::: tip
<p>It can be easier to understand array declarations by starting with the array’s name and reading them from the inside out.</p>
:::

::: info
<p>Exercises Section 3.5.1</p>
<p><strong>Exercise 3.27:</strong> Assuming <code>txt_size</code> is a function that takes no arguments and returns an <code>int</code> value, which of the following definitions are illegal? Explain why.</p>

```c++
unsigned buf_size = 1024;
```

<p><strong>(a)</strong>
<code>int ia[buf_size];</code></p>
<p><strong>(b)</strong>
<code>int ia[4 * 7 - 14];</code></p>
<p><strong>(c)</strong>
<code>int ia[txt_size()];</code></p>
<p><strong>(d)</strong>
<code>char st[11] = "fundamental";</code></p>
<p><strong>Exercise 3.28:</strong> What are the values in the following arrays?</p>

```c++
string sa[10];
int ia[10];
int main() {
    string sa2[10];
    int    ia2[10];
}
```

<p><strong>Exercise 3.29:</strong> List some of the drawbacks of using an array instead of a <code>vector</code>.</p>
:::

<h4 id="filepos873638"><a id="filepos873671"></a>3.5.2. Accessing the Elements of an Array</h4>
<p>As with the library <code>vector</code> and <code>string</code> types, we can use a range <code>for</code> or the subscript operator to access elements of an array. As usual, the indices start at 0. For an array of ten elements, the indices are 0 through 9, not 1 through 10.</p>
<p>When we use a variable to subscript an array, we normally should define that variable to have type <code>size_t</code>. <code>size_t</code> is a machine-specific unsigned type that is guaranteed to be large enough to hold the size of any object in memory. The <code>size_t</code> type is defined in the <code>cstddef</code> header, which is the C++ version of the <code>stddef.h</code> header from the C library.</p>
<p>With the exception that arrays are fixed size, we use arrays in ways that are similar to how we use <code>vector</code>s. For example, we can reimplement our grading program from § <a href="032-3.3._library_vector_type.html#filepos778112">3.3.3</a> (p. <a href="032-3.3._library_vector_type.html#filepos778112">104</a>) to use an array to hold the cluster counters:</p>

```c++
// count the number of grades by clusters of ten: 0--9, 10--19, ... 90--99, 100
unsigned scores[11] = {}; // 11 buckets, all value initialized to 0
unsigned grade;
while (cin >> grade) {
    if (grade <= 100)
        ++scores[grade/10]; // increment the counter for the current cluster
}
```

<p>The only obvious difference between this program and the one on page <a href="032-3.3._library_vector_type.html#filepos789121">104</a> is the declaration of <code>scores</code>. In this program <code>scores</code> is an array of 11 <code>unsigned</code> elements. The not so obvious difference is that the subscript operator in this program is the one that is defined as part of the language. This operator can be used on operands of array type. The subscript operator used in the program on page <a href="032-3.3._library_vector_type.html#filepos789121">104</a> was defined by the library <code>vector</code> template and applies to operands of type <code>vector</code>.</p>
<p>As in the case of <code>string</code> or <code>vector</code>, it is best to use a range <code>for</code> when we want to traverse the entire array. For example, we can print the resulting <code>scores</code> as follows:</p>

```c++
for (auto i : scores)      // for each counter in scores
    cout << i << " ";      // print the value of that counter
cout << endl;
```

<p>Because the dimension is part of each array type, the system knows how many elements are in <code>scores</code>. Using a range <code>for</code> means that we don’t have to manage the traversal ourselves.</p>
<h5>Checking Subscript Values</h5>
<p>As with <code>string</code> and <code>vector</code>, it is up to the programmer to ensure that the subscript value is in range—that is, that the index value is equal to or greater than zero and less than the size of the array. Nothing stops a program from stepping across an array boundary except careful attention to detail and thorough testing of the code. It is possible for programs to compile and execute yet still be fatally wrong.</p>

::: warning
<p>The most common source of security problems are buffer overflow bugs. Such bugs occur when a program fails to check a subscript and mistakenly uses memory outside the range of an array or similar data structure.</p>
:::

::: info
<a id="filepos880253"></a><p>Exercises Section 3.5.2</p>
<p><strong>Exercise 3.30:</strong> Identify the indexing errors in the following code:</p>

```c++
constexpr size_t array_size = 10;
int ia[array_size];
for (size_t ix = 1; ix <= array_size; ++ix)
      ia[ix] = ix;
```

<p><strong>Exercise 3.31:</strong> Write a program to define an array of ten <code>int</code>s. Give each element the same value as its position in the array.</p>
<p><strong>Exercise 3.32:</strong> Copy the array you defined in the previous exercise into another array. Rewrite your program to use <code>vector</code>s.</p>
<p><strong>Exercise 3.33:</strong> What would happen if we did not initialize the <code>scores</code> array in the program on page <a href="034-3.5._arrays.html#filepos873671">116</a>?</p>
:::

<h4 id="filepos881970">3.5.3. Pointers and Arrays</h4>
<p>In C++ pointers and arrays are closely intertwined. In particular, as we’ll see, when we use an array, the compiler ordinarily converts the array to a pointer.</p>
<p>Normally, we obtain a pointer to an object by using the address-of operator (§ <a href="023-2.3._compound_types.html#filepos409391">2.3.2</a>, p. <a href="023-2.3._compound_types.html#filepos409391">52</a>). Generally speaking, the address-of operator may be applied to any object. The elements in an array are objects. When we subscript an array, the result is the object at that location in the array. As with any other object, we can obtain a pointer to an array element by taking the address of that element:</p>

```c++
string nums[] = {"one", "two", "three"};  // array of strings
string *p = &nums[0];   // p points to the first element in nums
```

<p>However, arrays have a special property—in most places when we use an array, the compiler automatically substitutes a pointer to the first element:</p>

```c++
string *p2 = nums;      // equivalent to p2 = &nums[0]
```

::: info
<p>In most expressions, when we use an object of array type, we are really using a pointer to the first element in that array.</p>
:::

<p>There are various implications of the fact that operations on arrays are often really operations on pointers. One such implication is that when we use an array as an initializer for a variable defined using <code>auto</code> (§ <a href="025-2.5._dealing_with_types.html#filepos544751">2.5.2</a>, p. <a href="025-2.5._dealing_with_types.html#filepos544751">68</a>), the deduced type is a pointer, not an array:</p>

```c++
int ia[] = {0,1,2,3,4,5,6,7,8,9}; // ia is an array of ten ints
auto ia2(ia); // ia2 is an int* that points to the first element in ia
ia2 = 42;     // error: ia2 is a pointer, and we can't assign an int to a pointer
```

<p>Although <code>ia</code> is an array of ten <code>int</code>s, when we use <code>ia</code> as an initializer, the compiler treats that initialization as if we had written</p>
<p><a id="filepos887176"></a></p>

```c++
auto ia2(&ia[0]);  // now it's clear that ia2 has type int*
```

<p>It is worth noting that this conversion does not happen when we use <code>decltype</code> (§ <a href="025-2.5._dealing_with_types.html#filepos562878">2.5.3</a>, p. <a href="025-2.5._dealing_with_types.html#filepos562878">70</a>). The type returned by <code>decltype(ia)</code> is array of ten <code>int</code>s:</p>

```c++
// ia3 is an array of ten ints
decltype(ia) ia3 = {0,1,2,3,4,5,6,7,8,9};
ia3 = p;    // error: can't assign an int* to an array
ia3[4] = i; // ok: assigns the value of i to an element in ia3
```

<h5>Pointers Are Iterators</h5>
<p>Pointers that address elements in an array have additional operations beyond those we described in § <a href="023-2.3._compound_types.html#filepos409391">2.3.2</a> (p. <a href="023-2.3._compound_types.html#filepos409391">52</a>). In particular, pointers to array elements support the same operations as iterators on <code>vector</code>s or <code>string</code>s (§ <a href="033-3.4._introducing_iterators.html#filepos802543">3.4</a>, p. <a href="033-3.4._introducing_iterators.html#filepos802543">106</a>). For example, we can use the increment operator to move from one element in an array to the next:</p>

```c++
int arr[] = {0,1,2,3,4,5,6,7,8,9};
int *p = arr; // p points to the first element in arr
++p;          // p points to arr[1]
```

<p>Just as we can use iterators to traverse the elements in a <code>vector</code>, we can use pointers to traverse the elements in an array. Of course, to do so, we need to obtain pointers to the first and one past the last element. As we’ve just seen, we can obtain a pointer to the first element by using the array itself or by taking the address-of the first element. We can obtain an off-the-end pointer by using another special property of arrays. We can take the address of the nonexistent element one past the last element of an array:</p>

```c++
int *e = &arr[10]; // pointer just past the last element in arr
```

<p>Here we used the subscript operator to index a nonexisting element; <code>arr</code> has ten elements, so the last element in <code>arr</code> is at index position 9. The only thing we can do with this element is take its address, which we do to initialize <code>e</code>. Like an off-the-end iterator (§ <a href="033-3.4._introducing_iterators.html#filepos804727">3.4.1</a>, p. <a href="033-3.4._introducing_iterators.html#filepos804727">106</a>), an off-the-end pointer does not point to an element. As a result, we may not dereference or increment an off-the-end pointer.</p>
<p>Using these pointers we can write a loop to print the elements in <code>arr</code> as follows:</p>

```c++
for (int *b = arr; b != e; ++b)
    cout << *b << endl; // print the elements in arr
```

<h5>The Library <code>begin</code> and <code>end</code> Functions</h5>
<a id="filepos894049"></a><Badge type="tip" text="C++11" />
<p>Although we can compute an off-the-end pointer, doing so is error-prone. To make it easier and safer to use pointers, the new library includes two functions, named <code>begin</code> and <code>end</code>. These functions act like the similarly named container members (§ <a href="033-3.4._introducing_iterators.html#filepos804727">3.4.1</a>, p. <a href="033-3.4._introducing_iterators.html#filepos804727">106</a>). However, arrays are not class types, so these functions are not member functions. Instead, they take an argument that is an array:</p>

```c++
int ia[] = {0,1,2,3,4,5,6,7,8,9}; // ia is an array of ten ints
int *beg = begin(ia); // pointer to the first element in ia
int *last = end(ia);  // pointer one past the last element in ia
```

<p><a id="filepos895796"></a><code>begin</code> returns a pointer to the first, and <code>end</code> returns a pointer one past the last element in the given array: These functions are defined in the <code>iterator</code> header.</p>
<p>Using <code>begin</code> and <code>end</code>, it is easy to write a loop to process the elements in an array. For example, assuming <code>arr</code> is an array that holds <code>int</code> values, we might find the first negative value in <code>arr</code> as follows:</p>

```c++
// pbeg points to the first and pend points just past the last element in arr
int *pbeg = begin(arr),  *pend = end(arr);
// find the first negative element, stopping if we've seen all the elements
while (pbeg != pend && *pbeg >= 0)
    ++pbeg;
```

<p>We start by defining two <code>int</code> pointers named <code>pbeg</code> and <code>pend</code>. We position <code>pbeg</code> to denote the first element and <code>pend</code> to point one past the last element in <code>arr</code>. The <code>while</code> condition uses <code>pend</code> to know whether it is safe to dereference <code>pbeg</code>. If <code>pbeg</code> does point at an element, we dereference and check whether the underlying element is negative. If so, the condition fails and we exit the loop. If not, we increment the pointer to look at the next element.</p>

::: info
<p>A pointer “one past” the end of a built-in array behaves the same way as the iterator returned by the <code>end</code> operation of a <code>vector</code>. In particular, we may not dereference or increment an off-the-end pointer.</p>
:::

<h5>Pointer Arithmetic</h5>
<p>Pointers that address array elements can use all the iterator operations listed in <a href="033-3.4._introducing_iterators.html#filepos810064">Table 3.6</a> (p. <a href="033-3.4._introducing_iterators.html#filepos810064">107</a>) and <a href="033-3.4._introducing_iterators.html#filepos840512">Table 3.7</a> (p. <a href="033-3.4._introducing_iterators.html#filepos840512">111</a>). These operations—dereference, increment, comparisons, addition of an integral value, subtraction of two pointers—have the same meaning when applied to pointers that point at elements in a built-in array as they do when applied to iterators.</p>
<p>When we add (or subtract) an integral value to (or from) a pointer, the result is a new pointer. That new pointer points to the element the given number ahead of (or behind) the original pointer:</p>

```c++
constexpr size_t sz = 5;
int arr[sz] = {1,2,3,4,5};
int *ip = arr;     // equivalent to int *ip = &arr[0]
int *ip2 = ip + 4; // ip2 points to arr[4], the last element in arr
```

<p>The result of adding <code>4</code> to <code>ip</code> is a pointer that points to the element four elements further on in the array from the one to which <code>ip</code> currently points.</p>
<p>The result of adding an integral value to a pointer must be a pointer to an element in the same array, or a pointer just past the end of the array:</p>

```c++
// ok: arr is converted to a pointer to its first element; p points one past the end of arr
int *p = arr + sz; // use caution -- do not dereference!
int *p2 = arr + 10; // error: arr has only 5 elements; p2 has undefined value
```

<p>When we add <code>sz</code> to <code>arr</code>, the compiler converts <code>arr</code> to a pointer to the first element in <code>arr</code>. When we add <code>sz</code> to that pointer, we get a pointer that points <code>sz</code> positions <a id="filepos903915"></a>(i.e., <code>5</code> positions) past the first one. That is, it points one past the last element in <code>arr</code>. Computing a pointer more than one past the last element is an error, although the compiler is unlikely to detect such errors.</p>
<p>As with iterators, subtracting two pointers gives us the distance between those pointers. The pointers must point to elements in the same array:</p>

```c++
auto n = end(arr) - begin(arr); // n is 5, the number of elements in arr
```

<p>The result of subtracting two pointers is a library type named <code>ptrdiff_t</code>. Like <code>size_t</code>, the <code>ptrdiff_t</code> type is a machine-specific type and is defined in the <code>cstddef</code> header. Because subtraction might yield a negative distance, <code>ptrdiff_t</code> is a signed integral type.</p>
<p>We can use the relational operators to compare pointers that point to elements of an array, or one past the last element in that array. For example, we can traverse the elements in <code>arr</code> as follows:</p>

```c++
int *b = arr, *e = arr + sz;
while (b < e) {
    // use *b
    ++b;
}
```

<p>We cannot use the relational operators on pointers to two unrelated objects:</p>

```c++
int i = 0, sz = 42;
int *p = &i, *e = &sz;
// undefined: p and e are unrelated; comparison is meaningless!
while (p < e)
```

<p>Although the utility may be obscure at this point, it is worth noting that pointer arithmetic is also valid for null pointers (§ <a href="023-2.3._compound_types.html#filepos409391">2.3.2</a>, p. <a href="023-2.3._compound_types.html#filepos409391">53</a>) and for pointers that point to an object that is not an array. In the latter case, the pointers must point to the same object, or one past that object. If <code>p</code> is a null pointer, we can add or subtract an integral constant expression (§ <a href="024-2.4._const_qualifier.html#filepos520427">2.4.4</a>, p. <a href="024-2.4._const_qualifier.html#filepos520427">65</a>) whose value is 0 to <code>p</code>. We can also subtract two null pointers from one another, in which case the result is 0.</p>
<h5>Interaction between Dereference and Pointer Arithmetic</h5>
<p>The result of adding an integral value to a pointer is itself a pointer. Assuming the resulting pointer points to an element, we can dereference the resulting pointer:</p>

```c++
int ia[] = {0,2,4,6,8}; // array with 5 elements of type int
int last = *(ia + 4); // ok: initializes last to 8, the value of ia[4]
```

<p>The expression <code>*(ia + 4)</code> calculates the address four elements past <code>ia</code> and dereferences the resulting pointer. This expression is equivalent to writing <code>ia[4]</code>.</p>
<p>Recall that in § <a href="033-3.4._introducing_iterators.html#filepos804727">3.4.1</a> (p. <a href="033-3.4._introducing_iterators.html#filepos804727">109</a>) we noted that parentheses are required in expressions that contain dereference and dot operators. Similarly, the parentheses around this pointer addition are essential. Writing</p>

```c++
last = *ia + 4;  // ok: last = 4, equivalent to ia[0] + 4
```

<p>means dereference <code>ia</code> and add <code>4</code> to the dereferenced value. We’ll cover the reasons for this behavior in § <a href="039-4.1._fundamentals.html#filepos1010254">4.1.2</a> (p. <a href="039-4.1._fundamentals.html#filepos1010254">136</a>).</p>
<h5><a id="filepos911392"></a>Subscripts and Pointers</h5>
<Badge type="warning" text="Tricky" />
<p>As we’ve seen, in most places when we use the name of an array, we are really using a pointer to the first element in that array. One place where the compiler does this transformation is when we subscript an array. Given</p>

```c++
int ia[] = {0,2,4,6,8};  // array with 5 elements of type int
```

<p>if we write <code>ia[0]</code>, that is an expression that uses the name of an array. When we subscript an array, we are really subscripting a pointer to an element in that array:</p>

```c++
int i = ia[2];  // ia is converted to a pointer to the first element in ia
                // ia[2] fetches the element to which (ia + 2) points
int *p = ia;    // p points to the first element in ia
i = *(p + 2);   // equivalent to i = ia[2]
```

<p>We can use the subscript operator on any pointer, as long as that pointer points to an element (or one past the last element) in an array:</p>

```c++
int *p = &ia[2];  // p points to the element indexed by 2
int j = p[1];     // p[1] is equivalent to *(p + 1),
                  // p[1] is the same element as ia[3]
int k = p[-2];    // p[-2] is the same element as ia[0]
```

<p>This last example points out an important difference between arrays and library types such as <code>vector</code> and <code>string</code> that have subscript operators. The library types force the index used with a subscript to be an unsigned value. The built-in subscript operator does not. The index used with the built-in subscript operator can be a negative value. Of course, the resulting address must point to an element in (or one past the end of) the array to which the original pointer points.</p>

::: warning
<p>Unlike subscripts for <code>vector</code> and <code>string</code>, the index of the built-in subscript operator is not an <code>unsigned</code> type.</p>
:::

::: info
<p>Exercises Section 3.5.3</p>
<p><strong>Exercise 3.34:</strong> Given that <code>p1</code> and <code>p2</code> point to elements in the same array, what does the following code do? Are there values of <code>p1</code> or <code>p2</code> that make this code illegal?</p>

```c++
p1 += p2 - p1;
```

<p><strong>Exercise 3.35:</strong> Using pointers, write a program to set the elements in an array to zero.</p>
<p><strong>Exercise 3.36:</strong> Write a program to compare two arrays for equality. Write a similar program to compare two <code>vector</code>s.</p>
:::

<h4 id="filepos918393"><a id="filepos918426"></a>3.5.4. C-Style Character Strings</h4>
<Badge type="info" text="Fundamental" />

::: warning
<p>Although C++ supports C-style strings, they should not be used by C++ programs. C-style strings are a surprisingly rich source of bugs and are the root cause of many security problems. They’re also harder to use!</p>
:::

<p>Character string literals are an instance of a more general construct that C++ inherits from C: <strong><a href="037-defined_terms.html#filepos978817" id="filepos919251">C-style character strings</a></strong>. C-style strings are not a type. Instead, they are a convention for how to represent and use character strings. Strings that follow this convention are stored in character arrays and are <strong><a href="037-defined_terms.html#filepos984804" id="filepos919525">null terminated</a></strong>. By null-terminated we mean that the last character in the string is followed by a null character (<code>'\0'</code>). Ordinarily we use pointers to manipulate these strings.</p>
<h5>C Library String Functions</h5>
<p>The Standard C library provides a set of functions, listed in <a href="034-3.5._arrays.html#filepos920404">Table 3.8</a>, that operate on C-style strings. These functions are defined in the <code>cstring</code> header, which is the C++ version of the C header <code>string.h</code>.</p>
<p><a id="filepos920404"></a>Table 3.8. C-Style Character String Functions</p>

| Code             | Description                                                                                                                 |
|------------------|-----------------------------------------------------------------------------------------------------------------------------|
| `strlen(p)`      | Returns the length of `p`, not counting the null.                                                                           |
| `strcmp(p1, p2)` | Compares `p1` and `p2` for equality. Returns 0 if `p1 == p2`, a positive value if `p1 > p2`, a negative value if `p1 < p2`. |
| `strcat(p1, p2)` | Appends `p2` to `p1`. Returns `p1`.                                                                                         |
| `strcpy(p1, p2)` | Copies `p2` into `p1`. Returns `p1`.                                                                                        |

::: warning
<p>The functions in <a href="034-3.5._arrays.html#filepos920404">Table 3.8</a> do not verify their string parameters.</p>
:::

<p>The pointer(s) passed to these routines must point to null-terminated array(s):</p>

```c++
char ca[] = {'C', '+', '+'};  // not null terminated
cout << strlen(ca) << endl;   // disaster: ca isn't null terminated
```

<p>In this case, <code>ca</code> is an array of <code>char</code> but is not null terminated. The result is undefined. The most likely effect of this call is that <code>strlen</code> will keep looking through the memory that follows <code>ca</code> until it encounters a null character.</p>
<h5>Comparing Strings</h5>
<p>Comparing two C-style strings is done quite differently from how we compare library <code>string</code>s. When we compare two library <code>string</code>s, we use the normal relational or equality operators:</p>

```c++
string s1 = "A string example";
string s2 = "A different string";
if (s1 < s2)  // false: s2 is less than s1
```

<p><a id="filepos923633"></a>Using these operators on similarly defined C-style strings compares the pointer values, not the strings themselves:</p>

```c++
const char ca1[] = "A string example";
const char ca2[] = "A different string";
if (ca1 < ca2)  // undefined: compares two unrelated addresses
```

<p>Remember that when we use an array, we are really using a pointer to the first element in the array (§ <a href="034-3.5._arrays.html#filepos881970">3.5.3</a>, p. <a href="034-3.5._arrays.html#filepos881970">117</a>). Hence, this condition actually compares two <code>const char*</code> values. Those pointers do not address the same object, so the comparison is undefined.</p>
<p>To compare the strings, rather than the pointer values, we can call <code>strcmp</code>. That function returns 0 if the strings are equal, or a positive or negative value, depending on whether the first string is larger or smaller than the second:</p>

```c++
if (strcmp(ca1, ca2) < 0) // same effect as string comparison s1 < s2
```

<h5>Caller Is Responsible for Size of a Destination String</h5>
<p>Concatenating or copying C-style strings is also very different from the same operations on library <code>string</code>s. For example, if we wanted to concatenate the two <code>string</code>s <code>s1</code> and <code>s2</code> defined above, we can do so directly:</p>

```c++
// initialize largeStr as a concatenation of s1, a space, and s2
string largeStr = s1 + " " + s2;
```

<p>Doing the same with our two arrays, <code>ca1</code> and <code>ca2</code>, would be an error. The expression <code>ca1 + ca2</code> tries to add two pointers, which is illegal and meaningless.</p>
<p>Instead we can use <code>strcat</code> and <code>strcpy</code>. However, to use these functions, we must pass an array to hold the resulting string. The array we pass <em>must</em> be large enough to hold the generated string, including the null character at the end. The code we show here, although a common usage pattern, is fraught with potential for serious error:</p>

```c++
// disastrous if we miscalculated the size of largeStr
strcpy(largeStr, ca1);     // copies ca1 into largeStr
strcat(largeStr, " ");     // adds a space at the end of largeStr
strcat(largeStr, ca2);     // concatenates ca2 onto largeStr
```

<p>The problem is that we can easily miscalculate the size needed for <code>largeStr</code>. Moreover, any time we change the values we want to store in <code>largeStr</code>, we have to remember to double-check that we calculated its size correctly. Unfortunately, programs similar to this code are widely distributed. Programs with such code are error-prone and often lead to serious security leaks.</p>

::: tip
<p>For most applications, in addition to being safer, it is also more efficient to use library <code>string</code>s rather than C-style strings.</p>
:::

::: info
<a id="filepos930611"></a><p>Exercises Section 3.5.4</p>
<p><strong>Exercise 3.37:</strong> What does the following program do?</p>

```c++
const char ca[] = {'h', 'e', 'l', 'l', 'o'};
const char *cp = ca;
while (*cp) {
    cout << *cp << endl;
    ++cp;
}
```

<p><strong>Exercise 3.38:</strong> In this section, we noted that it was not only illegal but meaningless to try to add two pointers. Why would adding two pointers be meaningless?</p>
<p><strong>Exercise 3.39:</strong> Write a program to compare two <code>string</code>s. Now write a program to compare the values of two C-style character strings.</p>
<p><strong>Exercise 3.40:</strong> Write a program to define two character arrays initialized from string literals. Now define a third character array to hold the concatenation of the two arrays. Use <code>strcpy</code> and <code>strcat</code> to copy the two arrays into the third.</p>
:::

<h4 id="filepos932486">3.5.5. Interfacing to Older Code</h4>
<p>Many C++ programs predate the standard library and do not use the <code>string</code> and <code>vector</code> types. Moreover, many C++ programs interface to programs written in C or other languages that cannot use the C++ library. Hence, programs written in modern C++ may have to interface to code that uses arrays and/or C-style character strings. The C++ library offers facilities to make the interface easier to manage.</p>
<h5>Mixing Library <code>string</code>s and C-Style Strings</h5>
<Badge type="info" text="Fundamental" />
<p>In § <a href="031-3.2._library_string_type.html#filepos651083">3.2.1</a> (p. <a href="031-3.2._library_string_type.html#filepos651083">84</a>) we saw that we can initialize a <code>string</code> from a string literal:</p>

```c++
string s("Hello World");  // s holds Hello World
```

<p>More generally, we can use a null-terminated character array anywhere that we can use a string literal:</p>
<ul><li>We can use a null-terminated character array to initialize or assign a <code>string</code>.</li><li>We can use a null-terminated character array as one operand (but not both operands) to the <code>string</code> addition operator or as the right-hand operand in the <code>string</code> compound assignment (<code>+=</code>) operator.</li></ul>

<p>The reverse functionality is not provided: There is no direct way to use a library <code>string</code> when a C-style string is required. For example, there is no way to initialize a character pointer from a <code>string</code>. There is, however, a <code>string</code> member function named <code>c_str</code> that we can often use to accomplish what we want:</p>

```c++
char *str = s; // error: can't initialize a char* from a string
const char *str = s.c_str(); // ok
```

<p><a id="filepos936545"></a>The name <code>c_str</code> indicates that the function returns a C-style character string. That is, it returns a pointer to the beginning of a null-terminated character array that holds the same data as the characters in the <code>string</code>. The type of the pointer is <code>const char*</code>, which prevents us from changing the contents of the array.</p>
<p>The array returned by <code>c_str</code> is not guaranteed to be valid indefinitely. Any subsequent use of <code>s</code> that might change the value of <code>s</code> can invalidate this array.</p>

::: warning
<p>If a program needs continuing access to the contents of the array returned by <code>str()</code>, the program must copy the array returned by <code>c_str</code>.</p>
:::

<h5>Using an Array to Initialize a <code>vector</code></h5>
<p>In § <a href="034-3.5._arrays.html#filepos855259">3.5.1</a> (p. <a href="034-3.5._arrays.html#filepos855259">114</a>) we noted that we cannot initialize a built-in array from another array. Nor can we initialize an array from a <code>vector</code>. However, we can use an array to initialize a <code>vector</code>. To do so, we specify the address of the first element and one past the last element that we wish to copy:</p>

```c++
int int_arr[] = {0, 1, 2, 3, 4, 5};
// ivec has six elements; each is a copy of the corresponding element in int_arr
vector<int> ivec(begin(int_arr), end(int_arr));
```

<p>The two pointers used to construct <code>ivec</code> mark the range of values to use to initialize the elements in <code>ivec</code>. The second pointer points one past the last element to be copied. In this case, we used the library <code>begin</code> and <code>end</code> functions (§ <a href="034-3.5._arrays.html#filepos881970">3.5.3</a>, p. <a href="034-3.5._arrays.html#filepos881970">118</a>) to pass pointers to the first and one past the last elements in <code>int_arr</code>. As a result, <code>ivec</code> will have six elements each of which will have the same value as the corresponding element in <code>int_arr</code>.</p>
<p>The specified range can be a subset of the array:</p>

```c++
// copies three elements: int_arr[1], int_arr[2], int_arr[3]
vector<int> subVec(int_arr + 1, int_arr + 4);
```

<p>This initialization creates <code>subVec</code> with three elements. The values of these elements are copies of the values in <code>int_arr[1]</code> through <code>int_arr[3]</code>.</p>

::: info
<p>Advice: Use Library Types Instead of Arrays</p>
<p>Pointers and arrays are surprisingly error-prone. Part of the problem is conceptual: Pointers are used for low-level manipulations and it is easy to make bookkeeping mistakes. Other problems arise because of the syntax, particularly the declaration syntax used with pointers.</p>
<p>Modern C++ programs should use <code>vector</code>s and iterators instead of built-in arrays and pointers, and use <code>string</code>s rather than C-style array-based character strings.</p>
:::

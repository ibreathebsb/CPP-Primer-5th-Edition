<h3 id="filepos2617947">10.4. Revisiting Iterators</h3>
<p>In addition to the iterators that are defined for each of the containers, the library defines several additional kinds of iterators in the <code>iterator</code> header. These iterators include</p>
<ul><li><strong>Insert iterators</strong>: These iterators are bound to a container and can be used to insert elements into the container.</li><li><strong><a href="105-defined_terms.html#filepos2718194" id="filepos2618641">Stream iterators</a></strong>: These iterators are bound to input or output streams and can be used to iterate through the associated IO stream.</li><li><strong><a href="105-defined_terms.html#filepos2717790" id="filepos2618932">Reverse iterators</a></strong>: These iterators move backward, rather than forward. The library containers, other than <code>forward_list</code>, have reverse iterators.</li><li><strong><a href="105-defined_terms.html#filepos2715882" id="filepos2619298">Move iterators</a></strong>: These special-purpose iterators move rather than copy their elements. We’ll cover move iterators in § <a href="126-13.6._moving_objects.html#filepos3443291">13.6.2</a> (p. <a href="126-13.6._moving_objects.html#filepos3443291">543</a>).</li></ul>

<h4 id="filepos2619592">10.4.1. Insert Iterators</h4>
<Badge type="info" text="Fundamental" />
<p>An inserter is an iterator adaptor (§ <a href="094-9.6._container_adaptors.html#filepos2426063">9.6</a>, p. <a href="094-9.6._container_adaptors.html#filepos2426063">368</a>) that takes a container and yields an iterator that adds elements to the specified container. When we assign a value through an insert iterator, the iterator calls a container operation to add an element at a specified position in the given container. The operations these iterators support are listed in <a href="101-10.4._revisiting_iterators.html#filepos2620314">Table 10.2</a> (overleaf).</p>
<p><a id="filepos2620314"></a>Table 10.2. Insert Iterator Operations</p>
<img alt="Image" src="/images/00072.jpg"/>
<p><a id="filepos2620513"></a>There are three kinds of inserters. Each differs from the others as to where elements are inserted:</p>
<ul><li><code>back_inserter</code> (§ <a href="099-10.2._a_first_look_at_the_algorithms.html#filepos2485637">10.2.2</a>, p. <a href="099-10.2._a_first_look_at_the_algorithms.html#filepos2485637">382</a>) creates an iterator that uses <code>push_back</code>.</li><li><code>front_inserter</code> creates an iterator that uses <code>push_front</code>.</li><li><code>inserter</code> creates an iterator that uses <code>insert</code>. This function takes a second argument, which must be an iterator into the given container. Elements are inserted ahead of the element denoted by the given iterator.</li></ul>

::: info
<p>We can use <code>front_inserter</code>
<em>only</em> if the container has <code>push_front</code>. Similarly, we can use <code>back_inserter</code>
<em>only</em> if it has <code>push_back</code>.</p>
:::

<p>It is important to understand that when we call <code>inserter(c, iter)</code>, we get an iterator that, when used successively, inserts elements ahead of the element originally denoted by <code>iter</code>. That is, if <code>it</code> is an iterator generated by <code>inserter</code>, then an assignment such as</p>

```c++
* it = va1;
```

<p>behaves as</p>

```c++
it = c.insert(it, val); // it points to the newly added element
++it; // increment it so that it denotes the same element as before
```

<p>The iterator generated by <code>front_inserter</code> behaves quite differently from the one created by <code>inserter</code>. When we use <code>front_inserter</code>, elements are always inserted ahead of the then first element in the container. Even if the position we pass to <code>inserter</code> initially denotes the first element, as soon as we insert an element in front of that element, that element is no longer the one at the beginning of the container:</p>

```c++
list<int> 1st = {1,2,3,4};
list<int> lst2, lst3;     // empty lists
// after copy  completes, 1st2 contains 4 3 2 1
copy(1st.cbegin(), lst.cend(), front_inserter(lst2));
// after copy completes, 1st3 contains 1 2 3 4
copy(1st.cbegin(), lst.cend(), inserter(lst3, lst3.begin()));
```

<p>When we call <code>front_inserter(c)</code>, we get an insert iterator that successively calls <code>push_front</code>. As each element is inserted, it becomes the new first element in <code>c</code>. Therefore, <code>front_inserter</code> yields an iterator that reverses the order of the sequence that it inserts; <code>inserter</code> and <code>back_inserter</code> don’t.</p>

::: info
<a id="filepos2627070"></a><p>Exercises Section 10.4.1</p>
<p><strong>Exercise 10.26:</strong> Explain the differences among the three kinds of insert iterators.</p>
<p><strong>Exercise 10.27:</strong> In addition to <code>unique</code> (§ <a href="099-10.2._a_first_look_at_the_algorithms.html#filepos2506543">10.2.3</a>, p. <a href="099-10.2._a_first_look_at_the_algorithms.html#filepos2506543">384</a>), the library defines function named <code>unique_copy</code> that takes a third iterator denoting a destination into which to copy the unique elements. Write a program that uses <code>unique_copy</code> to copy the unique elements from a <code>vector</code> into an initially empty <code>list</code>.</p>
<p><strong>Exercise 10.28:</strong> Copy a <code>vector</code> that holds the values from <code>1</code> to <code>9</code> inclusive, into three other containers. Use an <code>inserter</code>, a <code>back_inserter</code>, and a <code>front_inserter</code>, respectivly to add elements to these containers. Predict how the output sequence varies by the kind of inserter and verify your predictions by running your programs.</p>
:::

<h4 id="filepos2629061">10.4.2. <code>iostream</code> Iterators</h4>
<Badge type="danger" text="Advanced" />
<p>Even though the <code>iostream</code> types are not containers, there are iterators that can be used with objects of the IO types (§ <a href="083-8.1._the_io_classes.html#filepos2076693">8.1</a>, p. <a href="083-8.1._the_io_classes.html#filepos2076693">310</a>). An <code>istream_iterator</code> (<a href="101-10.4._revisiting_iterators.html#filepos2630479">Table 10.3</a> (overleaf)) reads an input stream, and an <code>ostream_iterator</code> (<a href="101-10.4._revisiting_iterators.html#filepos2630814">Table 10.4</a> (p. <a href="101-10.4._revisiting_iterators.html#filepos2630814">405</a>)) writes an output stream. These iterators treat their corresponding stream as a sequence of elements of a specified type. Using a stream iterator, we can use the generic algorithms to read data from or write data to stream objects.</p>
<p><a id="filepos2630479"></a>Table 10.3. <code>istream_iterator</code> Operations</p>
<img alt="Image" src="/images/00073.jpg"/>
<p><a id="filepos2630814"></a>Table 10.4. <code>ostream</code> Iterator Operations</p>
<img alt="Image" src="/images/00074.jpg"/>
<h5>Operations on <code>istream_iterators</code></h5>
<p>When we create a stream iterator, we must specify the type of objects that the iterator will read or write. An <code>istream_iterator</code> uses <code>&gt;&gt;</code> to read a stream. Therefore, the type that an <code>istream_iterator</code> reads must have an input operator defined. When we create an <code>istream_iterator</code>, we can bind it to a stream. Alternatively, we can default initialize the iterator, which creates an iterator that we can use as the off-the-end value.</p>

```c++
istream_iterator<int> int_it(cin);   //   reads ints from cin
istream_iterator<int> int_eof;       //   end iterator value
ifstream in("afile");
istream_iterator<string> str_it(in); //   reads strings from "afile"
```

<p>As an example, we can use an <code>istream_iterator</code> to read the standard input into a <code>vector</code>:</p>

```c++
istream_iterator<int> in_iter(cin);  // read ints from cin
istream_iterator<int> eof;           // istream ''end'' iterator
while (in_iter != eof)  // while there's valid input to read
    // postfix increment reads the stream and returns the old value of the iterator
    // we dereference that iterator to get the previous value read from the stream
    vec.push_back(*in_iter++);
```

<p>This loop reads <code>int</code>s from <code>cin</code>, storing what was read in <code>vec</code>. On each iteration, the loop checks whether <code>in_iter</code> is the same as <code>eof</code>. That iterator was defined as the empty <code>istream_iterator</code>, which is used as the end iterator. An iterator <a id="filepos2635704"></a>bound to a stream is equal to the end iterator once its associated stream hits end-of-file or encounters an IO error.</p>
<p>The hardest part of this program is the argument to <code>push_back</code>, which uses the dereference and postfix increment operators. This expression works just like others we’ve written that combined dereference with postfix increment (§ <a href="043-4.5._increment_and_decrement_operators.html#filepos1087530">4.5</a>, p. <a href="043-4.5._increment_and_decrement_operators.html#filepos1087530">148</a>). The postfix increment advances the stream by reading the next value but returns the <em>old</em> value of the iterator. That old value contains the previous value read from the stream. We dereference that iterator to obtain that value.</p>
<p>What is more useful is that we can rewrite this program as</p>

```c++
istream_iterator<int> in_iter(cin), eof;  // read ints from cin
vector<int> vec(in_iter, eof);  // construct vec from an iterator range
```

<p>Here we construct <code>vec</code> from a pair of iterators that denote a range of elements. Those iterators are <code>istream_iterator</code>s, which means that the range is obtained by reading the associated stream. This constructor reads <code>cin</code> until it hits end-of-file or encounters an input that is not an <code>int</code>. The elements that are read are used to construct <code>vec</code>.</p>
<h5>Using Stream Iterators with the Algorithms</h5>
<p>Because algorithms operate in terms of iterator operations, and the stream iterators support at least some iterator operations, we can use stream iterators with at least some of the algorithms. We’ll see in § <a href="102-10.5._structure_of_generic_algorithms.html#filepos2673303">10.5.1</a> (p. <a href="102-10.5._structure_of_generic_algorithms.html#filepos2673303">410</a>) how to tell which algorithms can be used with the stream iterators. As one example, we can call <code>accumulate</code> with a pair of <code>istream_iterators</code>:</p>

```c++
istream_iterator<int> in(cin), eof;
cout << accumulate(in, eof, 0) << endl;
```

<p>This call will generate the sum of values read from the standard input. If the input to this program is</p>

```
23 109 45 89 6 34 12 90 34 23 56 23 8 89 23
```

<p>then the output will be <code>664</code>.</p>
<h5><a id="filepos2640063"></a><code>istream_iterator</code>s Are Permitted to Use Lazy Evaluation</h5>
<p>When we bind an <code>istream_iterator</code> to a stream, we are not guaranteed that it will read the stream immediately. The implementation is permitted to delay reading the stream until we use the iterator. We are guaranteed that before we dereference the iterator for the first time, the stream will have been read. For most programs, whether the read is immediate or delayed makes no difference. However, if we create an <code>istream_iterator</code> that we destroy without using or if we are synchronizing reads to the same stream from two different objects, then we might care a great deal when the read happens.</p>
<h5>Operations on <code>ostream_iterator</code>s</h5>
<p>An <code>ostream_iterator</code> can be defined for any type that has an output operator (the <code>&lt;&lt;</code> operator). When we create an <code>ostream_iterator</code>, we may (optionally) provide a second argument that specifies a character string to print following each element. That string must be a C-style character string (i.e., a string literal or a pointer to a null-terminated array). We must bind an <code>ostream_iterator</code> to a specific stream. There is no empty or off-the-end <code>ostream_iterator</code>.</p>
<p>We can use an <code>ostream_iterator</code> to write a sequence of values:</p>

```c++
ostream_iterator<int> out_iter(cout, " ");
for (auto e : vec)
    *out_iter++ = e;  // the assignment writes this element to cout
cout << endl;
```

<p>This program writes each element from <code>vec</code> onto <code>cout</code> following each element with a space. Each time we assign a value to <code>out_iter</code>, the write is committed.</p>
<p>It is worth noting that we can omit the dereference and the increment when we assign to <code>out_iter</code>. That is, we can write this loop equivalently as</p>

```c++
for (auto e : vec)
    out_iter = e;  // the assignment writes this element to cout
cout << endl;
```

<p>The <code>*</code> and <code>++</code> operators do nothing on an <code>ostream_iterator</code>, so omitting them has no effect on our program. However, we prefer to write the loop as first presented. That loop uses the iterator consistently with how we use other iterator <a id="filepos2644645"></a>types. We can easily change this loop to execute on another iterator type. Moreover, the behavior of this loop will be clearer to readers of our code.</p>
<p>Rather than writing the loop ourselves, we can more easily print the elements in <code>vec</code> by calling <code>copy</code>:</p>

```c++
copy(vec.begin(), vec.end(), out_iter);
cout << endl;
```

<h5>Using Stream Iterators with Class Types</h5>
<p>We can create an <code>istream_iterator</code> for any type that has an input operator (<code>&gt;&gt;</code>). Similarly, we can define an <code>ostream_iterator</code> so long as the type has an output operator (<code>&lt;&lt;</code>). Because <code>Sales_item</code> has both input and output operators, we can use IO iterators to rewrite the bookstore program from § <a href="016-1.6._the_bookstore_program.html#filepos244566">1.6</a> (p. <a href="016-1.6._the_bookstore_program.html#filepos244566">24</a>):</p>

```c++
istream_iterator<Sales_item> item_iter(cin), eof;
ostream_iterator<Sales_item> out_iter(cout, "\n");
// store the first transaction in sum and read the next record
Sales_item sum = *item_iter++;
while (item_iter != eof) {
    // if the current transaction (which is stored in item_iter) has the same ISBN
    if (item_iter->isbn() == sum.isbn())
        sum += *item_iter++; // add it to sum and read the next transaction
    else {
        out_iter = sum;      // write the current sum
        sum = *item_iter++;  // read the next transaction
    }
}
out_iter = sum;  // remember to print the last set of records
```

<p>This program uses <code>item_iter</code> to read <code>Sales_item</code> transactions from <code>cin</code>. It uses <code>out_iter</code> to write the resulting sums to <code>cout</code>, following each output with a newline. Having defined our iterators, we use <code>item_iter</code> to initialize <code>sum</code> with the value of the first transaction:</p>

```c++
// store the first transaction in sum and read the next record
Sales_item sum = *item_iter++;
```

<p>Here, we dereference the result of the postfix increment on <code>item_iter</code>. This expression reads the next transaction, and initializes <code>sum</code> from the value previously stored in <code>item_iter</code>.</p>
<p>The <code>while</code> loop executes until we hit end-of-file on <code>cin</code>. Inside the <code>while</code>, we check whether <code>sum</code> and the record we just read refer to the same book. If so, we add the most recently read <code>Sales_item</code> into <code>sum</code>. If the <small>ISBN</small>s differ, we assign <code>sum</code> to <code>out_iter</code>, which prints the current value of <code>sum</code> followed by a newline. Having printed the sum for the previous book, we assign <code>sum</code> a copy of the most recently read transaction and increment the iterator, which reads the next transaction. The loop continues until an error or end-of-file is encountered. Before exiting, we remember to print the values associated with the last book in the input.</p>

::: info
<a id="filepos2651608"></a><p>Exercises Section 10.4.2</p>
<p><strong>Exercise 10.29:</strong> Write a program using stream iterators to read a text file into a <code>vector</code> of <code>string</code>s.</p>
<p><strong>Exercise 10.30:</strong> Use stream iterators, <code>sort</code>, and <code>copy</code> to read a sequence of integers from the standard input, sort them, and then write them back to the standard output.</p>
<p><strong>Exercise 10.31:</strong> Update the program from the previous exercise so that it prints only the unique elements. Your program should use <code>unqiue_copy</code> (§ <a href="101-10.4._revisiting_iterators.html#filepos2619592">10.4.1</a>, p. <a href="101-10.4._revisiting_iterators.html#filepos2619592">403</a>).</p>
<p><strong>Exercise 10.32:</strong> Rewrite the bookstore problem from § <a href="016-1.6._the_bookstore_program.html#filepos244566">1.6</a> (p. <a href="016-1.6._the_bookstore_program.html#filepos244566">24</a>) using a <code>vector</code> to hold the transactions and various algorithms to do the processing. Use <code>sort</code> with your <code>compareIsbn</code> function from § <a href="100-10.3._customizing_operations.html#filepos2520495">10.3.1</a> (p. <a href="100-10.3._customizing_operations.html#filepos2520495">387</a>) to arrange the transactions in order, and then use <code>find</code> and <code>accumulate</code> to do the sum.</p>
<p><strong>Exercise 10.33:</strong> Write a program that takes the names of an input file and two output files. The input file should hold integers. Using an <code>istream_iterator</code> read the input file. Using <code>ostream_iterator</code>s, write the odd numbers into the first output file. Each value should be followed by a space. Write the even numbers into the second file. Each of these values should be placed on a separate line.</p>
:::

<h4 id="filepos2654416">10.4.3. Reverse Iterators</h4>
<p>A reverse iterator is an iterator that traverses a container backward, from the last element toward the first. A reverse iterator inverts the meaning of increment (and decrement). Incrementing (<code>++it</code>) a reverse iterator moves the iterator to the previous element; derementing <code>(--it</code>) moves the iterator to the next element.</p>
<p>The containers, aside from <code>forward_list</code>, all have reverse iterators. We obtain a reverse iterator by calling the <code>rbegin</code>, <code>rend</code>, <code>crbegin</code>, and <code>crend</code> members. These members return reverse iterators to the last element in the container and one “past” (i.e., one before) the beginning of the container. As with ordinary iterators, there are both <code>const</code> and non<code>const</code> reverse iterators.</p>
<p><a href="101-10.4._revisiting_iterators.html#filepos2656256">Figure 10.1</a> illustrates the relationship between these four iterators on a hypothetical <code>vector</code> named <code>vec</code>.</p>
<a id="filepos2656256"></a><img alt="Image" src="/images/00075.jpg"/>
<p>Figure 10.1. Comparing <code>begin/cend</code> and <code>rbegin/crend</code> Iterators</p>
<p>As an example, the following loop prints the elements of <code>vec</code> in reverse order:</p>
<p><a id="filepos2656969"></a></p>

```c++
vector<int> vec = {0,1,2,3,4,5,6,7,8,9};
// reverse iterator of vector from back to front
for (auto r_iter = vec.crbegin(); // binds r_iter to the last element
          r_iter != vec.crend();  // crend refers 1 before 1st element
          ++r_iter)               // decrements the iterator one element
    cout << *r_iter << endl;      // prints 9, 8, 7,... 0
```

<p>Although it may seem confusing to have the meaning of the increment and decrement operators reversed, doing so lets us use the algorithms transparently to process a container forward or backward. For example, we can sort our <code>vector</code> in descending order by passing <code>sort</code> a pair of reverse iterators:</p>

```c++
sort(vec.begin(), vec.end()); // sorts vec in ''normal'' order
// sorts in reverse: puts the smallest element at the end of vec
sort(vec.rbegin(), vec.rend());
```

<h5>Reverse Iterators Require Decrement Operators</h5>
<p>Not surprisingly, we can define a reverse iterator only from an iterator that supports <code>--</code> as well as <code>++</code>. After all, the purpose of a reverse iterator is to move the iterator backward through the sequence. Aside from <code>forward_list</code>, the iterators on the standard containers all support decrement as well as increment. However, the stream iterators do not, because it is not possible to move backward through a stream. Therefore, it is not possible to create a reverse iterator from a <code>forward_list</code> or a stream iterator.</p>
<h5>Relationship between Reverse Iterators and Other Iterators</h5>
<img alt="Image" src="/images/00011.jpg"/>
<p>Suppose we have a <code>string</code> named <code>line</code> that contains a comma-separated list of words, and we want to print the first word in <code>line</code>. Using <code>find</code>, this task is easy:</p>

```c++
// find the first element in a comma-separated list
auto comma = find(line.cbegin(), line.cend(), ',');
cout << string(line.cbegin(), comma) << endl;
```

<p>If there is a comma in <code>line</code>, then <code>comma</code> refers to that comma; otherwise it is <code>line.cend()</code>. When we print the <code>string</code> from <code>line.cbegin()</code> to <code>comma</code>, we print characters up to the comma, or the entire <code>string</code> if there is no comma.</p>
<p>If we wanted the last word, we can use reverse iterators instead:</p>

```c++
// find the last element in a comma-separated list
auto rcomma = find(line.crbegin(), line.crend(), ',');
```

<p>Because we pass <code>crbegin()</code> and <code>crend()</code>, this call starts with the last character in <code>line</code> and searches backward. When <code>find</code> completes, if there is a comma, then <code>rcomma</code> refers to the last comma in the line—that is, it refers to the first comma found in the backward search. If there is no comma, then <code>rcomma</code> is <code>line.crend()</code>.</p>
<p>The interesting part comes when we try to print the word we found. The seemingly obvious way</p>

```c++
// WRONG: will generate the word in reverse order
cout << string(line.crbegin(), rcomma) << endl;
```

<p><a id="filepos2664962"></a>generates bogus output. For example, had our input been</p>

```
FIRST,MIDDLE,LAST
```

<p>then this statement would print <code>TSAL!</code></p>
<p><a href="101-10.4._revisiting_iterators.html#filepos2667404">Figure 10.2</a> illustrates the problem: We are using reverse iterators, which process the <code>string</code> backward. Therefore, our output statement prints from <code>crbegin</code> backward through <code>line</code>. Instead, we want to print from <code>rcomma</code> forward to the end of <code>line</code>. However, we can’t use <code>rcomma</code> directly. That iterator is a reverse iterator, which means that it goes backward toward the beginning of the <code>string</code>. What we need to do is transform <code>rcomma</code> back into an ordinary iterator that will go forward through <code>line</code>. We can do so by calling the <code>reverse_iterator</code>’s <code>base</code> member, which gives us its corresponding ordinary iterator:</p>

```c++
// ok: get a forward iterator and read to the end of line
cout << string(rcomma.base(), line.cend()) << endl;
```

<a id="filepos2667404"></a><img alt="Image" src="/images/00076.jpg"/>
<p>Figure 10.2. Relationship between Reverse and Ordinary Iterators</p>
<p>Given the same preceding input, this statement prints <code>LAST</code> as expected.</p>
<p>The objects shown in <a href="101-10.4._revisiting_iterators.html#filepos2667404">Figure 10.2</a> illustrate the relationship between ordinary and reverse iterators. For example, <code>rcomma</code> and <code>rcomma.base()</code> refer to different elements, as do <code>line.crbegin()</code> and <code>line.cend()</code>. These differences are needed to ensure that the <em>range</em> of elements, whether processed forward or backward, is the same.</p>
<p>Technically speaking, the relationship between normal and reverse iterators accommodates the properties of a left-inclusive range (§ <a href="090-9.2._container_library_overview.html#filepos2196283">9.2.1</a>, p. <a href="090-9.2._container_library_overview.html#filepos2196283">331</a>). The point is that <code>[line.crbegin(), rcomma)</code> and <code>[rcomma.base(), line.cend())</code> refer to the same elements in <code>line</code>. In order for that to happen, <code>rcomma</code> and <code>rcomma.base()</code> must yield adjacent positions, rather than the same position, as must <code>crbegin()</code> and <code>cend()</code>.</p>

::: info
<p>The fact that reverse iterators are intended to represent ranges and that these ranges are asymmetric has an important consequence: When we initialize or assign a reverse iterator from a plain iterator, the resulting iterator does not refer to the same element as the original.</p>
:::

::: info
<a id="filepos2670101"></a><p>Exercises Section 10.4.3</p>
<p><strong>Exercise 10.34:</strong> Use <code>reverse_iterator</code>s to print a <code>vector</code> in reverse order.</p>
<p><strong>Exercise 10.35:</strong> Now print the elements in reverse order using ordinary iterators.</p>
<p><strong>Exercise 10.36:</strong> Use <code>find</code> to find the last element in a <code>list</code> of <code>int</code>s with value 0.</p>
<p><strong>Exercise 10.37:</strong> Given a <code>vector</code> that has ten elements, copy the elements from positions 3 through 7 in reverse order to a <code>list</code>.</p>
:::

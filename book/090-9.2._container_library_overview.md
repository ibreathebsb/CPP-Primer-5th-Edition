<h3 id="filepos2188055">9.2. Container Library Overview</h3>
<img alt="Image" src="/images/00009.jpg"/>
<p>The operations on the container types form a kind of hierarchy:</p>
<ul><li>Some operations (<a href="090-9.2._container_library_overview.html#filepos2188610">Table 9.2</a> (p. <a href="090-9.2._container_library_overview.html#filepos2188610">330</a>)) are provided by all container types.</li></ul>
<p><a id="filepos2188610"></a>Table 9.2. Container Operations</p>
<img alt="Image" src="/images/00047.jpg"/>
<img alt="Image" src="/images/00048.jpg"/>
<ul><li>Other operations are specific to the sequential (<a href="090-9.2._container_library_overview.html#filepos2189318">Table 9.3</a> (p. <a href="090-9.2._container_library_overview.html#filepos2189318">335</a>)), the associative (<a href="109-11.3._operations_on_associative_containers.html#filepos2831111">Table 11.7</a> (p. <a href="109-11.3._operations_on_associative_containers.html#filepos2831111">438</a>)), or the unordered (<a href="110-11.4._the_unordered_containers.html#filepos2880096">Table 11.8</a> (p. <a href="110-11.4._the_unordered_containers.html#filepos2880096">445</a>)) containers.</li></ul>
<p><a id="filepos2189318"></a>Table 9.3. Defining and Initializing Containers</p>
<img alt="Image" src="/images/00049.jpg"/>
<ul><li>Still others are common to only a smaller subset of the containers.</li></ul>
<p><a id="filepos2189692"></a>In this section, we’ll cover aspects common to all of the containers. The remainder of this chapter will then focus solely on sequential containers; we’ll cover operations specific to the associative containers in <a href="106-chapter_11._associative_containers.html#filepos2718579">Chapter 11</a>.</p>
<p>In general, each container is defined in a header file with the same name as the type. That is, <code>deque</code> is in the <code>deque</code> header, <code>list</code> in the <code>list</code> header, and so on. The containers are class templates (§ <a href="032-3.3._library_vector_type.html#filepos736471">3.3</a>, p. <a href="032-3.3._library_vector_type.html#filepos736471">96</a>). As with <code>vector</code>s, we must supply additional information to generate a particular container type. For most, but not all, of the containers, the information we must supply is the element type:</p>

```c++
list<Sales_data>   // list that holds Sales_data objects
deque<double>      // deque that holds doubles
```

<h4>Constraints on Types That a Container Can Hold</h4>
<p>Almost any type can be used as the element type of a sequential container. In particular, we can define a container whose element type is itself another container. We define such containers exactly as we do any other container type: We specify the element type (which in this case is a container type) inside angle brackets:</p>

```c++
vector<vector<string>> lines;      // vector of vectors
```

<p>Here <code>lines</code> is a <code>vector</code> whose elements are <code>vectors</code> of <code>string</code>s.</p>
<img alt="Image" src="/images/00008.jpg"/>

::: info
<p>Note</p>
<p>Older compilers may require a space between the angle brackets, for example, <code>vector&lt;vector&lt;string&gt; &gt;</code>.</p>
:::

<p>Although we can store almost any type in a container, some container operations impose requirements of their own on the element type. We can define a container for a type that does not support an operation-specific requirement, but we can use an operation only if the element type meets that operation’s requirements.</p>
<p>As an example, the sequential container constructor that takes a size argument (§ <a href="032-3.3._library_vector_type.html#filepos744172">3.3.1</a>, p. <a href="032-3.3._library_vector_type.html#filepos744172">98</a>) uses the element type’s default constructor. Some classes do not have a default constructor. We can define a container that holds objects of such types, but we cannot construct such containers using only an element count:</p>

```c++
// assume noDefault is a type without a default constructor
vector<noDefault> v1(10, init); // ok: element initializer supplied
vector<noDefault> v2(10);       // error: must supply an element initializer
```

<p>As we describe the container operations, we’ll note the additional constraints, if any, that each container operation places on the element type.</p>

::: info
<p>Exercises Section 9.2</p>
<p><strong>Exercise 9.2:</strong> Define a <code>list</code> that holds elements that are <code>deque</code>s that hold <code>int</code>s.</p>
:::

<h4 id="filepos2196283"><a id="filepos2196324"></a>9.2.1. Iterators</h4>
<img alt="Image" src="/images/00009.jpg"/>
<p>As with the containers, iterators have a common interface: If an iterator provides an operation, then the operation is supported in the same way for each iterator that supplies that operation. For example, all the iterators on the standard container types let us access an element from a container, and they all do so by providing the dereference operator. Similarly, the iterators for the library containers all define the increment operator to move from one element to the next.</p>
<p>With one exception, the container iterators support all the operations listed in <a href="033-3.4._introducing_iterators.html#filepos810064">Table 3.6</a> (p. <a href="033-3.4._introducing_iterators.html#filepos810064">107</a>). The exception is that the <code>forward_list</code> iterators do not support the decrement (<code>--</code>) operator. The iterator arithmetic operations listed in <a href="033-3.4._introducing_iterators.html#filepos840512">Table 3.7</a> (p. <a href="033-3.4._introducing_iterators.html#filepos840512">111</a>) apply only to iterators for <code>string, vector, deque</code>, and <code>array</code>. We cannot use these operations on iterators for any of the other container types.</p>
<h5>Iterator Ranges</h5>

::: info
<p>Note</p>
<p>The concept of an iterator range is fundamental to the standard library.</p>
:::

<p>An <strong><a href="096-defined_terms.html#filepos2449746" id="filepos2198345">iterator range</a></strong> is denoted by a pair of iterators each of which refers to an element, or to <em>one past the last element,</em> in the same container. These two iterators, often referred to as <code>begin</code> and <code>end</code>—or (somewhat misleadingly) as <code>first</code> and <code>last</code>—mark a range of elements from the container.</p>
<p>The name <code>last</code>, although commonly used, is a bit misleading, because the second iterator never refers to the last element of the range. Instead, it refers to a point one past the last element. The elements in the range include the element denoted by <code>first</code> and every element from <code>first</code> up to but not including <code>last</code>.</p>
<p>This element range is called a <strong><a href="096-defined_terms.html#filepos2450433" id="filepos2199691">left-inclusive interval</a></strong>. The standard mathematical notation for such a range is</p>

```
[ begin, end)
```

<p>indicating that the range begins with <code>begin</code> and ends with, but does not include, <code>end</code>. The iterators <code>begin</code> and <code>end</code> must refer to the same container. The iterator <code>end</code> may be equal to <code>begin</code> but must not refer to an element before the one denoted by <code>begin</code>.</p>

::: warning
<p>Requirements on Iterators Forming an Iterator Range</p>
<p>Two iterators, <code>begin</code> and <code>end</code>, form an iterator range, if</p>
<p>• They refer to elements of, or one past the end of, the same container, and</p>
<p>• It is possible to reach <code>end</code> by repeatedly incrementing <code>begin</code>. In other words, <code>end</code> must not precede <code>begin</code>.</p>
<p>Warning</p>
<p>The compiler cannot enforce these requirements. It is up to us to ensure that our programs follow these conventions.</p>
:::

<h5><a id="filepos2202427"></a>Programming Implications of Using Left-Inclusive Ranges</h5>
<p>The library uses left-inclusive ranges because such ranges have three convenient properties. Assuming <code>begin</code> and <code>end</code> denote a valid iterator range, then</p>
<ul><li>If <code>begin</code> equals <code>end</code>, the range is empty</li><li>If <code>begin</code> is not equal to <code>end</code>, there is at least one element in the range, and <code>begin</code> refers to the first element in that range</li><li>We can increment <code>begin</code> some number of times until <code>begin == end</code></li></ul>

<p>These properties mean that we can safely write loops such as the following to process a range of elements:</p>

```c++
while (begin   != end) {
    *begin =  val;    // ok: range isn't empty so begin denotes an element
    ++begin;          // advance the iterator to get the next element
}
```

<p>Given that <code>begin</code> and <code>end</code> form a valid iterator range, we know that if <code>begin</code> == <code>end</code>, then the range is empty. In this case, we exit the loop. If the range is nonempty, we know that <code>begin</code> refers to an element in this nonempty range. Therefore, inside the body of the <code>while</code>, we know that it is safe to dereference <code>begin</code> because <code>begin</code> must refer to an element. Finally, because the loop body increments <code>begin</code>, we also know the loop will eventually terminate.</p>

::: info
<p>Exercises Section 9.2.1</p>
<p><strong>Exercise 9.3:</strong> What are the constraints on the iterators that form iterator ranges?</p>
<p><strong>Exercise 9.4:</strong> Write a function that takes a pair of iterators to a <code>vector&lt;int&gt;</code> and an <code>int</code> value. Look for that value in the range and return a <code>bool</code> indicating whether it was found.</p>
<p><strong>Exercise 9.5:</strong> Rewrite the previous program to return an iterator to the requested element. Note that the program must handle the case where the element is not found.</p>
<p><strong>Exercise 9.6:</strong> What is wrong with the following program? How might you correct it?</p>

```c++
list<int> lst1;
list<int>::iterator iter1 = lst1.begin(),
                    iter2 = lst1.end();
while (iter1 < iter2) /* ... */
```

:::

<h4 id="filepos2207848">9.2.2. Container Type Members</h4>
<p>Each container defines several types, shown in <a href="090-9.2._container_library_overview.html#filepos2188610">Table 9.2</a> (p. <a href="090-9.2._container_library_overview.html#filepos2188610">330</a>). We have already used three of these container-defined types: <code>size_type</code> (§ <a href="031-3.2._library_string_type.html#filepos659212">3.2.2</a>, p. <a href="031-3.2._library_string_type.html#filepos659212">88</a>), <code>iterator</code>, and <code>const_iterator</code> (§ <a href="033-3.4._introducing_iterators.html#filepos804727">3.4.1</a>, p. <a href="033-3.4._introducing_iterators.html#filepos804727">108</a>).</p>
<p><a id="filepos2208614"></a>In addition to the iterator types we’ve already used, most containers provide reverse iterators. Briefly, a reverse iterator is an iterator that goes backward through a container and inverts the meaning of the iterator operations. For example, saying <code>++</code> on a reverse iterator yields the previous element. We’ll have more to say about reverse iterators in § <a href="101-10.4._revisiting_iterators.html#filepos2654416">10.4.3</a> (p. <a href="101-10.4._revisiting_iterators.html#filepos2654416">407</a>).</p>
<p>The remaining type aliases let us use the type of the elements stored in a container without knowing what that type is. If we need the element type, we refer to the container’s <code>value_type</code>. If we need a reference to that type, we use <code>reference</code> or <code>const_reference</code>. These element-related type aliases are most useful in generic programs, which we’ll cover in <a href="153-chapter_16._templates_and_generic_programming.html#filepos4150078">Chapter 16</a>.</p>
<p>To use one of these types, we must name the class of which they are a member:</p>

```c++
// iter is the iterator type defined by list<string>
list<string>::iterator iter;
// count is the difference_type type defined by vector<int>
vector<int>::difference_type count;
```

<p>These declarations use the scope operator (§ <a href="012-1.2._a_first_look_at_inputoutput.html#filepos136281">1.2</a>, p. <a href="012-1.2._a_first_look_at_inputoutput.html#filepos136281">8</a>) to say that we want the <code>iterator</code> member of the <code>list&lt;string&gt;</code> class and the <code>difference_type</code> defined by <code>vector&lt;int&gt;</code>, respectively.</p>

::: info
<p>Exercises Section 9.2.2</p>
<p><strong>Exercise 9.7:</strong> What type should be used as the index into a <code>vector</code> of <code>int</code>s?</p>
<p><strong>Exercise 9.8:</strong> What type should be used to read elements in a <code>list</code> of <code>string</code>s? To write them?</p>
:::

<h4 id="filepos2212546">9.2.3. <code>begin</code> and <code>end</code> Members</h4>
<img alt="Image" src="/images/00009.jpg"/>
<p>The <code>begin</code> and <code>end</code> operations (§ <a href="033-3.4._introducing_iterators.html#filepos804727">3.4.1</a>, p. <a href="033-3.4._introducing_iterators.html#filepos804727">106</a>) yield iterators that refer to the first and one past the last element in the container. These iterators are most often used to form an iterator range that encompasses all the elements in the container.</p>
<p>As shown in <a href="090-9.2._container_library_overview.html#filepos2188610">Table 9.2</a> (p. <a href="090-9.2._container_library_overview.html#filepos2188610">330</a>), there are several versions of <code>begin</code> and <code>end</code>: The versions with an <code>r</code> return reverse iterators (which we cover in § <a href="101-10.4._revisiting_iterators.html#filepos2654416">10.4.3</a> (p. <a href="101-10.4._revisiting_iterators.html#filepos2654416">407</a>)). Those that start with a <code>c</code> return the <code>const</code> version of the related iterator:</p>

```c++
list<string> a = {"Milton", "Shakespeare", "Austen"};
auto it1 = a.begin();  // list<string>::iterator
auto it2 = a.rbegin(); // list<string>::reverse_iterator
auto it3 = a.cbegin(); // list<string>::const_iterator
auto it4 = a.crbegin();// list<string>::const_reverse_iterator
```

<p>The functions that do not begin with a <code>c</code> are overloaded. That is, there are actually two members named <code>begin</code>. One is a <code>const</code> member (§ <a href="073-7.1._defining_abstract_data_types.html#filepos1761316">7.1.2</a>, p. <a href="073-7.1._defining_abstract_data_types.html#filepos1761316">258</a>) that returns the container’s <code>const_iterator</code> type. The other is non<code>const</code> and returns the container’s <code>iterator</code> type. Similarly for <code>rbegin</code>, <code>end</code>, and <code>rend</code>. When we <a id="filepos2216072"></a>call one of these members on a non<code>const</code> object, we get the version that returns <code>iterator</code>. We get a <code>const</code> version of the iterators <em>only</em> when we call these functions on a <code>const</code> object. As with pointers and references to <code>const</code>, we can convert a plain <code>iterator</code> to the corresponding <code>const_iterator</code>, but not vice versa.</p>
<a id="filepos2216888"></a><img alt="Image" src="/images/00008.jpg"/>
<p>The <code>c</code> versions were introduced by the new standard to support using <code>auto</code> with <code>begin</code> and <code>end</code> functions (§ <a href="025-2.5._dealing_with_types.html#filepos544751">2.5.2</a>, p. <a href="025-2.5._dealing_with_types.html#filepos544751">68</a>). In the past, we had no choice but to say which type of iterator we want:</p>

```c++
// type is explicitly specified
list<string>::iterator it5 = a.begin();
list<string>::const_iterator it6 = a.begin();
// iterator or const_iterator depending on a's type of a
auto it7 = a.begin();  // const_iterator only if a is const
auto it8 = a.cbegin(); // it8 is const_iterator
```

<p>When we use <code>auto</code> with <code>begin</code> or <code>end</code>, the iterator type we get depends on the container type. How we intend to use the iterator is irrelevant. The <code>c</code> versions let us get a <code>const_iterator</code> regardless of the type of the container.</p>

::: tip
<p>Best Practices</p>
<p>When write access is not needed, use <code>cbegin</code> and <code>cend</code>.</p>
:::

::: info
<p>Exercises Section 9.2.3</p>
<p><strong>Exercise 9.9:</strong> What is the difference between the <code>begin</code> and <code>cbegin</code> functions?</p>
<p><strong>Exercise 9.10:</strong> What are the types of the following four objects?</p>

```c++
vector<int> v1;
const vector<int> v2;
auto it1 = v1.begin(), it2 = v2.begin();
auto it3 = v1.cbegin(), it4 = v2.cbegin();
```

:::

<h4 id="filepos2221429">9.2.4. Defining and Initializing a Container</h4>
<img alt="Image" src="/images/00009.jpg"/>
<p>Every container type defines a default constructor (§ <a href="073-7.1._defining_abstract_data_types.html#filepos1802479">7.1.4</a>, p. <a href="073-7.1._defining_abstract_data_types.html#filepos1802479">263</a>). With the exception of <code>array</code>, the default constructor creates an empty container of the specified type. Again excepting <code>array</code>, the other constructors take arguments that specify the size of the container and initial values for the elements.</p>
<h5>Initializing a Container as a Copy of Another Container</h5>
<p>There are two ways to create a new container as a copy of another one: We can directly copy the container, or (excepting <code>array</code>) we can copy a range of elements denoted by a pair of iterators.</p>
<p>To create a container as a copy of another container, the container and element types must match. When we pass iterators, there is no requirement that the container types be identical. Moreover, the element types in the new and original <a id="filepos2222871"></a>containers can differ as long as it is possible to convert (§ <a href="049-4.11._type_conversions.html#filepos1157818">4.11</a>, p. <a href="049-4.11._type_conversions.html#filepos1157818">159</a>) the elements we’re copying to the element type of the container we are initializing:</p>

```c++
// each container has three elements, initialized from the given initializers
list<string> authors = {"Milton", "Shakespeare", "Austen"};
vector<const char*> articles = {"a", "an", "the"};
list<string> list2(authors);     // ok: types match
deque<string> authList(authors); // error: container types don't match
vector<string> words(articles);  // error: element types must match
// ok: converts const char* elements to string
forward_list<string> words(articles.begin(), articles.end());
```

::: info
<p>Note</p>
<p>When we initialize a container as a copy of another container, the container type and element type of both containers must be identical.</p>
:::

<p>The constructor that takes two iterators uses them to denote a range of elements that we want to copy. As usual, the iterators mark the first and one past the last element to be copied. The new container has the same size as the number of elements in the range. Each element in the new container is initialized by the value of the corresponding element in the range.</p>
<p>Because the iterators denote a range, we can use this constructor to copy a subsequence of a container. For example, assuming <code>it</code> is an iterator denoting an element in <code>authors</code>, we can write</p>

```c++
// copies up to but not including the element denoted by it
deque<string> authList(authors.begin(), it);
```

<h5><a id="filepos2226365"></a>List Initialization</h5>
<a id="filepos2226442"></a><img alt="Image" src="/images/00008.jpg"/>
<p>Under the new standard, we can list initialize (§ <a href="032-3.3._library_vector_type.html#filepos744172">3.3.1</a>, p. <a href="032-3.3._library_vector_type.html#filepos744172">98</a>) a container:</p>

```c++
// each container has three elements, initialized from the given initializers
list<string> authors = {"Milton", "Shakespeare", "Austen"};
vector<const char*> articles = {"a", "an", "the"};
```

<p>When we do so, we explicitly specify values for each element in the container. For types other than <code>array</code>, the initializer list also implicitly specifies the size of the container: The container will have as many elements as there are initializers.</p>
<h5>Sequential Container Size-Related Constructors</h5>
<p>In addition to the constructors that sequential containers have in common with associative containers, we can also initialize the sequential containers (other than <code>array</code>) from a size and an (optional) element initializer. If we do not supply an element initializer, the library creates a value-initialized one for us § <a href="032-3.3._library_vector_type.html#filepos744172">3.3.1</a> (p. <a href="032-3.3._library_vector_type.html#filepos744172">98</a>):</p>

```c++
vector<int> ivec(10, -1);        // ten int elements, each initialized to -1
list<string> svec(10, "hi!");    // ten strings; each element is  "hi!"
forward_list<int> ivec(10);      // ten elements, each initialized to 0
deque<string> svec(10);          // ten elements, each an empty string
```

<p>We can use the constructor that takes a size argument if the element type is a built-in type or a class type that has a default constructor (§ <a href="090-9.2._container_library_overview.html#filepos2188055">9.2</a>, p. <a href="090-9.2._container_library_overview.html#filepos2188055">329</a>). If the element type does not have a default constructor, then we must specify an explicit element initializer along with the size.</p>

::: info
<p>Note</p>
<p>The constructors that take a size are valid <em>only</em> for sequential containers; they are not supported for the associative containers.</p>
:::

<h5>Library <code>array</code>s Have Fixed Size</h5>
<p>Just as the size of a built-in array is part of its type, the size of a library <code>array</code> is part of its type. When we define an <code>array</code>, in addition to specifying the element type, we also specify the container size:</p>

```c++
array<int, 42>    // type is: array that holds 42 ints
array<string, 10> // type is: array that holds 10 strings
```

<p>To use an <code>array</code> type we must specify both the element type and the size:</p>

```c++
array<int, 10>::size_type i; // array type includes element type and size
array<int>::size_type j;     // error: array<int> is not a type
```

<p>Because the size is part of the <code>array</code>’s type, <code>array</code> does not support the normal container constructors. Those constructors, implicitly or explicitly, determine the size of the container. It would be redundant (at best) and error-prone to allow users to pass a size argument to an <code>array</code> constructor.</p>
<p>The fixed-size nature of <code>array</code>s also affects the behavior of the constructors that <code>array</code> does define. Unlike the other containers, a default-constructed <code>array</code>
<a id="filepos2234338"></a>is not empty: It has as many elements as its size. These elements are default initialized (§ <a href="022-2.2._variables.html#filepos350704">2.2.1</a>, p. <a href="022-2.2._variables.html#filepos350704">43</a>) just as are elements in a built-in array (§ <a href="034-3.5._arrays.html#filepos855259">3.5.1</a>, p. <a href="034-3.5._arrays.html#filepos855259">114</a>). If we list initialize the <code>array</code>, the number of the initializers must be equal to or less than the size of the <code>array</code>. If there are fewer initializers than the size of the <code>array</code>, the initializers are used for the first elements and any remaining elements are value initialized (§ <a href="032-3.3._library_vector_type.html#filepos744172">3.3.1</a>, p. <a href="032-3.3._library_vector_type.html#filepos744172">98</a>). In both cases, if the element type is a class type, the class must have a default constructor in order to permit value initialization:</p>

```c++
array<int, 10> ia1;  // ten default-initialized ints
array<int, 10> ia2 = {0,1,2,3,4,5,6,7,8,9};  // list initialization
array<int, 10> ia3 = {42};  // ia3[0] is 42, remaining elements are 0
```

<p>It is worth noting that although we cannot copy or assign objects of built-in array types (§ <a href="034-3.5._arrays.html#filepos855259">3.5.1</a>, p. <a href="034-3.5._arrays.html#filepos855259">114</a>), there is no such restriction on <code>array</code>:</p>

```c++
int digs[10] = {0,1,2,3,4,5,6,7,8,9};
int cpy[10] = digs;  // error: no copy or assignment for built-in arrays
array<int, 10> digits = {0,1,2,3,4,5,6,7,8,9};
array<int, 10> copy = digits;  // ok: so long as array types match
```

<p>As with any container, the initializer must have the same type as the container we are creating. For <code>array</code>s, the element type and the size must be the same, because the size of an <code>array</code> is part of its type.</p>

::: info
<p>Exercises Section 9.2.4</p>
<p><strong>Exercise 9.11:</strong> Show an example of each of the six ways to create and initialize a <code>vector</code>. Explain what values each <code>vector</code> contains.</p>
<p><strong>Exercise 9.12:</strong> Explain the differences between the constructor that takes a container to copy and the constructor that takes two iterators.</p>
<p><strong>Exercise 9.13:</strong> How would you initialize a <code>vector&lt;double&gt;</code> from a <code>list&lt;int&gt;</code>? From a <code>vector&lt;int&gt;</code>? Write code to check your answers.</p>
:::

<h4 id="filepos2239281">9.2.5. Assignment and <code>swap</code></h4>
<p>The assignment-related operators, listed in <a href="090-9.2._container_library_overview.html#filepos2240913">Table 9.4</a> (overleaf) act on the entire container. The assignment operator replaces the entire range of elements in the left-hand container with copies of the elements from the right-hand operand:</p>

```c++
c1 = c2;      // replace the contents of c1 with a copy of the elements in c2
c1 = {a,b,c}; // after the assignment c1 has size 3
```

<p><a id="filepos2240913"></a>Table 9.4. Container Assignment Operations</p>
<img alt="Image" src="/images/00050.jpg"/>
<p>After the first assignment, the left- and right-hand containers are equal. If the containers had been of unequal size, after the assignment both containers would have the size of the right-hand operand. After the second assignment, the <code>size</code> of <code>c1</code> is 3, which is the number of values provided in the braced list.</p>
<p><a id="filepos2241618"></a>Unlike built-in arrays, the library <code>array</code> type does allow assignment. The left-and right-hand operands must have the same type:</p>

```c++
array<int, 10> a1 = {0,1,2,3,4,5,6,7,8,9};
array<int, 10> a2 = {0}; // elements all have value 0
a1 = a2;  // replaces elements in a1
a2 = {0}; // error: cannot assign to an array from a braced list
```

<p>Because the size of the right-hand operand might differ from the size of the left-hand operand, the <code>array</code> type does not support <code>assign</code> and it does not allow assignment from a braced list of values.</p>
<h5>Using <code>assign</code> (Sequential Containers Only)</h5>
<p>The assignment operator requires that the left-hand and right-hand operands have the same type. It copies all the elements from the right-hand operand into the left-hand operand. The sequential containers (except <code>array</code>) also define a member named <code>assign</code> that lets us assign from a different but compatible type, or assign from a subsequence of a container. The <code>assign</code> operation replaces all the elements in the left-hand container with (copies of) the elements specified by its arguments. For example, we can use <code>assign</code> to assign a range of <code>char*</code> values from a <code>vector</code> into a <code>list</code> of <code>string</code>:</p>

```c++
list<string> names;
vector<const char*> oldstyle;
names = oldstyle;  // error: container types don't match
// ok: can convert from const char*to string
names.assign(oldstyle.cbegin(), oldstyle.cend());
```

<p><a id="filepos2245488"></a>The call to <code>assign</code> replaces the elements in <code>names</code> with copies of the elements in the range denoted by the iterators. The arguments to <code>assign</code> determine how many elements and what values the container will have.</p>

::: warning
<p>Warning</p>
<p>Because the existing elements are replaced, the iterators passed to <code>assign</code> must not refer to the container on which <code>assign</code> is called.</p>
:::

<p>A second version of <code>assign</code> takes an integral value and an element value. It replaces the elements in the container with the specified number of elements, each of which has the specified element value:</p>

```c++
// equivalent to slist1.clear();
// followed by slist1.insert(slist1.begin(), 10, "Hiya!");
list<string> slist1(1);     // one element, which is the empty string
slist1.assign(10, "Hiya!"); // ten elements; each one is Hiya !
```

<h5>Using <code>swap</code></h5>
<p>The <code>swap</code> operation exchanges the contents of two containers of the same type. After the call to <code>swap</code>, the elements in the two containers are interchanged:</p>

```c++
vector<string> svec1(10); // vector with ten elements
vector<string> svec2(24); // vector with 24 elements
swap(svec1, svec2);
```

<p>After the <code>swap, svec1</code> contains 24 <code>string</code> elements and <code>svec2</code> contains ten. With the exception of <code>array</code>s, swapping two containers is guaranteed to be fast—the elements themselves are not swapped; internal data structures are swapped.</p>

::: info
<p>Note</p>
<p>Excepting <code>array, swap</code> does not copy, delete, or insert any elements and is guaranteed to run in constant time.</p>
:::

<p>The fact that elements are not moved means that, with the exception of <code>string</code>, iterators, references, and pointers into the containers are not invalidated. They refer to the same elements as they did before the swap. However, after the <code>swap</code>, those elements are in a different container. For example, had <code>iter</code> denoted the <code>string</code> at position <code>svec1 [3]</code> before the <code>swap</code>, it will denote the element at position <code>svec2[3]</code> after the <code>swap</code>. Differently from the containers, a call to <code>swap</code> on a <code>string</code> may invalidate iterators, references and pointers.</p>
<p>Unlike how <code>swap</code> behaves for the other containers, swapping two <code>array</code>s does exchange the elements. As a result, swapping two <code>array</code>s requires time proportional to the number of elements in the <code>array</code>.</p>
<p>After the <code>swap</code>, pointers, references, and iterators remain bound to the same element they denoted before the <code>swap</code>. Of course, the value of that element has been swapped with the corresponding element in the other <code>array</code>.</p>
<a id="filepos2252464"></a><img alt="Image" src="/images/00008.jpg"/>
<p>In the new library, the containers offer both a member and nonmember version of <code>swap</code>. Earlier versions of the library defined only the member version of <code>swap</code>. The nonmember <code>swap</code> is of most importance in generic programs. As a matter of habit, it is best to use the nonmember version of <code>swap</code>.</p>

::: info
<a id="filepos2253151"></a><p>Exercises Section 9.2.5</p>
<p><strong>Exercise 9.14:</strong> Write a program to assign the elements from a <code>list</code> of <code>char*</code> pointers to C-style character strings to a <code>vector</code> of <code>string</code>s.</p>
:::

<h4 id="filepos2253841">9.2.6. Container Size Operations</h4>
<img alt="Image" src="/images/00009.jpg"/>
<p>With one exception, the container types have three size-related operations. The <code>size</code> member (§ <a href="031-3.2._library_string_type.html#filepos659212">3.2.2</a>, p. <a href="031-3.2._library_string_type.html#filepos659212">87</a>) returns the number of elements in the container; <code>empty</code> returns a <code>bool</code> that is <code>true</code> if <code>size</code> is zero and <code>false</code> otherwise; and <code>max_size</code> returns a number that is greater than or equal to the number of elements a container of that type can contain. For reasons we’ll explain in the next section, <code>forward_list</code> provides <code>max_size</code> and <code>empty</code>, but not <code>size</code>.</p>
<h4 id="filepos2255277">9.2.7. Relational Operators</h4>
<p>Every container type supports the equality operators (<code>==</code> and <code>!=</code>); all the containers except the unordered associative containers also support the relational operators (<code>&gt;</code>, <code>&gt;=</code>, <code>&lt;</code>, <code>&lt;=</code>). The right- and left-hand operands must be the same kind of container and must hold elements of the same type. That is, we can compare a <code>vector&lt;int&gt;</code> only with another <code>vector&lt;int&gt;</code>. We cannot compare a <code>vector&lt;int&gt;</code> with a <code>list&lt;int&gt;</code> or a <code>vector&lt;double&gt;</code>.</p>
<p>Comparing two containers performs a pairwise comparison of the elements. These operators work similarly to the <code>string</code> relationals (§ <a href="031-3.2._library_string_type.html#filepos659212">3.2.2</a>, p. <a href="031-3.2._library_string_type.html#filepos659212">88</a>):</p>
<ul><li>If both containers are the same size and all the elements are equal, then the two containers are equal; otherwise, they are unequal.</li><li>If the containers have different sizes but every element of the smaller one is equal to the corresponding element of the larger one, then the smaller one is less than the other.</li><li>If neither container is an initial subsequence of the other, then the comparison depends on comparing the first unequal elements.</li></ul>

<p>The following examples illustrate how these operators work:</p>

```c++
vector<int> v1 = { 1, 3, 5, 7, 9, 12 };
vector<int> v2 = { 1, 3, 9 };
vector<int> v3 = { 1, 3, 5, 7 };
vector<int> v4 = { 1, 3, 5, 7, 9, 12 };
v1 < v2  // true; v1 and v2 differ at element [2]: v1[2] is less than v2[2]
v1 < v3  // false; all elements are equal, but v3 has fewer of them;
v1 == v4 // true; each element is equal and v1 and v4 have the same size()
v1 == v2 // false; v2 has fewer elements than v1
```

<h5><a id="filepos2260185"></a>Relational Operators Use Their Element’s Relational Operator</h5>

::: info
<p>Note</p>
<p>We can use a relational operator to compare two containers only if the appropriate comparison operator is defined for the element type.</p>
:::

<p>The container equality operators use the element’s <code>==</code> operator, and the relational operators use the element’s <code>&lt;</code> operator. If the element type doesn’t support the required operator, then we cannot use the corresponding operations on containers holding that type. For example, the <code>Sales_data</code> type that we defined in <a href="072-chapter_7._classes.html#filepos1741323">Chapter 7</a> does not define either the <code>==</code> or the <code>&lt;</code> operation. Therefore, we cannot compare two containers that hold <code>Sales_data</code> elements:</p>

```c++
vector<Sales_data> storeA, storeB;
if (storeA < storeB) // error: Sales_data has no less-than operator
```

::: info
<p>Exercises Section 9.2.7</p>
<p><strong>Exercise 9.15:</strong> Write a program to determine whether two <code>vector&lt;int&gt;</code>s are equal.</p>
<p><strong>Exercise 9.16:</strong> Repeat the previous program, but compare elements in a <code>list&lt;int&gt;</code> to a <code>vector&lt;int&gt;</code>.</p>
<p><strong>Exercise 9.17:</strong> Assuming <code>c1</code> and <code>c2</code> are containers, what (if any) constraints does the following usage place on the types of <code>c1</code> and <code>c2?</code></p>

```c++
if (c1 < c2)
```

:::

---
title: Defined Terms
---

<h3 id="filepos611642">Defined Terms</h3><ul><li><p><strong>address</strong> Number by which a byte in memory can be found.</p></li><li><p><a href="025-2.5._dealing_with_types.html#filepos538618" id="filepos611960"><strong>alias declaration</strong></a> Defines a synonym for another type: <code>using</code>
<em>name</em> = <em>type</em> declares <em>name</em> as a synonym for the type <em>type</em>.</p></li><li><p><a href="021-2.1._primitive_builtin_types.html#filepos288306" id="filepos612338"><strong>arithmetic types</strong></a> Built-in types representing boolean values, characters, integers, and floating-point numbers.</p></li><li><p><a href="021-2.1._primitive_builtin_types.html#filepos332535" id="filepos612610"><strong>array</strong></a> Data structure that holds a collection of unnamed objects that are accessed by an index. <a href="034-3.5._arrays.html#filepos853883">Section 3.5</a> covers arrays in detail.</p></li><li><p><a href="025-2.5._dealing_with_types.html#filepos545603" id="filepos612931"><strong>auto</strong></a> Type specifier that deduces the type of a variable from its initializer.</p></li><li><p><a href="023-2.3._compound_types.html#filepos395618" id="filepos613170"><strong>base type</strong></a> type specifier, possibly qualified by <code>const</code>, that precedes the declarators in a declaration. The base type provides the common type on which the declarators in a declaration can build.</p></li><li><p><a href="023-2.3._compound_types.html#filepos398552" id="filepos613589"><strong>bind</strong></a> Associating a name with a given entity so that uses of the name are uses of the underlying entity. For example, a reference is a name that is bound to an object.</p></li><li><p><strong>byte</strong> Smallest addressable unit of memory. On most machines a byte is 8 bits.</p></li><li><p><strong>class member</strong> Part of a class.</p></li><li><p><a href="023-2.3._compound_types.html#filepos395006" id="filepos614272"><strong>compound type</strong></a> A type that is defined in terms of another type.</p></li><li><p><a href="024-2.4._const_qualifier.html#filepos463173" id="filepos614496"><strong>const</strong></a> Type qualifier used to define objects that may not be changed. <code>const</code> objects must be initialized, because there is no way to give them a value after they are defined.</p></li><li><p><strong>const pointer</strong> Pointer that is <code>const</code>.</p></li><li><p><strong>const reference</strong> Colloquial synonym for reference to <code>const</code>.</p></li><li><p><a href="024-2.4._const_qualifier.html#filepos520769" id="filepos615363"><strong>constant expression</strong></a> Expression that can be evaluated at compile time.</p></li><li><p><a href="024-2.4._const_qualifier.html#filepos524406" id="filepos615594"><strong>constexpr</strong></a> Variable that represents a constant expression. § <a href="067-6.5._features_for_specialized_uses.html#filepos1645920">6.5.2</a> (p. <a href="067-6.5._features_for_specialized_uses.html#filepos1645920">239</a>) covers <code>constexpr</code> functions.</p></li><li><p><strong>conversion</strong> Process whereby a value of one type is transformed into a value of another type. The language defines conversions among the built-in types.</p></li><li><p><a href="026-2.6._defining_our_own_data_structures.html#filepos582406" id="filepos616257"><strong>data member</strong></a> Data elements that constitute an object. Every object of a given class has its own copies of the class’ data members. Data members may be initialized when declared inside the class.</p></li><li><p><a href="022-2.2._variables.html#filepos371408" id="filepos616618"><strong>declaration</strong></a> Asserts the existence of a variable, function, or type defined elsewhere. Names may not be used until they are defined or declared.</p></li><li><p><a id="filepos616923"></a><a href="023-2.3._compound_types.html#filepos395711" id="filepos616931"><strong>declarator</strong></a> The part of a declaration that includes the name being defined and an optional type modifier.</p></li><li><p><a href="025-2.5._dealing_with_types.html#filepos563522" id="filepos617197"><strong>decltype</strong></a> Type specifier that deduces the type of a variable or an expression.</p></li><li><p><a href="022-2.2._variables.html#filepos363102" id="filepos617436"><strong>default initialization</strong></a> How objects are initialized when no explicit initializer is given. How class type objects are initialized is controlled by the class. Objects of built-in type defined at global scope are initialized to 0; those defined at local scope are uninitialized and have undefined values.</p></li><li><p><a href="022-2.2._variables.html#filepos371606" id="filepos617899"><strong>definition</strong></a> Allocates storage for a variable of a specified type and optionally initializes the variable. Names may not be used until they are defined or declared.</p></li><li><p><a href="021-2.1._primitive_builtin_types.html#filepos334876" id="filepos618223"><strong>escape sequence</strong></a> Alternative mechanism for representing characters, particularly for those without printable representations. An escape sequence is a backslash followed by a character, three or fewer octal digits, or an <code>x</code> followed by a hexadecimal number.</p></li><li><p><a href="022-2.2._variables.html#filepos386326" id="filepos618702"><strong>global scope</strong></a> The scope that is outside all other scopes.</p></li><li><p><a href="026-2.6._defining_our_own_data_structures.html#filepos605213" id="filepos618920"><strong>header guard</strong></a> Preprocessor variable used to prevent a header from being included more than once in a single file.</p></li><li><p><a href="022-2.2._variables.html#filepos377773" id="filepos619194"><strong>identifier</strong></a> Sequence of characters that make up a name. Identifiers are case-sensitive.</p></li><li><p><a href="026-2.6._defining_our_own_data_structures.html#filepos583741" id="filepos619442"><strong>in-class initializer</strong></a> Initializer provided as part of the declaration of a class data member. In-class initializers must follow an <code>=</code> symbol or be enclosed inside curly braces.</p></li><li><p><a href="022-2.2._variables.html#filepos392091" id="filepos619841"><strong>in scope</strong></a> Name that is visible from the current scope.</p></li><li><p><a href="022-2.2._variables.html#filepos356298" id="filepos620056"><strong>initialized</strong></a> A variable given an initial value when it is defined. Variables usually should be initialized.</p></li><li><p><a href="022-2.2._variables.html#filepos388224" id="filepos620324"><strong>inner scope</strong></a> Scope that is nested inside another scope.</p></li><li><p><a href="021-2.1._primitive_builtin_types.html#filepos289128" id="filepos620540"><strong>integral types</strong></a> See arithmetic type.</p></li><li><p><a href="022-2.2._variables.html#filepos360286" id="filepos620737"><strong>list initialization</strong></a> Form of initialization that uses curly braces to enclose one or more initializers.</p></li><li><p><a href="021-2.1._primitive_builtin_types.html#filepos326932" id="filepos621001"><strong>literal</strong></a> A value such as a number, a character, or a string of characters. The value cannot be changed. Literal characters are enclosed in single quotes, literal strings in double quotes.</p></li><li><p><strong>local scope</strong> Colloquial synonym for block scope.</p></li><li><p><a href="024-2.4._const_qualifier.html#filepos505221" id="filepos621521"><strong>low-level const</strong></a> A <code>const</code> that is not top-level. Such <code>const</code>s are integral to the type and are never ignored.</p></li><li><p><a href="026-2.6._defining_our_own_data_structures.html#filepos582304" id="filepos621915"><strong>member</strong></a> Part of a class.</p></li><li><p><a href="021-2.1._primitive_builtin_types.html#filepos334603" id="filepos622100"><strong>nonprintable character</strong></a> A character with no visible representation, such as a control character, a backspace, newline, and so on.</p></li><li><p><a href="023-2.3._compound_types.html#filepos424173" id="filepos622390"><strong>null pointer</strong></a> Pointer whose value is 0. A null pointer is valid but does not point to any object.</p></li><li><p><a href="023-2.3._compound_types.html#filepos425892" id="filepos622648"><strong>nullptr</strong></a> Literal constant that denotes the null pointer.</p></li><li><p><a href="022-2.2._variables.html#filepos355079" id="filepos622865"><strong>object</strong></a> A region of memory that has a type. A variable is an object that has a name.</p></li><li><p><a href="022-2.2._variables.html#filepos388326" id="filepos623110"><strong>outer scope</strong></a> Scope that encloses another scope.</p></li><li><p><a href="023-2.3._compound_types.html#filepos409586" id="filepos623318"><strong>pointer</strong></a> An object that can hold the address of an object, the address one past the end of an object, or zero.</p></li><li><p><a href="024-2.4._const_qualifier.html#filepos492522" id="filepos623589"><strong>pointer to const</strong></a> Pointer that can hold the address of a <code>const</code> object. A pointer to <code>const</code> may not be used to change the value of the object to which it points.</p></li><li><p><a href="026-2.6._defining_our_own_data_structures.html#filepos604512" id="filepos624035"><strong>preprocessor</strong></a> Program that runs as part of compilation of a C++ program.</p></li><li><p><a href="023-2.3._compound_types.html#filepos426588" id="filepos624268"><strong>preprocessor variable</strong></a> Variable managed by the preprocessor. The preprocessor replaces each preprocessor variable by its value before our program is compiled.</p></li><li><p><a href="023-2.3._compound_types.html#filepos397128" id="filepos624587"><strong>reference</strong></a> An alias for another object.</p></li><li><p><a id="filepos624787"></a><a href="024-2.4._const_qualifier.html#filepos477231" id="filepos624795"><strong>reference to</strong>
<code>const</code></a> A reference that may not change the value of the object to which it refers. A reference to <code>const</code> may be bound to a <code>const</code> object, a non<code>const</code> object, or the result of an expression.</p></li><li><p><a href="022-2.2._variables.html#filepos383477" id="filepos625473"><strong>scope</strong></a> The portion of a program in which names have meaning. C++ has several levels of scope:</p></li><li><p><strong>global</strong>—names defined outside any other scope</p></li><li><p><strong>class</strong>—names defined inside a class</p></li><li><p><strong>namespace</strong>—names defined inside a namespace</p></li><li><p><strong>block</strong>—names defined inside a block</p></li><li><p>Scopes nest. Once a name is declared, it is accessible until the end of the scope in which it was declared.</p></li><li><p><a href="022-2.2._variables.html#filepos368630" id="filepos626576"><strong>separate compilation</strong></a> Ability to split a program into multiple separate source files.</p></li><li><p><a href="021-2.1._primitive_builtin_types.html#filepos297046" id="filepos626822"><strong>signed</strong></a> Integer type that holds negative or positive values, including zero.</p></li><li><p><strong>string</strong> Library type representing variable-length sequences of characters.</p></li><li><p><a href="026-2.6._defining_our_own_data_structures.html#filepos580149" id="filepos627257"><strong>struct</strong></a> Keyword used to define a class.</p></li><li><p><a href="024-2.4._const_qualifier.html#filepos486375" id="filepos627457"><strong>temporary</strong></a> Unnamed object created by the compiler while evaluating an expression. A temporary exists until the end of the largest expression that encloses the expression for which it was created.</p></li><li><p><a href="024-2.4._const_qualifier.html#filepos504706" id="filepos627813"><strong>top-level const</strong></a> The <code>const</code> that specifies that an object may not be changed.</p></li><li><p><a href="025-2.5._dealing_with_types.html#filepos536265" id="filepos628113"><strong>type alias</strong></a> A name that is a synonym for another type. Defined through either a <code>typedef</code> or an alias declaration.</p></li><li><p><a href="022-2.2._variables.html#filepos376660" id="filepos628449"><strong>type checking</strong></a> Term used to describe the process by which the compiler verifies that the way objects of a given type are used is consistent with the definition of that type.</p></li><li><p><a href="022-2.2._variables.html#filepos350944" id="filepos628783"><strong>type specifier</strong></a> The name of a type.</p></li><li><p><a href="025-2.5._dealing_with_types.html#filepos536684" id="filepos628979"><strong>typedef</strong></a> Defines an alias for another type. When <code>typedef</code> appears in the base type of a declaration, the names defined in the declaration are type names.</p></li><li><p><a href="021-2.1._primitive_builtin_types.html#filepos310269" id="filepos629355"><strong>undefined</strong></a> Usage for which the language does not specify a meaning. Knowingly or unknowingly relying on undefined behavior is a great source of hard-to-track runtime errors, security problems, and portability problems.</p></li><li><p><a href="022-2.2._variables.html#filepos363781" id="filepos629734"><strong>uninitialized</strong></a> Variable defined without an initial value. In general, trying to access the value of an uninitialized variable results in undefined behavior.</p></li><li><p><a href="021-2.1._primitive_builtin_types.html#filepos297117" id="filepos630051"><strong>unsigned</strong></a> Integer type that holds only values greater than or equal to zero.</p></li><li><p><a href="022-2.2._variables.html#filepos350207" id="filepos630288"><strong>variable</strong></a> A named object or reference. In C++, variables must be declared before they are used.</p></li><li><p><a href="023-2.3._compound_types.html#filepos439589" id="filepos630544"><strong>void*</strong></a> Pointer type that can point to any non<code>const</code> type. Such pointers may not be dereferenced.</p></li><li><p><strong>void type</strong> Special-purpose type that has no operations and no value. It is not possible to define a variable of type <code>void</code>.</p></li><li><p><strong>word</strong> The natural unit of integer computation on a given machine. Usually a word is large enough to hold an address. On a 32-bit machine a word is typically 4 bytes.</p></li><li><p><a href="023-2.3._compound_types.html#filepos412549" id="filepos631461"><code>&amp;</code>
<strong>operator</strong></a> Address-of operator. Yields the address of the object to which it is applied.</p></li><li><p><a href="023-2.3._compound_types.html#filepos418230" id="filepos631844"><code>*</code>
<strong>operator</strong></a> Dereference operator. Dereferencing a pointer returns the object to which the pointer points. Assigning to the result of a dereference assigns a new value to the underlying object.</p></li><li><p><code>#</code>
<strong>define</strong> Preprocessor directive that defines a preprocessor variable.</p></li><li><p><code>#</code>
<strong>endif</strong> Preprocessor directive that ends an <code>#ifdef</code> or <code>#ifndef</code> region.</p></li><li><p><code>#</code>
<strong>ifdef</strong> Preprocessor directive that determines whether a given variable is defined.</p></li><li><p><code>#</code>
<strong>ifndef</strong> Preprocessor directive that determines whether a given variable is not defined.</p></li>
 
</ul>

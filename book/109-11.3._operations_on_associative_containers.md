<h3 id="filepos2776538">11.3. Operations on Associative Containers</h3>
<p>In addition to the types listed in <a href="090-9.2._container_library_overview.html#filepos2188610">Table 9.2</a> (p. <a href="090-9.2._container_library_overview.html#filepos2188610">330</a>), the associative containers define the types listed in <a href="109-11.3._operations_on_associative_containers.html#filepos2777022">Table 11.3</a>. These types represent the container’s key and value types.</p>
<p><a id="filepos2777022"></a>Table 11.3. Associative Container Additional Type Aliases</p>
<img alt="Image" src="/images/00082.jpg"/>
<p>For the <code>set</code> types, the <code>key_type</code> and the <code>value_type</code> are the same; the values held in a <code>set</code> are the keys. In a <code>map</code>, the elements are key–value pairs. That is, each element is a <code>pair</code> object containing a key and a associated value. Because we cannot change an element’s key, the key part of these <code>pair</code>s is <code>const</code>:</p>
<p><a id="filepos2778354"></a></p>

```c++
set<string>::value_type v1;      // v1 is a string
set<string>::key_type v2;        // v2 is a string
map<string, int>::value_type v3; // v3 is a pair<const string, int>
map<string, int>::key_type v4;   // v4 is a string
map<string, int>::mapped_type v5; // v5 is an int
```

<p>As with the sequential containers (§ <a href="090-9.2._container_library_overview.html#filepos2207848">9.2.2</a>, p. <a href="090-9.2._container_library_overview.html#filepos2207848">332</a>), we use the scope operator to fetch a type member—for example, <code>map&lt;string, int&gt;::key_type</code>.</p>
<p>Only the <code>map</code> types (<code>unordered_map</code>, <code>unordered_multimap</code>, <code>multimap</code>, and <code>map</code>) define <code>mapped_type</code>.</p>
<h4 id="filepos2780998">11.3.1. Associative Container Iterators</h4>
<p>When we dereference an iterator, we get a reference to a value of the container’s <code>value_type</code>. In the case of <code>map</code>, the <code>value_type</code> is a <code>pair</code> in which <code>first</code> holds the <code>const</code> key and <code>second</code> holds the value:</p>

```c++
// get an iterator to an element in word_count
auto map_it = word_count.begin();
// *map_it is a reference to a pair<const string, size_t> object
cout << map_it->first;          // prints the key for this element
cout << " " << map_it->second;  // prints the value of the element
map_it->first = "new key";      // error: key is const
++map_it->second;     // ok: we can change the value through an iterator
```

::: info
<p>It is essential to remember that the <code>value_type</code> of a <code>map</code> is a <code>pair</code> and that we can change the value but not the key member of that <code>pair</code>.</p>
:::

<h5>Iterators for <code>set</code>s Are <code>const</code></h5>
<p>Although the <code>set</code> types define both the <code>iterator</code> and <code>const_iterator</code> types, both types of iterators give us read-only access to the elements in the <code>set</code>. Just as we cannot change the key part of a <code>map</code> element, the keys in a <code>set</code> are also <code>const</code>. We can use a <code>set</code> iterator to read, but not write, an element’s value:</p>

```c++
set<int> iset = {0,1,2,3,4,5,6,7,8,9};
set<int>::iterator set_it = iset.begin();
if (set_it != iset.end()) {
    *set_it = 42;            // error: keys in a set are read-only
    cout << *set_it << endl; // ok: can read the key
}
```

<h5><a id="filepos2786303"></a>Iterating across an Associative Container</h5>
<p>The <code>map</code> and <code>set</code> types provide all the <code>begin</code> and <code>end</code> operations from <a href="090-9.2._container_library_overview.html#filepos2188610">Table 9.2</a> (p. <a href="090-9.2._container_library_overview.html#filepos2188610">330</a>). As usual, we can use these functions to obtain iterators that we can use to traverse the container. For example, we can rewrite the loop that printed the results in our word-counting program on page <a href="107-11.1._using_an_associative_container.html#filepos2725651">421</a> as follows:</p>

```c++
// get an iterator positioned on the first element
auto map_it = word_count.cbegin();
// compare the current iterator to the off-the-end iterator
while (map_it != word_count.cend()) {
    // dereference the iterator to print the element key--value pairs
    cout << map_it->first << " occurs "
         << map_it->second << " times" << endl;
    ++map_it;  // increment the iterator to denote the next element
}
```

<p>The <code>while</code> condition and increment for the iterator in this loop look a lot like the programs we wrote that printed the contents of a <code>vector</code> or a <code>string</code>. We initialize an iterator, <code>map_it</code>, to refer to the first element in <code>word_count</code>. As long as the iterator is not equal to the <code>end</code> value, we print the current element and then increment the iterator. The output statement dereferences <code>map_it</code> to get the members of <code>pair</code> but is otherwise the same as the one in our original program.</p>

::: info
<p>The output of this program is in alphabetical order. When we use an iterator to traverse a <code>map, multimap, set</code>, or <code>multiset</code>, the iterators yield elements in ascending key order.</p>
:::

<h5>Associative Containers and Algorithms</h5>
<p>In general, we do not use the generic algorithms (<a href="097-chapter_10._generic_algorithms.html#filepos2454824">Chapter 10</a>) with the associative containers. The fact that the keys are <code>const</code> means that we cannot pass associative container iterators to algorithms that write to or reorder container elements. Such algorithms need to write to the elements. The elements in the <code>set</code> types are <code>const</code>, and those in <code>map</code>s are <code>pair</code>s whose first element is <code>const</code>.</p>
<p>Associative containers can be used with the algorithms that read elements. However, many of these algorithms search the sequence. Because elements in an associative container can be found (quickly) by their key, it is almost always a bad idea to use a generic search algorithm. For example, as we’ll see in § <a href="109-11.3._operations_on_associative_containers.html#filepos2829910">11.3.5</a> (p. <a href="109-11.3._operations_on_associative_containers.html#filepos2829910">436</a>), the associative containers define a member named <code>find</code>, which directly fetches the element with a given key. We could use the generic <code>find</code> algorithm to look for an element, but that algorithm does a sequential search. It is much faster to use the <code>find</code> member defined by the container than to call the generic version.</p>
<p>In practice, if we do so at all, we use an associative container with the algorithms either as the source sequence or as a destination. For example, we might use the generic <code>copy</code> algorithm to copy the elements from an associative container into another sequence. Similarly, we can call <code>inserter</code> to bind an insert iterator (§ <a href="101-10.4._revisiting_iterators.html#filepos2619592">10.4.1</a>, p. <a href="101-10.4._revisiting_iterators.html#filepos2619592">401</a>) to an associative container. Using <code>inserter</code>, we can use the associative container as a destination for another algorithm.</p>

::: info
<a id="filepos2792631"></a><p>Exercises Section 11.3.1</p>
<p><strong>Exercise 11.15:</strong> What are the <code>mapped_type</code>, <code>key_type</code>, and <code>value_type</code> of a <code>map</code> from <code>int</code> to <code>vector&lt;int&gt;?</code></p>
<p><strong>Exercise 11.16:</strong> Using a <code>map</code> iterator write an expression that assigns a value to an element.</p>
<p><strong>Exercise 11.17:</strong> Assuming <code>c</code> is a <code>multiset</code> of <code>string</code>s and <code>v</code> is a <code>vector</code> of <code>string</code>s, explain the following calls. Indicate whether each call is legal:</p>

```c++
copy(v.begin(), v.end(), inserter(c, c.end()));
copy(v.begin(), v.end(), back_inserter(c));
copy(c.begin(), c.end(), inserter(v, v.end()));
copy(c.begin(), c.end(), back_inserter(v));
```

<p><strong>Exercise 11.18:</strong> Write the type of <code>map_it</code> from the loop on page <a href="109-11.3._operations_on_associative_containers.html#filepos2786303">430</a> without using <code>auto</code> or <code>decltype</code>.</p>
<p><strong>Exercise 11.19:</strong> Define a variable that you initialize by calling <code>begin()</code> on the <code>multiset</code> named <code>bookstore</code> from § <a href="108-11.2._overview_of_the_associative_containers.html#filepos2751456">11.2.2</a> (p. <a href="108-11.2._overview_of_the_associative_containers.html#filepos2751456">425</a>). Write the variable’s type without using <code>auto</code> or <code>decltype</code>.</p>
:::

<h4 id="filepos2795913">11.3.2. Adding Elements</h4>
<p>The <code>insert</code> members (<a href="109-11.3._operations_on_associative_containers.html#filepos2797757">Table 11.4</a> (overleaf)) add one element or a range of elements. Because <code>map</code> and <code>set</code> (and the corresponding unordered types) contain unique keys, inserting an element that is already present has no effect:</p>

```c++
vector<int> ivec = {2,4,6,8,2,4,6,8};    // ivec has eight elements
set<int> set2;                           // empty set
set2.insert(ivec.cbegin(), ivec.cend()); // set2 has four elements
set2.insert({1,3,5,7,1,3,5,7});      // set2 now has eight elements
```

<p><a id="filepos2797757"></a>Table 11.4. Associative Container <code>insert</code> Operations</p>
<img alt="Image" src="/images/00083.jpg"/>
<p>The versions of <code>insert</code> that take a pair of iterators or an initializer list work similarly to the corresponding constructors (§ <a href="108-11.2._overview_of_the_associative_containers.html#filepos2741390">11.2.1</a>, p. <a href="108-11.2._overview_of_the_associative_containers.html#filepos2741390">423</a>)—only the first element with a given key is inserted.</p>
<h5>Adding Elements to a <code>map</code></h5>
<p>When we <code>insert</code> into a <code>map</code>, we must remember that the element type is a <code>pair</code>. Often, we don’t have a <code>pair</code> object that we want to insert. Instead, we create a <code>pair</code> in the argument list to <code>insert</code>:</p>

```c++
// four ways to add word to word_count
word_count.insert({word, 1});
word_count.insert(make_pair(word, 1));
word_count.insert(pair<string, size_t>(word, 1));
word_count.insert(map<string, size_t>::value_type(word, 1));
```

<a id="filepos2800124"></a><Badge type="tip" text="C++11" />
<p>As we’ve seen, under the new standard the easiest way to create a <code>pair</code> is to use brace initialization inside the argument list. Alternatively, we can call <code>make_pair</code>
<a id="filepos2800508"></a>or explicitly construct the <code>pair</code>. The argument in the last call to <code>insert</code>:</p>

```c++
map<string, size_t>::value_type(s, 1)
```

<p>constructs a new object of the appropriate <code>pair</code> type to insert into the <code>map</code>.</p>
<h5>Testing the Return from <code>insert</code></h5>
<p>The value returned by <code>insert</code> (or <code>emplace</code>) depends on the container type and the parameters. For the containers that have unique keys, the versions of <code>insert</code> and <code>emplace</code> that add a single element return a <code>pair</code> that lets us know whether the insertion happened. The <code>first</code> member of the <code>pair</code> is an iterator to the element with the given key; the <code>second</code> is a <code>bool</code> indicating whether that element was inserted, or was already there. If the key is already in the container, then <code>insert</code> does nothing, and the <code>bool</code> portion of the return value is <code>false</code>. If the key isn’t present, then the element is inserted and the <code>bool</code> is <code>true</code>.</p>
<p>As an example, we’ll rewrite our word-counting program to use <code>insert</code>:</p>

```c++
// more verbose way to count number of times each word occurs in the input
map<string, size_t> word_count; // empty map from string to size_t
string word;
while (cin >> word) {
    // inserts an element with key equal to word and value 1;
    // if word is already in word_count, insert does nothing
    auto ret = word_count.insert({word, 1});
    if (!ret.second)         // word was already in word_count
        ++ret.first->second; // increment the counter
}
```

<p>For each <code>word</code>, we attempt to <code>insert</code> it with a value <code>1</code>. If <code>word</code> is already in the <code>map</code>, then nothing happens. In particular, the counter associated with <code>word</code> is <a id="filepos2806248"></a>unchanged. If <code>word</code> is not already in the <code>map</code>, then that <code>string</code> is added to the <code>map</code> and its counter value is set to 1.</p>
<p>The <code>if</code> test examines the <code>bool</code> part of the return value. If that value is <code>false</code>, then the insertion didn’t happen. In this case, <code>word</code> was already in <code>word_count</code>, so we must increment the value associated with that element.</p>
<h5>Unwinding the Syntax</h5>
<p>The statement that increments the counter in this version of the word-counting program can be hard to understand. It will be easier to understand that expression by first parenthesizing it to reflect the precedence (§ <a href="039-4.1._fundamentals.html#filepos1010254">4.1.2</a>, p. <a href="039-4.1._fundamentals.html#filepos1010254">136</a>) of the operators:</p>

```c++
++((ret.first)->second); // equivalent expression
```

<p>Explaining this expression step by step:</p>

::: info
<p><code>ret</code> holds the value returned by <code>insert</code>, which is a <code>pair</code>.</p>
:::

::: info
<p><code>ret.first</code> is the <code>first</code> member of that <code>pair</code>, which is a <code>map</code> iterator referring to the element with the given key.</p>
:::

::: info
<p><code>ret.first-&gt;</code> dereferences that iterator to fetch that element. Elements in the <code>map</code> are also <code>pair</code>s.</p>
:::

::: info
<p><code>ret.first-&gt;second</code> is the value part of the map element <code>pair</code>.</p>
:::

::: info
<p><code>++ret.first-&gt;second</code> increments that value.</p>
:::

<p>Putting it back together, the increment statement fetches the iterator for the element with the key <code>word</code> and increments the counter associated with the key we tried to insert.</p>
<p>For readers using an older compiler or reading code that predates the new standard, declaring and initializing <code>ret</code> is also somewhat tricky:</p>

```c++
pair<map<string, size_t>::iterator, bool> ret =
            word_count.insert(make_pair(word, 1));
```

<p>It should be easy to see that we’re defining a <code>pair</code> and that the second type of the <code>pair</code> is <code>bool</code>. The first type of that <code>pair</code> is a bit harder to understand. It is the <code>iterator</code> type defined by the <code>map&lt;string, size_t&gt;</code> type.</p>
<h5>Adding Elements to <code>multiset</code> or <code>multimap</code></h5>
<p>Our word-counting program depends on the fact that a given key can occur only once. That way, there is only one counter associated with any given word. Sometimes, we want to be able to add additional elements with the same key. For example, we might want to map authors to titles of the books they have written. In this case, there might be multiple entries for each author, so we’d use a <code>multimap</code> rather than a <code>map</code>. Because keys in a <code>multi</code> container need not be unique, <code>insert</code> on these types always inserts an element:</p>
<p><a id="filepos2813196"></a></p>

```c++
multimap<string, string> authors;
// adds the first element with the key Barth, John
authors.insert({"Barth, John", "Sot-Weed Factor"});
// ok: adds the second element with the key Barth, John
authors.insert({"Barth, John", "Lost in the Funhouse"});
```

<p>For the containers that allow multiple keys, the <code>insert</code> operation that takes a single element returns an iterator to the new element. There is no need to return a <code>bool</code>, because <code>insert</code> always adds a new element in these types.</p>

::: info
<p>Exercises Section 11.3.2</p>
<p><strong>Exercise 11.20:</strong> Rewrite the word-counting program from § <a href="107-11.1._using_an_associative_container.html#filepos2724280">11.1</a> (p. <a href="107-11.1._using_an_associative_container.html#filepos2724280">421</a>) to use <code>insert</code> instead of subscripting. Which program do you think is easier to write and read? Explain your reasoning.</p>
<p><strong>Exercise 11.21:</strong> Assuming <code>word_count</code> is a <code>map</code> from <code>string</code> to <code>size_t</code> and <code>word</code> is a <code>string</code>, explain the following loop:</p>

```c++
while (cin >> word)
  ++word_count.insert({word, 0}).first->second;
```

<p><strong>Exercise 11.22:</strong> Given a <code>map&lt;string, vector&lt;int&gt;&gt;</code>, write the types used as an argument and as the return value for the version of <code>insert</code> that inserts one element.</p>
<p><strong>Exercise 11.23:</strong> Rewrite the <code>map</code> that stored <code>vector</code>s of children’s names with a key that is the family last name for the exercises in § <a href="108-11.2._overview_of_the_associative_containers.html#filepos2741390">11.2.1</a> (p. <a href="108-11.2._overview_of_the_associative_containers.html#filepos2741390">424</a>) to use a <code>multimap</code>.</p>
:::

<h4 id="filepos2817032">11.3.3. Erasing Elements</h4>
<p>The associative containers define three versions of <code>erase</code>, which are described in <a href="109-11.3._operations_on_associative_containers.html#filepos2817959">Table 11.5</a>. As with the sequential containers, we can <code>erase</code> one element or a range of elements by passing <code>erase</code> an iterator or an iterator pair. These versions of <code>erase</code> are similar to the corresponding operations on sequential containers: The indicated element(s) are removed and the function returns <code>void</code>.</p>
<p><a id="filepos2817959"></a>Table 11.5. Removing Elements from an Associative Container</p>
<img alt="Image" src="/images/00084.jpg"/>
<p>The associative containers supply an additional <code>erase</code> operation that takes a <code>key_type</code> argument. This version removes all the elements, if any, with the given key and returns a count of how many elements were removed. We can use this version to remove a specific word from <code>word_count</code> before printing the results:</p>

```c++
// erase on a key returns the number of elements removed
if (word_count.erase(removal_word))
     cout << "ok: " << removal_word << " removed\n";
else cout << "oops: " << removal_word << " not found!\n";
```

<p>For the containers with unique keys, the return from <code>erase</code> is always either zero or one. If the return value is zero, then the element we wanted to erase was not in the container.</p>
<p><a id="filepos2819746"></a>For types that allow multiple keys, the number of elements removed could be greater than one:</p>

```c++
auto cnt = authors.erase("Barth, John");
```

<p>If <code>authors</code> is the <code>multimap</code> we created in § <a href="109-11.3._operations_on_associative_containers.html#filepos2795913">11.3.2</a> (p. <a href="109-11.3._operations_on_associative_containers.html#filepos2795913">434</a>), then <code>cnt</code> will be 2.</p>
<h4 id="filepos2820595">11.3.4. Subscripting a <code>map</code></h4>
<Badge type="warning" text="Tricky" />
<p>The <code>map</code> and <code>unordered_map</code> containers provide the subscript operator and a corresponding <code>at</code> function (§ <a href="091-9.3._sequential_container_operations.html#filepos2294924">9.3.2</a>, p. <a href="091-9.3._sequential_container_operations.html#filepos2294924">348</a>), which are described in <a href="109-11.3._operations_on_associative_containers.html#filepos2822041">Table 11.6</a> (overleaf). The <code>set</code> types do not support subscripting because there is no “value” associated with a key in a <code>set</code>. The elements are themselves keys, so the operation of “fetching the value associated with a key” is meaningless. We cannot subscript a <code>multimap</code> or an <code>unordered_multimap</code> because there may be more than one value associated with a given key.</p>
<p><a id="filepos2822041"></a>Table 11.6. Subscript Operation for <code>map</code> and <code>unordered_map</code></p>
<img alt="Image" src="/images/00085.jpg"/>
<p>Like the other subscript operators we’ve used, the <code>map</code> subscript takes an index (that is, a key) and fetches the value associated with that key. However, unlike other subscript operators, if the key is not already present, <em>a new element is created and inserted</em> into the <code>map</code> for that key. The associated value is value initialized (§ <a href="032-3.3._library_vector_type.html#filepos744172">3.3.1</a>, p. <a href="032-3.3._library_vector_type.html#filepos744172">98</a>).</p>
<p>For example, when we write</p>

```c++
map <string, size_t> word_count; // empty map
// insert a value-initialized element with key Anna; then assign 1 to its value
word_count["Anna"] = 1;
```

<p>the following steps take place:</p>
<ul><li><code>word_count</code> is searched for the element whose key is <code>Anna</code>. The element is not found.</li><li>A new key-value pair is inserted into <code>word_count</code>. The key is a <code>const string</code> holding <code>Anna</code>. The value is value initialized, meaning in this case that the value is 0.</li><li>The newly inserted element is fetched and is given the value 1.</li></ul>

<p>Because the subscript operator might insert an element, we may use subscript only on a <code>map</code> that is not <code>const</code>.</p>

::: info
<p>Subscripting a <code>map</code> behaves quite differently from subscripting an array or <code>vector:</code> Using a key that is not already present <em>adds</em> an element with that key to the <code>map</code>.</p>
:::

<h5>Using the Value Returned from a Subscript Operation</h5>
<p>Another way in which the <code>map</code> subscript differs from other subscript operators we’ve used is its return type. Ordinarily, the type returned by dereferencing an iterator and the type returned by the subscript operator are the same. Not so for <code>map</code>s: when we subscript a <code>map</code>, we get a <code>mapped_type</code> object; when we dereference a <code>map</code> iterator, we get a <code>value_type</code> object (§ <a href="109-11.3._operations_on_associative_containers.html#filepos2776538">11.3</a>, p. <a href="109-11.3._operations_on_associative_containers.html#filepos2776538">428</a>).</p>
<p>In common with other subscripts, the <code>map</code> subscript operator returns an lvalue (§ <a href="039-4.1._fundamentals.html#filepos999677">4.1.1</a>, p. <a href="039-4.1._fundamentals.html#filepos999677">135</a>). Because the return is an lvalue, we can read or write the element:</p>

```c++
cout << word_count["Anna"]; // fetch the element indexed by Anna; prints 1
++word_count["Anna"];       // fetch the element and add 1 to it
cout << word_count["Anna"]; // fetch the element and print it; prints 2
```

::: info
<p>Unlike <code>vector</code> or <code>string</code>, the type returned by the <code>map</code> subscript operator differs from the type obtained by dereferencing a <code>map</code> iterator.</p>
:::

<p>The fact that the subscript operator adds an element if it is not already in the <code>map</code> allows us to write surprisingly succinct programs such as the loop inside our word-counting program (§ <a href="107-11.1._using_an_associative_container.html#filepos2724280">11.1</a>, p. <a href="107-11.1._using_an_associative_container.html#filepos2724280">421</a>). On the other hand, sometimes we only want to know whether an element is present and <em>do not</em> want to add the element if it is not. In such cases, we must not use the subscript operator.</p>
<h4 id="filepos2829910">11.3.5. Accessing Elements</h4>
<p>The associative containers provide various ways to find a given element, which are described in <a href="109-11.3._operations_on_associative_containers.html#filepos2831111">Table 11.7</a> (p. <a href="109-11.3._operations_on_associative_containers.html#filepos2831111">438</a>). Which operation to use depends on what problem we are trying to solve. If all we care about is whether a particular element is in the container, it is probably best to use <code>find</code>. For the containers that can hold only unique keys, it probably doesn’t matter whether we use <code>find</code> or <code>count</code>. However, for the containers with multiple keys, <code>count</code> has to do more work: If the element is present, it still has to count how many elements have the same key. If we don’t need the count, it’s best to use <code>find</code>:</p>
<p><a id="filepos2831111"></a>Table 11.7. Operations to Find Elements in an Associative Container</p>
<img alt="Image" src="/images/00086.jpg"/>

::: info
<a id="filepos2831331"></a><p>Exercises Section 11.3.4</p>
<p><strong>Exercise 11.24:</strong> What does the following program do?</p>

```c++
map<int, int> m;
m[0] = 1;
```

<p><strong>Exercise 11.25:</strong> Contrast the following program with the one in the previous exercise</p>

```c++
vector<int> v;
v[0] = 1;
```

<p><strong>Exercise 11.26:</strong> What type can be used to subscript a <code>map</code>? What type does the subscript operator return? Give a concrete example—that is, define a <code>map</code> and then write the types that can be used to subscript the <code>map</code> and the type that would be returned from the subscript operator.</p>
:::

```c++
set<int> iset = {0,1,2,3,4,5,6,7,8,9};
iset.find(1);   // returns an iterator that refers to the element with key == 1
iset.find(11);  // returns the iterator == iset.end()
iset.count(1);  // returns 1
iset.count(11); // returns 0
```

<h5>Using <code>find</code> Instead of Subscript for <code>map</code>s</h5>
<p>For the <code>map</code> and <code>unordered_map</code> types, the subscript operator provides the simplest method of retrieving a value. However, as we’ve just seen, using a subscript has an important side effect: If that key is not already in the <code>map</code>, then subscript inserts an element with that key. Whether this behavior is correct depends on our expectations. Our word-counting programs relied on the fact that using a nonexistent key as a subscript inserts an element with that key and value 0.</p>
<p>Sometimes, we want to know if an element with a given key is present without changing the <code>map</code>. We cannot use the subscript operator to determine whether an element is present, because the subscript operator inserts a new element if the key is not already there. In such cases, we should use <code>find</code>:</p>

```c++
if (word_count.find("foobar") == word_count.end())
    cout << "foobar is not in the map" << endl;
```

<h5>Finding Elements in a <code>multimap</code> or <code>multiset</code></h5>
<p>Finding an element in an associative container that requires unique keys is a simple matter—the element is or is not in the container. For the containers that allow multiple keys, the process is more complicated: There may be many elements with the given key. When a <code>multimap</code> or <code>multiset</code> has multiple elements of a given key, those elements will be adjacent within the container.</p>
<p><a id="filepos2836897"></a>For example, given our map from author to titles, we might want to print all the books by a particular author. We can solve this problem in three different ways. The most obvious way uses <code>find</code> and <code>count</code>:</p>

```c++
string search_item("Alain de Botton"); // author we'll look for
auto entries = authors.count(search_item); // number of elements
auto iter = authors.find(search_item); // first entry for this author
// loop through the number of entries there are for this author
while(entries) {
    cout << iter->second << endl; // print each title
    ++iter;     // advance to the next title
    --entries;  // keep track of how many we've printed
}
```

<p>We start by determining how many entries there are for the author by calling <code>count</code> and getting an iterator to the first element with this key by calling <code>find</code>. The number of iterations of the <code>for</code> loop depends on the number returned from <code>count</code>. In particular, if the <code>count</code> was zero, then the loop is never executed.</p>

::: info
<p>We are guaranteed that iterating across a <code>multimap</code> or <code>multiset</code> returns all the elements with a given key in sequence.</p>
:::

<h5>A Different, Iterator-Oriented Solution</h5>
<p>Alternatively, we can solve our problem using <code>lower_bound</code> and <code>upper_bound</code>. Each of these operations take a key and returns an iterator. If the key is in the container, the iterator returned from <code>lower_bound</code> will refer to the first instance of that key and the iterator returned by <code>upper_bound</code> will refer just after the last instance of the key. If the element is not in the <code>multimap</code>, then <code>lower_bound</code> and <code>upper_bound</code> will return equal iterators; both will refer to the point at which the key can be inserted without disrupting the order. Thus, calling <code>lower_bound</code> and <code>upper_bound</code> on the same key yields an iterator range (§ <a href="090-9.2._container_library_overview.html#filepos2196283">9.2.1</a>, p. <a href="090-9.2._container_library_overview.html#filepos2196283">331</a>) that denotes all the elements with that key.</p>
<p><a id="filepos2841351"></a>Of course, the iterator returned from these operations might be the off-the-end iterator for the container itself. If the element we’re looking for has the largest key in the container, then <code>upper_bound</code> on that key returns the off-the-end iterator. If the key is not present and is larger than any key in the container, then the return from <code>lower_bound</code> will also be the off-the-end iterator.</p>

::: info
<p>The iterator returned from <code>lower_bound</code> may or may not refer to an element with the given key. If the key is not in the container, then <code>lower_bound</code> refers to the first point at which this key can be inserted while preserving the element order within the container.</p>
:::

<p>Using these operations, we can rewrite our program as follows:</p>

```c++
// definitions of authors and search_item as above
// beg and end denote the range of elements for this author
for (auto beg = authors.lower_bound(search_item),
          end = authors.upper_bound(search_item);
     beg != end; ++beg)
    cout << beg->second << endl; // print each title
```

<p>This program does the same work as the previous one that used <code>count</code> and <code>find</code> but accomplishes its task more directly. The call to <code>lower_bound</code> positions <code>beg</code> so that it refers to the first element matching <code>search_item</code> if there is one. If there is no such element, then <code>beg</code> refers to the first element with a key larger than <code>search_item</code>, which could be the off-the-end iterator. The call to <code>upper_bound</code> sets <code>end</code> to refer to the element just beyond the last element with the given key. These operations say nothing about whether the key is present. The important point is that the return values act like an iterator range (§ <a href="090-9.2._container_library_overview.html#filepos2196283">9.2.1</a>, p. <a href="090-9.2._container_library_overview.html#filepos2196283">331</a>).</p>
<p>If there is no element for this key, then <code>lower_bound</code> and <code>upper_bound</code> will be equal. Both will refer to the point at which this key can be inserted while maintaining the container order.</p>
<p>Assuming there are elements with this key, <code>beg</code> will refer to the first such element. We can increment <code>beg</code> to traverse the elements with this key. The iterator in <code>end</code> will signal when we’ve seen all the elements. When <code>beg</code> equals <code>end</code>, we have seen every element with this key.</p>
<p>Because these iterators form a range, we can use a <code>for</code> loop to traverse that range. The loop is executed zero or more times and prints the entries, if any, for the given author. If there are no elements, then <code>beg</code> and <code>end</code> are equal and the loop is never executed. Otherwise, we know that the increment to <code>beg</code> will eventually reach <code>end</code> and that in the process we will print each record associated with this author.</p>

::: info
<p>If <code>lower_bound</code> and <code>upper_bound</code> return the same iterator, then the given key is not in the container.</p>
:::

<h5>The <code>equal_range</code> Function</h5>
<p>The remaining way to solve this problem is the most direct of the three approaches: Instead of calling <code>upper_bound</code> and <code>lower_bound</code>, we can call <code>equal_range</code>.</p>
<p><a id="filepos2848488"></a>This function takes a key and returns a <code>pair</code> of iterators. If the key is present, then the first iterator refers to the first instance of the key and the second iterator refers one past the last instance of the key. If no matching element is found, then both the first and second iterators refer to the position where this key can be inserted.</p>
<p>We can use <code>equal_range</code> to modify our program once again:</p>

```c++
// definitions of authors and search_item as above
// pos holds iterators that denote the range of elements for this key
for (auto pos = authors.equal_range(search_item);
     pos.first != pos.second; ++pos.first)
    cout << pos.first->second << endl; // print each title
```

<p>This program is essentially identical to the previous one that used <code>upper_bound</code> and <code>lower_bound</code>. Instead of using local variables, <code>beg</code> and <code>end</code>, to hold the iterator range, we use the <code>pair</code> returned by <code>equal_range</code>. The <code>first</code> member of that <code>pair</code> holds the same iterator as <code>lower_bound</code> would have returned and <code>second</code> holds the iterator <code>upper_bound</code> would have returned. Thus, in this program <code>pos.first</code> is equivalent to <code>beg</code>, and <code>pos.second</code> is equivalent to <code>end</code>.</p>

::: info
<p>Exercises Section 11.3.5</p>
<p><strong>Exercise 11.27:</strong> What kinds of problems would you use <code>count</code> to solve? When might you use <code>find</code> instead?</p>
<p><strong>Exercise 11.28:</strong> Define and initialize a variable to hold the result of calling <code>find</code> on a <code>map</code> from <code>string</code> to <code>vector</code> of <code>int</code>.</p>
<p><strong>Exercise 11.29:</strong> What do <code>upper_bound</code>, <code>lower_bound</code>, and <code>equal_range</code> return when you pass them a key that is not in the container?</p>
<p><strong>Exercise 11.30:</strong> Explain the meaning of the operand <code>pos.first-&gt;second</code> used in the output expression of the final program in this section.</p>
<p><strong>Exercise 11.31:</strong> Write a program that defines a <code>multimap</code> of authors and their works. Use <code>find</code> to find an element in the <code>multimap</code> and <code>erase</code> that element. Be sure your program works correctly if the element you look for is not in the <code>map</code>.</p>
<p><strong>Exercise 11.32:</strong> Using the <code>multimap</code> from the previous exercise, write a program to print the list of authors and their works alphabetically.</p>
:::

<h4 id="filepos2854545">11.3.6. A Word Transformation Map</h4>
<p>We’ll close this section with a program to illustrate creating, searching, and iterating across a <code>map</code>. We’ll write a program that, given one <code>string</code>, transforms it into another. The input to our program is two files. The first file contains rules that we will use to transform the text in the second file. Each rule consists of a word that might be in the input file and a phrase to use in its place. The idea is that whenever the first word appears in the input, we will replace it with the corresponding phrase. The second file contains the text to transform.</p>
<p><a id="filepos2855442"></a>If the contents of the word-transformation file are</p>

```
brb be right back
k okay?
y why
r are
u you
pic picture
thk thanks!
l8r later
```

<p>and the text we are given to transform is</p>

```
where r u
y dont u send me a pic
k thk l8r
```

<p>then the program should generate the following output:</p>

```
where are you
why dont you send me a picture
okay? thanks! later
```

<h5>The Word Transformation Program</h5>
<p>Our solution will use three functions. The <code>word_transform</code> function will manage the overall processing. It will take two <code>ifstream</code> arguments: The first will be bound to the word-transformation file and the second to the file of text we’re to transform. The <code>buildMap</code> function will read the file of transformation rules and create a <code>map</code> from each word to its transformation. The <code>transform</code> function will take a <code>string</code> and return the transformation if there is one.</p>
<p>We’ll start by defining the <code>word_transform</code> function. The important parts are the calls to <code>buildMap</code> and <code>transform</code>:</p>

```c++
void word_transform(ifstream &map_file, ifstream &input)
{
    auto trans_map = buildMap(map_file); // store the transformations
    string text;                    // hold each line from the input
    while (getline(input, text)) {  // read a line of input
        istringstream stream(text); // read each word
        string word;
        bool firstword = true;      // controls whether a space is printed
        while (stream >> word) {
           if (firstword)
               firstword = false;
           else
               cout << " ";  // print a space between words
           // transform returns its first argument or its transformation
           cout << transform(word, trans_map); // print the output
        }
        cout << endl;         // done with this line of input
    }
}
```

<p><a id="filepos2861431"></a>The function starts by calling <code>buildMap</code> to generate the word-transformation <code>map</code>. We store the result in <code>trans_map</code>. The rest of the function processes the <code>input</code> file. The <code>while</code> loop uses <code>getline</code> to read the input file a line at a time. We read by line so that our output will have line breaks at the same position as in the input file. To get the words from each line, we use a nested <code>while</code> loop that uses an <code>istringstream</code> (§ <a href="085-8.3._string_streams.html#filepos2143868">8.3</a>, p. <a href="085-8.3._string_streams.html#filepos2143868">321</a>) to process each word in the current line.</p>
<p>The inner <code>while</code> prints the output using the <code>bool firstword</code> to determine whether to print a space. The call to <code>transform</code> obtains the word to print. The value returned from <code>transform</code> is either the original <code>string</code> in <code>word</code> or its corresponding transformation from <code>trans_map</code>.</p>
<h5>Building the Transformation Map</h5>
<p>The <code>buildMap</code> function reads its given file and builds the transformation <code>map</code>.</p>

```c++
map<string, string> buildMap(ifstream &map_file)
{
    map<string, string> trans_map;  // holds the transformations
    string key;    // a word to transform
    string value;  // phrase to use instead
    // read the first word into key and the rest of the line into value
    while (map_file >> key && getline(map_file, value))
        if (value.size() > 1) // check that there is a transformation
            trans_map[key] = value.substr(1); // skip leading space
        else
            throw runtime_error("no rule for " + key);
    return trans_map;
}
```

<p>Each line in <code>map_file</code> corresponds to a rule. Each rule is a word followed by a phrase, which might contain multiple words. We use <code>&gt;&gt;</code> to read the word that we will transform into <code>key</code> and call <code>getline</code> to read the rest of the line into <code>value</code>. Because <code>getline</code> does not skip leading spaces (§ <a href="031-3.2._library_string_type.html#filepos659212">3.2.2</a>, p. <a href="031-3.2._library_string_type.html#filepos659212">87</a>), we need to skip the space between the word and its corresponding rule. Before we store the transformation, we check that we got more than one character. If so, we call <code>substr</code> (§ <a href="093-9.5._additional_string_operations.html#filepos2374493">9.5.1</a>, p. <a href="093-9.5._additional_string_operations.html#filepos2374493">361</a>) to skip the space that separated the transformation phrase from its corresponding word and store that substring in <code>trans_map</code>,</p>
<p>Note that we use the subscript operator to add the key–value pairs. Implicitly, we are ignoring what should happen if a word appears more than once in our transformation file. If a word does appear multiple times, our loops will put the last corresponding phrase into <code>trans_map</code>. When the <code>while</code> concludes, <code>trans_map</code> contains the data that we need to transform the input.</p>
<h5>Generating a Transformation</h5>
<p>The <code>transform</code> function does the actual transformation. Its parameters are references to the <code>string</code> to transform and to the transformation <code>map</code>. If the given <code>string</code> is in the <code>map</code>, <code>transform</code> returns the corresponding transformation. If the given <code>string</code> is not in the <code>map</code>, <code>transform</code> returns its argument:</p>
<p><a id="filepos2868525"></a></p>

```c++
const string &
transform(const string &s, const map<string, string> &m)
{
    // the actual map work; this part is the heart of the program
    auto map_it = m.find(s);
    // if this word is in the transformation map
    if (map_it != m.cend())
        return map_it->second; // use the replacement word
    else
        return s;              // otherwise return the original unchanged
}
```

<p>We start by calling <code>find</code> to determine whether the given <code>string</code> is in the <code>map</code>. If it is, then <code>find</code> returns an iterator to the corresponding element. Otherwise, <code>find</code> returns the off-the-end iterator. If the element is found, we dereference the iterator, obtaining a <code>pair</code> that holds the key and value for that element (§ <a href="109-11.3._operations_on_associative_containers.html#filepos2776538">11.3</a>, p. <a href="109-11.3._operations_on_associative_containers.html#filepos2776538">428</a>). We return the <code>second</code> member, which is the transformation to use in place of <code>s</code>.</p>

::: info
<p>Exercises Section 11.3.6</p>
<p><strong>Exercise 11.33:</strong> Implement your own version of the word-transformation program.</p>
<p><strong>Exercise 11.34:</strong> What would happen if we used the subscript operator instead of <code>find</code> in the <code>transform</code> function?</p>
<p><strong>Exercise 11.35:</strong> In <code>buildMap</code>, what effect, if any, would there be from rewriting</p>

```c++
    trans_map[key] = value.substr(1);

```

as

```c++
    trans_map.insert({key, value.substr(1)});
```

<p><strong>Exercise 11.36:</strong> Our program does no checking on the validity of either input file. In particular, it assumes that the rules in the transformation file are all sensible. What would happen if a line in that file has a key, one space, and then the end of the line? Predict the behavior and then check it against your version of the program.</p>
:::

<h3 id="filepos4051570">15.9. Text Queries Revisited</h3>
<p>As a final example of inheritance, we’ll extend our text-query application from §<a href="116-12.3._using_the_library_a_textquery_program.html#filepos3140586">12.3</a> (p. <a href="116-12.3._using_the_library_a_textquery_program.html#filepos3140586">484</a>). The classes we wrote in that section let us look for occurrences of a <a id="filepos4051934"></a>given word in a file. We’d like to extend the system to support more complicated queries. In our examples, we’ll run queries against the following simple story:</p>

```c++
Alice Emma has long flowing red hair.
Her Daddy says when the wind blows
through her hair, it looks almost alive,
like a fiery bird in flight.
A beautiful fiery bird, he tells her,
magical but untamed.
"Daddy, shush, there is no such thing,"
she tells him, at the same time wanting
him to tell her more.
Shyly, she asks, "I mean, Daddy, is there?"
```

<p>Our system should support the following queries:</p>
<ul><li>Word queries find all the lines that match a given <code>string</code>:</li></ul>

```c++
Executing Query for:
Daddy Daddy occurs 3 times
(line 2) Her Daddy says when the wind blows
(line 7) "Daddy, shush, there is no such thing,"
(line 10) Shyly, she asks, "I mean, Daddy, is there?"
```

<ul><li>Not queries, using the <code>~</code> operator, yield lines that don’t match the query:</li></ul>

```c++
Executing Query for: ~(Alice)
~(Alice) occurs 9 times
(line 2) Her Daddy says when the wind blows
(line 3) through her hair, it looks almost alive,
(line 4) like a fiery bird in flight.
...
```

<ul><li>Or queries, using the <code>|</code> operator, return lines matching either of two queries:</li></ul>

```c++
Executing Query for: (hair | Alice)
(hair | Alice) occurs 2 times
(line 1) Alice Emma has long flowing red hair.
(line 3) through her hair, it looks almost alive,
```

<ul><li>And queries, using the <code>&amp;</code> operator, return lines matching both queries:</li></ul>

```c++
Executing query for: (hair & Alice)
(hair & Alice) occurs 1 time
(line 1) Alice Emma has long flowing red hair.
```

<p>Moreover, we want to be able to combine these operations, as in</p>

```c++
fiery & bird | wind
```

<p>We’ll use normal C++ precedence rules (§<a href="039-4.1._fundamentals.html#filepos1010254">4.1.2</a>, p. <a href="039-4.1._fundamentals.html#filepos1010254">136</a>) to evaluate compound expressions such as this example. Thus, this query will match a line in which both <code>fiery</code> and <code>bird</code> appear or one in which <code>wind</code> appears:</p>

```c++
Executing Query for: ((fiery & bird) | wind)
((fiery & bird) | wind) occurs 3 times
(line 2) Her Daddy says when the wind blows
(line 4) like a fiery bird in flight.
(line 5) A beautiful fiery bird, he tells her,
```

<p>Our output will print the query, using parentheses to indicate the way in which the query was interpreted. As with our original implementation, our system will display lines in ascending order and will not display the same line more than once.</p>
<h4 id="filepos4058655">15.9.1. An Object-Oriented Solution</h4>
<p>We might think that we should use the <code>TextQuery</code> class from §<a href="116-12.3._using_the_library_a_textquery_program.html#filepos3157528">12.3.2</a> (p. <a href="116-12.3._using_the_library_a_textquery_program.html#filepos3157528">487</a>) to represent our word query and derive our other queries from that class.</p>
<p>However, this design would be flawed. To see why, consider a Not query. A Word query looks for a particular word. In order for a Not query to be a kind of Word query, we would have to be able to identify the word for which the Not query was searching. In general, there is no such word. Instead, a Not query has a query (a Word query or any other kind of query) whose value it negates. Similarly, an And query and an Or query have two queries whose results it combines.</p>
<p>This observation suggests that we model our different kinds of queries as independent classes that share a common base class:</p>

```c++
WordQuery // Daddy
NotQuery  // ~Alice
OrQuery   // hair | Alice
AndQuery  // hair & Alice
```

<p>These classes will have only two operations:</p>
<ul><li><code>eval</code>, which takes a <code>TextQuery</code> object and returns a <code>QueryResult</code>. The <code>eval</code> function will use the given <code>TextQuery</code> object to find the query’s the matching lines.</li><li><code>rep</code>, which returns the <code>string</code> representation of the underlying query. This function will be used by <code>eval</code> to create a <code>QueryResult</code> representing the match and by the output operator to print the query expressions.</li></ul>

<h5>Abstract Base Class</h5>
<p>As we’ve seen, our four query types are not related to one another by inheritance; they are conceptually siblings. Each class shares the same interface, which suggests that we’ll need to define an abstract base class (§<a href="145-15.4._abstract_base_classes.html#filepos3884701">15.4</a>, p. <a href="145-15.4._abstract_base_classes.html#filepos3884701">610</a>) to represent that interface. We’ll name our abstract base class <code>Query_base</code>, indicating that its role is to serve as the root of our query hierarchy.</p>
<p>Our <code>Query_base</code> class will define <code>eval</code> and <code>rep</code> as pure virtual functions (§<a href="145-15.4._abstract_base_classes.html#filepos3884701">15.4</a>, p. <a href="145-15.4._abstract_base_classes.html#filepos3884701">610</a>). Each of our classes that represents a particular kind of query must override these functions. We’ll derive <code>WordQuery</code> and <code>NotQuery</code> directly from <a id="filepos4063003"></a><code>Query_base</code>. The <code>AndQuery</code> and <code>OrQuery</code> classes share one property that the other classes in our system do not: Each has two operands. To model this property, we’ll define another abstract base class, named <code>BinaryQuery</code>, to represent queries with two operands. The <code>AndQuery</code> and <code>OrQuery</code> classes will inherit from <code>BinaryQuery</code>, which in turn will inherit from <code>Query_base</code>. These decisions give us the class design represented in <a href="150-15.9._text_queries_revisited.html#filepos4064029">Figure 15.2</a>.</p>
<a id="filepos4064029"></a><img alt="Image" src="/images/00103.jpg"/>
<p>Figure 15.2. <code>Query_base</code> Inheritance Hierarchy</p>

::: info
<p>Key Concept: Inheritance versus Composition</p>
<p>The design of inheritance hierarchies is a complicated topic in its own right and well beyond the scope of this language Primer. However, there is one important design guide that is so fundamental that every programmer should be familiar with it.</p>
<p>When we define a class as publicly inherited from another, the derived class should reflect an “Is A” relationship to the base class. In well-designed class hierarchies, objects of a publicly derived class can be used wherever an object of the base class is expected.</p>
<p>Another common relationship among types is a “Has A” relationship. Types related by a “Has A” relationship imply membership.</p>
<p>In our bookstore example, our base class represents the concept of a quote for a book sold at a stipulated price. Our <code>Bulk_quote</code> “is a” kind of quote, but one with a different pricing strategy. Our bookstore classes “have a” price and an <small>ISBN</small>.</p>
:::

<h5>Hiding a Hierarchy in an Interface Class</h5>
<p>Our program will deal with evaluating queries, not with building them. However, we need to be able to create queries in order to run our program. The simplest way to do so is to write C++ expressions to create the queries. For example, we’d like to generate the compound query previously described by writing code such as</p>

```c++
Query q = Query("fiery") & Query("bird") | Query("wind");
```

<p><a id="filepos4066923"></a>This problem description implicitly suggests that user-level code won’t use the inherited classes directly. Instead, we’ll define an interface class named <code>Query</code>, which will hide the hierarchy. The <code>Query</code> class will store a pointer to <code>Query_base</code>. That pointer will be bound to an object of a type derived from <code>Query_base</code>. The <code>Query</code> class will provide the same operations as the <code>Query_base</code> classes: <code>eval</code> to evaluate the associated query, and <code>rep</code> to generate a <code>string</code> version of the query. It will also define an overloaded output operator to display the associated query.</p>
<p>Users will create and manipulate <code>Query_base</code> objects only indirectly through operations on <code>Query</code> objects. We’ll define three overloaded operators on <code>Query</code> objects, along with a <code>Query</code> constructor that takes a <code>string</code>. Each of these functions will dynamically allocate a new object of a type derived from <code>Query_base</code>:</p>
<ul><li>The <code>&amp;</code> operator will generate a <code>Query</code> bound to a new <code>AndQuery</code>.</li><li>The <code>|</code> operator will generate a <code>Query</code> bound to a new <code>OrQuery</code>.</li><li>The <code>~</code> operator will generate a <code>Query</code> bound to a new <code>NotQuery</code>.</li><li>The <code>Query</code> constructor that takes a <code>string</code> will generate a new <code>WordQuery</code>.</li></ul>

<h5>Understanding How These Classes Work</h5>
<p>It is important to realize that much of the work in this application consists of building objects to represent the user’s query. For example, an expression such as the one above generates the collection of interrelated objects illustrated in <a href="150-15.9._text_queries_revisited.html#filepos4070749">Figure 15.3</a>.</p>
<a id="filepos4070749"></a><img alt="Image" src="/images/00104.jpg"/>
<p>Figure 15.3. Objects Created by <code>Query</code> Expressions</p>
<p>Once the tree of objects is built up, evaluating (or generating the representation of) a query is basically a process (managed for us by the compiler) of following these links, asking each object to evaluate (or display) itself. For example, if we <a id="filepos4071360"></a>call <code>eval</code> on <code>q</code> (i.e., on the root of the tree), that call asks the <code>OrQuery</code> to which <code>q</code> points to <code>eval</code> itself. Evaluating this <code>OrQuery</code> calls <code>eval</code> on its two operands—on the <code>AndQuery</code> and the <code>WordQuery</code> that looks for the word <code>wind</code>. Evaluating the <code>AndQuery</code> evaluates its two <code>WordQuery</code>s, generating the results for the words <code>fiery</code> and <code>bird</code>, respectively.</p>
<p>When new to object-oriented programming, it is often the case that the hardest part in understanding a program is understanding the design. Once you are thoroughly comfortable with the design, the implementation flows naturally. As an aid to understanding this design, we’ve summarized the classes used in this example in <a href="150-15.9._text_queries_revisited.html#filepos4073117">Table 15.1</a> (overleaf).</p>
<p><a id="filepos4073117"></a>Table 15.1. Recap: Query Program Design</p>
<img alt="Image" src="/images/00105.jpg"/>

::: info
<p>Exercises Section 15.9.1</p>
<p><strong>Exercise 15.31:</strong> Given that <code>s1</code>, <code>s2</code>, <code>s3</code>, and <code>s4</code> are all <code>string</code>s, determine what objects are created in the following expressions:</p>

<p><strong>(a)</strong>
<code>Query(s1) | Query(s2) &amp; ~ Query(s3);</code></p>
<p><strong>(b)</strong>
<code>Query(s1) | (Query(s2) &amp; ~ Query(s3));</code></p>
<p><strong>(c)</strong>
<code>(Query(s1) &amp; (Query(s2)) | (Query(s3) &amp; Query(s4)));</code></p>
:::

<h4 id="filepos4074865">15.9.2. The <code>Query_base</code> and <code>Query</code> Classes</h4>
<p>We’ll start our implementation by defining the <code>Query_base</code> class:</p>

```c++
// abstract class acts as a base class for concrete query types; all members are private
class Query_base {
    friend class Query;
protected:
    using line_no = TextQuery::line_no; // used in the eval functions
    virtual ~Query_base() = default;
private:
    // eval returns the QueryResult that matches this Query
    virtual QueryResult eval(const TextQuery&) const = 0;
    // rep is a string representation of the query
    virtual std::string rep() const = 0;
};
```

<p>Both <code>eval</code> and <code>rep</code> are pure virtual functions, which makes <code>Query_base</code> an abstract base class (§<a href="145-15.4._abstract_base_classes.html#filepos3884701">15.4</a>, p. <a href="145-15.4._abstract_base_classes.html#filepos3884701">610</a>). Because we don’t intend users, or the derived classes, to use <code>Query_base</code> directly, <code>Query_base</code> has no <code>public</code> members. All use of <code>Query_base</code> will be through <code>Query</code> objects. We grant friendship to the <code>Query</code> class, because members of <code>Query</code> will call the virtuals in <code>Query_base</code>.</p>
<p>The <code>protected</code> member, <code>line_no</code>, will be used inside the <code>eval</code> functions. Similarly, the destructor is <code>protected</code> because it is used (implicitly) by the destructors in the derived classes.</p>
<h5><a id="filepos4079028"></a>The <code>Query</code> Class</h5>
<p>The <code>Query</code> class provides the interface to (and hides) the <code>Query_base</code> inheritance hierarchy. Each <code>Query</code> object will hold a <code>shared_ptr</code> to a corresponding <code>Query_base</code> object. Because <code>Query</code> is the only interface to the <code>Query_base</code> classes, <code>Query</code> must define its own versions of <code>eval</code> and <code>rep</code>.</p>
<p>The <code>Query</code> constructor that takes a <code>string</code> will create a new <code>WordQuery</code> and bind its <code>shared_ptr</code> member to that newly created object. The <code>&amp;</code>, <code>|</code>, and <code>~</code> operators will create <code>AndQuery</code>, <code>OrQuery</code>, and <code>NotQuery</code> objects, respectively. These operators will return a <code>Query</code> object bound to its newly generated object. To support these operators, <code>Query</code> needs a constructor that takes a <code>shared_ptr</code> to a <code>Query_base</code> and stores its given pointer. We’ll make this constructor <code>private</code> because we don’t intend general user code to define <code>Query_base</code> objects. Because this constructor is <code>private</code>, we’ll need to make the operators <code>friend</code>s.</p>
<p>Given the preceding design, the <code>Query</code> class itself is simple:</p>

```c++
// interface class to manage the Query_base inheritance hierarchy
class Query {
    // these operators need access to the shared_ptr constructor
    friend Query operator~(const Query &);
    friend Query operator|(const Query&, const Query&);
    friend Query operator&(const Query&, const Query&);
public:
    Query(const std::string&);  // builds a new WordQuery
    // interface functions: call the corresponding Query_base operations
    QueryResult eval(const TextQuery &t) const
                            { return q->eval(t); }
    std::string rep() const { return q->rep(); }
private:
    Query(std::shared_ptr<Query_base> query): q(query) { }
    std::shared_ptr<Query_base> q;
};
```

<p><a id="filepos4084404"></a>We start by naming as friends the operators that create <code>Query</code> objects. These operators need to be friends in order to use the <code>private</code> constructor.</p>
<p>In the <code>public</code> interface for <code>Query</code>, we declare, but cannot yet define, the constructor that takes a <code>string</code>. That constructor creates a <code>WordQuery</code> object, so we cannot define this constructor until we have defined the <code>WordQuery</code> class.</p>
<p>The other two <code>public</code> members represent the interface for <code>Query_base</code>. In each case, the <code>Query</code> operation uses its <code>Query_base</code> pointer to call the respective (virtual) <code>Query_base</code> operation. The actual version that is called is determined at run time and will depend on the type of the object to which <code>q</code> points.</p>
<h5>The <code>Query</code> Output Operator</h5>
<img alt="Image" src="/images/00011.jpg"/>
<p>The output operator is a good example of how our overall query system works:</p>

```c++
std::ostream &
operator<<(std::ostream &os, const Query &query)
{
    // Query::rep makes a virtual call through its Query_base pointer to rep()
    return os << query.rep();
}
```

<p>When we print a <code>Query</code>, the output operator calls the (public) <code>rep</code> member of class <code>Query</code>. That function makes a virtual call through its pointer member to the <code>rep</code> member of the object to which this <code>Query</code> points. That is, when we write</p>

```c++
Query andq = Query(sought1) & Query(sought2);
cout << andq << endl;
```

<p>the output operator calls <code>Query::rep</code> on <code>andq</code>. <code>Query::rep</code> in turn makes a virtual call through its <code>Query_base</code> pointer to the <code>Query_base</code> version of <code>rep</code>. Because <code>andq</code> points to an <code>AndQuery</code> object, that call will run <code>AndQuery::rep</code>.</p>

::: info
<p>Exercises Section 15.9.2</p>
<p><strong>Exercise 15.32:</strong> What happens when an object of type <code>Query</code> is copied, moved, assigned, and destroyed?</p>
<p><strong>Exercise 15.33:</strong> What about objects of type <code>Query_base</code>?</p>
:::

<h4 id="filepos4089928"><a id="filepos4089961"></a>15.9.3. The Derived Classes</h4>
<p>The most interesting part of the classes derived from <code>Query_base</code> is how they are represented. The <code>WordQuery</code> class is most straightforward. Its job is to hold the search word.</p>
<p>The other classes operate on one or two operands. A <code>NotQuery</code> has a single operand, and <code>AndQuery</code> and <code>OrQuery</code> have two operands. In each of these classes, the operand(s) can be an object of any of the concrete classes derived from <code>Query_base</code>: A <code>NotQuery</code> can be applied to a <code>WordQuery</code>, an <code>AndQuery</code>, an <code>OrQuery</code>, or another <code>NotQuery</code>. To allow this flexibility, the operands must be stored as pointers to <code>Query_base</code>. That way we can bind the pointer to whichever concrete class we need.</p>
<p>However, rather than storing a <code>Query_base</code> pointer, our classes will themselves use a <code>Query</code> object. Just as user code is simplified by using the interface class, we can simplify our own class code by using the same class.</p>
<p>Now that we know the design for these classes, we can implement them.</p>
<h5>The <code>WordQuery</code> Class</h5>
<p>A <code>WordQuery</code> looks for a given <code>string</code>. It is the only operation that actually performs a query on the given <code>TextQuery</code> object:</p>

```c++
class WordQuery: public Query_base {
    friend class Query; // Query uses the WordQuery constructor
    WordQuery(const std::string &s): query_word(s) { }
    // concrete class: WordQuery defines all inherited pure virtual functions
    QueryResult eval(const TextQuery &t) const
                     { return t.query(query_word); }
    std::string rep() const { return query_word; }
    std::string query_word;    // word for which to search
};
```

<p>Like <code>Query_base</code>, <code>WordQuery</code> has no <code>public</code> members; <code>WordQuery</code> must make <code>Query</code> a friend in order to allow <code>Query</code> to access the <code>WordQuery</code> constructor.</p>
<p>Each of the concrete query classes must define the inherited pure virtual functions, <code>eval</code> and <code>rep</code>. We defined both operations inside the <code>WordQuery</code> class body: <code>eval</code> calls the <code>query</code> member of its given <code>TextQuery</code> parameter, which does the actual search in the file; <code>rep</code> returns the <code>string</code> that this <code>WordQuery</code> represents (i.e., <code>query_word</code>).</p>
<p>Having defined the <code>WordQuery</code> class, we can now define the <code>Query</code> constructor that takes a <code>string</code>:</p>

```c++
inline
Query::Query(const std::string &s): q(new WordQuery(s)) { }
```

<p>This constructor allocates a <code>WordQuery</code> and initializes its pointer member to point to that newly allocated object.</p>
<h5>The <code>NotQuery</code> Class and the <code>~</code> Operator</h5>
<p>The <code>~</code> operator generates a <code>NotQuery</code>, which holds a <code>Query</code>, which it negates:</p>
<p><a id="filepos4097604"></a></p>

```c++
class NotQuery: public Query_base {
    friend Query operator~(const Query &);
    NotQuery(const Query &q): query(q) { }
    // concrete class: NotQuery defines all inherited pure virtual functions
    std::string rep() const {return "~(" + query.rep() + ")";}
    QueryResult eval(const TextQuery&) const;
    Query query;
};
inline Query operator~(const Query &operand)
{
    return std::shared_ptr<Query_base>(new NotQuery(operand));
}
```

<p>Because the members of <code>NotQuery</code> are all <code>private</code>, we start by making the <code>~</code> operator a friend. To <code>rep</code> a <code>NotQuery</code>, we concatenate the <code>~</code> symbol to the representation of the underlying <code>Query</code>. We parenthesize the output to ensure that precedence is clear to the reader.</p>
<p>It is worth noting that the call to <code>rep</code> in <code>NotQuery</code>’s own <code>rep</code> member ultimately makes a virtual call to <code>rep</code>: <code>query.rep()</code> is a nonvirtual call to the <code>rep</code> member of the <code>Query</code> class. <code>Query::rep</code> in turn calls <code>q-&gt;rep()</code>, which is a virtual call through its <code>Query_base</code> pointer.</p>
<p>The <code>~</code> operator dynamically allocates a new <code>NotQuery</code> object. The return (implicitly) uses the <code>Query</code> constructor that takes a <code>shared_ptr&lt;Query_base&gt;</code>. That is, the <code>return</code> statement is equivalent to</p>

```c++
// allocate a new NotQuery object
// bind the resulting NotQuery pointer to a shared_ptr<Query_base
shared_ptr<Query_base> tmp(new NotQuery(expr));
return Query(tmp); // use the Query constructor that takes a shared_ptr
```

<p>The <code>eval</code> member is complicated enough that we will implement it outside the class body. We’ll define the <code>eval</code> functions in §<a href="150-15.9._text_queries_revisited.html#filepos4114112">15.9.4</a> (p. <a href="150-15.9._text_queries_revisited.html#filepos4114112">647</a>).</p>
<h5>The <code>BinaryQuery</code> Class</h5>
<p>The <code>BinaryQuery</code> class is an abstract base class that holds the data needed by the query types that operate on two operands:</p>

```c++
class BinaryQuery: public Query_base {
protected:
    BinaryQuery(const Query &l, const Query &r, std::string s):
          lhs(l), rhs(r), opSym(s) { }
    // abstract class: BinaryQuery doesn't define eval
    std::string rep() const { return "(" + lhs.rep() + " "
                                         + opSym + " "
                                         + rhs.rep() + ")"; }
    Query lhs, rhs;    // right- and left-hand operands
    std::string opSym; // name of the operator
};
```

<p><a id="filepos4104958"></a>The data in a <code>BinaryQuery</code> are the two <code>Query</code> operands and the corresponding operator symbol. The constructor takes the two operands and the operator symbol, each of which it stores in the corresponding data members.</p>
<p>To <code>rep</code> a <code>BinaryOperator</code>, we generate the parenthesized expression consisting of the representation of the left-hand operand, followed by the operator, followed by the representation of the right-hand operand. As when we displayed a <code>NotQuery</code>, the calls to <code>rep</code> ultimately make virtual calls to the <code>rep</code> function of the <code>Query_base</code> objects to which <code>lhs</code> and <code>rhs</code> point.</p>

::: info
<p>Note</p>
<p>The <code>BinaryQuery</code> class does not define the <code>eval</code> function and so inherits a pure virtual. Thus, <code>BinaryQuery</code> is also an abstract base class, and we cannot create objects of <code>BinaryQuery</code> type.</p>
:::

<h5>The <code>AndQuery</code> and <code>OrQuery</code> Classes and Associated Operators</h5>
<p>The <code>AndQuery</code> and <code>OrQuery</code> classes, and their corresponding operators, are quite similar to one another:</p>

```c++
class AndQuery: public BinaryQuery {
    friend Query operator& (const Query&, const Query&);
    AndQuery(const Query &left, const Query &right):
                        BinaryQuery(left, right, "&") { }
    // concrete class: AndQuery inherits rep and defines the remaining pure virtual
    QueryResult eval(const TextQuery&) const;
};
inline Query operator&(const Query &lhs, const Query &rhs)
{
    return std::shared_ptr<Query_base>(new AndQuery(lhs, rhs));
}

class OrQuery: public BinaryQuery {
    friend Query operator|(const Query&, const Query&);
    OrQuery(const Query &left, const Query &right):
                BinaryQuery(left, right, "|") { }
    QueryResult eval(const TextQuery&) const;
};
inline Query operator|(const Query &lhs, const Query &rhs)
{
    return std::shared_ptr<Query_base>(new OrQuery(lhs, rhs));
}
```

<p>These classes make the respective operator a friend and define a constructor to create their <code>BinaryQuery</code> base part with the appropriate operator. They inherit the <code>BinaryQuery</code> definition of <code>rep</code>, but each overrides the <code>eval</code> function.</p>
<p>Like the <code>~</code> operator, the <code>&amp;</code> and <code>|</code> operators return a <code>shared_ptr</code> bound to a newly allocated object of the corresponding type. That <code>shared_ptr</code> gets converted to <code>Query</code> as part of the return statement in each of these operators.</p>

::: info
<a id="filepos4110943"></a><p>Exercises Section 15.9.3</p>
<p><strong>Exercise 15.34:</strong> For the expression built in <a href="150-15.9._text_queries_revisited.html#filepos4070749">Figure 15.3</a> (p. <a href="150-15.9._text_queries_revisited.html#filepos4070749">638</a>):</p>
<p><strong>(a)</strong> List the constructors executed in processing that expression.</p>
<p><strong>(b)</strong> List the calls to <code>rep</code> that are made from <code>cout &lt;&lt; q</code>.</p>
<p><strong>(c)</strong> List the calls to <code>eval</code> made from <code>q.eval()</code>.</p>
<p><strong>Exercise 15.35:</strong> Implement the <code>Query</code> and <code>Query_base</code> classes, including a definition of <code>rep</code> but omitting the definition of <code>eval</code>.</p>
<p><strong>Exercise 15.36:</strong> Put print statements in the constructors and <code>rep</code> members and run your code to check your answers to <code>(a)</code> and <code>(b)</code> from the first exercise.</p>
<p><strong>Exercise 15.37:</strong> What changes would your classes need if the derived classes had members of type <code>shared_ptr&lt;Query_base&gt;</code> rather than of type <code>Query</code>?</p>
<p><strong>Exercise 15.38:</strong> Are the following declarations legal? If not, why not? If so, explain what the declarations mean.</p>

```c++
BinaryQuery a = Query("fiery") & Query("bird");
AndQuery b = Query("fiery") & Query("bird");
OrQuery c = Query("fiery") & Query("bird");
```

:::

<h4 id="filepos4114112">15.9.4. The <code>eval</code> Functions</h4>
<p>The <code>eval</code> functions are the heart of our query system. Each of these functions calls <code>eval</code> on its operand(s) and then applies its own logic: The <code>OrQuery eval</code> operation returns the union of the results of its two operands; <code>AndQuery</code> returns the intersection. The <code>NotQuery</code> is more complicated: It must return the line numbers that are not in its operand’s set.</p>
<p>To support the processing in the <code>eval</code> functions, we need to use the version of <code>QueryResult</code> that defines the members we added in the exercises to §<a href="116-12.3._using_the_library_a_textquery_program.html#filepos3157528">12.3.2</a> (p. <a href="116-12.3._using_the_library_a_textquery_program.html#filepos3157528">490</a>). We’ll assume that <code>QueryResult</code> has <code>begin</code> and <code>end</code> members that will let us iterate through the <code>set</code> of line numbers that the <code>QueryResult</code> holds. We’ll also assume that <code>QueryResult</code> has a member named <code>get_file</code> that returns a <code>shared_ptr</code> to the underlying file on which the query was executed.</p>

::: warning
<p>Warning</p>
<p>Our <code>Query</code> classes use members defined for <code>QueryResult</code> in the exercises to §<a href="116-12.3._using_the_library_a_textquery_program.html#filepos3157528">12.3.2</a> (p. <a href="116-12.3._using_the_library_a_textquery_program.html#filepos3157528">490</a>).</p>
:::

<h5><code>OrQuery::eval</code></h5>
<p>An <code>OrQuery</code> represents the union of the results for its two operands, which we obtain by calling <code>eval</code> on each of its operands. Because these operands are <code>Query</code> objects, calling <code>eval</code> is a call to <code>Query::eval</code>, which in turn makes a virtual call to <code>eval</code> on the underlying <code>Query_base</code> object. Each of these calls yields a <code>QueryResult</code> representing the line numbers in which its operand appears. We’ll combine those line numbers into a new <code>set</code>:</p>
<p><a id="filepos4118222"></a></p>

```c++
// returns the union of its operands' result sets
QueryResult
OrQuery::eval(const TextQuery& text) const
{
    // virtual calls through the Query members, lhs and rhs
    // the calls to eval return the QueryResult for each operand
    auto right = rhs.eval(text), left = lhs.eval(text);
    // copy the line numbers from the left-hand operand into the result set
    auto ret_lines =
         make_shared<set<line_no>>(left.begin(), left.end());
    // insert lines from the right-hand operand
    ret_lines->insert(right.begin(), right.end());
    // return the new QueryResult representing the union of lhs and rhs
    return QueryResult(rep(), ret_lines, left.get_file());
}
```

<p>We initialize <code>ret_lines</code> using the <code>set</code> constructor that takes a pair of iterators. The <code>begin</code> and <code>end</code> members of a <code>QueryResult</code> return iterators into that object’s <code>set</code> of line numbers. So, <code>ret_lines</code> is created by copying the elements from <code>left</code>’s <code>set</code>. We next call <code>insert</code> on <code>ret_lines</code> to insert the elements from <code>right</code>. After this call, <code>ret_lines</code> contains the line numbers that appear in either <code>left</code> or <code>right</code>.</p>
<p>The <code>eval</code> function ends by building and returning a <code>QueryResult</code> representing the combined match. The <code>QueryResult</code> constructor (§<a href="116-12.3._using_the_library_a_textquery_program.html#filepos3157528">12.3.2</a>, p. <a href="116-12.3._using_the_library_a_textquery_program.html#filepos3157528">489</a>) takes three arguments: a <code>string</code> representing the query, a <code>shared_ptr</code> to the <code>set</code> of matching line numbers, and a <code>shared_ptr</code> to the <code>vector</code> that represents the input file. We call <code>rep</code> to generate the <code>string</code> and <code>get_file</code> to obtain the <code>shared_ptr</code> to the file. Because both <code>left</code> and <code>right</code> refer to the same file, it doesn’t matter which of these we use for <code>get_file</code>.</p>
<h5><code>AndQuery::eval</code></h5>
<p>The <code>AndQuery</code> version of <code>eval</code> is similar to the <code>OrQuery</code> version, except that it calls a library algorithm to find the lines in common to both queries:</p>

```c++
// returns the intersection of its operands' result sets
QueryResult
AndQuery::eval(const TextQuery& text) const
{
    // virtual calls through the Query operands to get result sets for the operands
    auto left = lhs.eval(text), right = rhs.eval(text);
    // set to hold the intersection of left and right
    auto ret_lines = make_shared<set<line_no>>();
    // writes the intersection of two ranges to a destination iterator
    // destination iterator in this call adds elements to ret
    set_intersection(left.begin(), left.end(),
                   right.begin(), right.end(),
                   inserter(*ret_lines, ret_lines->begin()));
    return QueryResult(rep(), ret_lines, left.get_file());
}
```

<p><a id="filepos4127069"></a>Here we use the library <code>set_intersection</code> algorithm, which is described in <a href="189-a.2._a_brief_tour_of_the_algorithms.html#filepos5478694">Appendix A.2.8</a> (p. <a href="189-a.2._a_brief_tour_of_the_algorithms.html#filepos5478694">880</a>), to merge these two <code>set</code>s.</p>
<p>The <code>set_intersection</code> algorithm takes five iterators. It uses the first four to denote two input sequences (§<a href="102-10.5._structure_of_generic_algorithms.html#filepos2684451">10.5.2</a>, p. <a href="102-10.5._structure_of_generic_algorithms.html#filepos2684451">413</a>). Its last argument denotes a destination. The algorithm writes the elements that appear in both input sequences into the destination.</p>
<p>In this call we pass an insert iterator (§<a href="101-10.4._revisiting_iterators.html#filepos2619592">10.4.1</a>, p. <a href="101-10.4._revisiting_iterators.html#filepos2619592">401</a>) as the destination. When <code>set_intersection</code> writes to this iterator, the effect will be to insert a new element into <code>ret_lines</code>.</p>
<p>Like the <code>OrQuery eval</code> function, this one ends by building and returning a <code>QueryResult</code> representing the combined match.</p>
<h5><code>NotQuery::eval</code></h5>
<p><code>NotQuery</code> finds each line of the text within which the operand is not found:</p>

```c++
// returns the lines not in its operand's result set
QueryResult
NotQuery::eval(const TextQuery& text) const
{
    // virtual call to eval through the Query operand
    auto result = query.eval(text);
    // start out with an empty result set
    auto ret_lines = make_shared<set<line_no>>();
    // we have to iterate through the lines on which our operand appears
    auto beg = result.begin(), end = result.end();
    // for each line in the input file, if that line is not in result,
    // add that line number to ret_lines
    auto sz = result.get_file()->size();
    for (size_t n = 0; n != sz; ++n) {
        // if we haven't processed all the lines in result
        // check whether this line is present
        if (beg == end || *beg != n)
            ret_lines->insert(n);  // if not in result, add this line
        else if (beg != end)
            ++beg; // otherwise get the next line number in result if there is one
    }
    return QueryResult(rep(), ret_lines, result.get_file());
}
```

<p>As in the other <code>eval</code> functions, we start by calling <code>eval</code> on this object’s operand. That call returns the <code>QueryResult</code> containing the line numbers on which the operand appears, but we want the line numbers on which the operand does not appear. That is, we want every line in the file that is not already in <code>result</code>.</p>
<p>We generate that <code>set</code> by iterating through sequenital integers up to the size of the input file. We’ll put each number that is not in <code>result</code> into <code>ret_lines</code>. We position <code>beg</code> and <code>end</code> to denote the first and one past the last elements in <code>result</code>. That object is a <code>set</code>, so when we iterate through it, we’ll obtain the line numbers in ascending order.</p>
<p>The loop body checks whether the current number is in <code>result</code>. If not, we add that number to <code>ret_lines</code>. If the number is in <code>result</code>, we increment <code>beg</code>, which is our iterator into <code>result</code>.</p>
<p>Once we’ve processed all the line numbers, we return a <code>QueryResult</code> containing <code>ret_lines</code>, along with the results of running <code>rep</code> and <code>get_file</code> as in the previous <code>eval</code> functions.</p>

::: info
<p>Exercises Section 15.9.4</p>
<p><strong>Exercise 15.39:</strong> Implement the <code>Query</code> and <code>Query_base</code> classes. Test your application by evaluating and printing a query such as the one in <a href="150-15.9._text_queries_revisited.html#filepos4070749">Figure 15.3</a> (p. <a href="150-15.9._text_queries_revisited.html#filepos4070749">638</a>).</p>
<p><strong>Exercise 15.40:</strong> In the <code>OrQuery eval</code> function what would happen if its <code>rhs</code> member returned an empty set? What if its <code>lhs</code> member did so? What if both <code>rhs</code> and <code>lhs</code> returned empty sets?</p>
<p><strong>Exercise 15.41:</strong> Reimplement your classes to use built-in pointers to <code>Query_base</code> rather than <code>shared_ptr</code>s. Remember that your classes will no longer be able to use the synthesized copy-control members.</p>
<p><strong>Exercise 15.42:</strong> Design and implement one of the following enhancements:</p>
<p><strong>(a)</strong> Print words only once per sentence rather than once per line.</p>
<p><strong>(b)</strong> Introduce a history system in which the user can refer to a previous query by number, possibly adding to it or combining it with another.</p>
<p><strong>(c)</strong> Allow the user to limit the results so that only matches in a given range of lines are displayed.</p>
:::

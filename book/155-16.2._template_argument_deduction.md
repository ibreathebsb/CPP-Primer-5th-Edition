<h3 id="filepos4324217">16.2. Template Argument Deduction</h3>
<p>We’ve seen that, by default, the compiler uses the arguments in a call to determine the template parameters for a function template. The process of determining the template arguments from the function arguments is known as <strong><a href="160-defined_terms.html#filepos4554571" id="filepos4324590">template argument deduction</a></strong>. During template argument deduction, the compiler uses types of the arguments in the call to find the template arguments that generate a version of the function that best matches the given call.</p>
<h4 id="filepos4324892"><a id="filepos4324925"></a>16.2.1. Conversions and Template Type Parameters</h4>
<Badge type="info" text="Fundamental" />
<p>As with a nontemplate function, the arguments we pass in a call to a function template are used to initialize that function’s parameters. Function parameters whose type uses a template type parameter have special initialization rules. Only a very limited number of conversions are automatically applied to such arguments. Rather than converting the arguments, the compiler generates a new instantiation.</p>
<p>As usual, top-level <code>const</code>s (§ <a href="024-2.4._const_qualifier.html#filepos504024">2.4.3</a>, p. <a href="024-2.4._const_qualifier.html#filepos504024">63</a>) in either the parameter or the argument are ignored. The only other conversions performed in a call to a function template are</p>
<ul><li><code>const</code> conversions: A function parameter that is a reference (or pointer) to a <code>const</code> can be passed a reference (or pointer) to a non<code>const</code> object (§ <a href="049-4.11._type_conversions.html#filepos1178431">4.11.2</a>, p. <a href="049-4.11._type_conversions.html#filepos1178431">162</a>).</li><li>Array- or function-to-pointer conversions: If the function parameter is not a reference type, then the normal pointer conversion will be applied to arguments of array or function type. An array argument will be converted to a pointer to its first element. Similarly, a function argument will be converted to a pointer to the function’s type (§ <a href="049-4.11._type_conversions.html#filepos1178431">4.11.2</a>, p. <a href="049-4.11._type_conversions.html#filepos1178431">161</a>).</li></ul>

<p>Other conversions, such as the arithmetic conversions (§ <a href="049-4.11._type_conversions.html#filepos1162796">4.11.1</a>, p. <a href="049-4.11._type_conversions.html#filepos1162796">159</a>), derived-to-base (§ <a href="143-15.2._defining_base_and_derived_classes.html#filepos3806030">15.2.2</a>, p. <a href="143-15.2._defining_base_and_derived_classes.html#filepos3806030">597</a>), and user-defined conversions (§ <a href="077-7.5._constructors_revisited.html#filepos1990205">7.5.4</a>, p. <a href="077-7.5._constructors_revisited.html#filepos1990205">294</a>, and § <a href="138-14.9._overloading_conversions_and_operators.html#filepos3713073">14.9</a>, p. <a href="138-14.9._overloading_conversions_and_operators.html#filepos3713073">579</a>), are not performed.</p>
<p>As examples, consider calls to the functions <code>fobj</code> and <code>fref</code>. The <code>fobj</code> function copies its parameters, whereas <code>fref</code>’s parameters are references:</p>

```c++
template <typename T> T fobj(T, T); // arguments are copied
template <typename T> T fref(const T&, const T&); // references
string s1("a value");
const string s2("another value");
fobj(s1, s2); // calls fobj(string, string); const is ignored
fref(s1, s2); // calls fref(const string&, const string&)
              // uses premissible conversion to const on s1
int a[10], b[42];
fobj(a, b); // calls f(int*, int*)
fref(a, b); // error: array types don't match
```

<p>In the first pair of calls, we pass a <code>string</code> and a <code>const string</code>. Even though these types do not match exactly, both calls are legal. In the call to <code>fobj</code>, the arguments are copied, so whether the original object is <code>const</code> doesn’t matter. In the call to <code>fref</code>, the parameter type is a reference to <code>const</code>. Conversion to <code>const</code> for a reference parameter is a permitted conversion, so this call is legal.</p>
<p>In the next pair of calls, we pass array arguments in which the arrays are different sizes and hence have different types. In the call to <code>fobj</code>, the fact that the array types differ doesn’t matter. Both arrays are converted to pointers. The template parameter type in <code>fobj</code> is <code>int*</code>. The call to <code>fref</code>, however, is illegal. When the parameter is a reference, the arrays are not converted to pointers (§ <a href="064-6.2._argument_passing.html#filepos1499104">6.2.4</a>, p. <a href="064-6.2._argument_passing.html#filepos1499104">217</a>). The types of <code>a</code> and <code>b</code> don’t match, so the call is in error.</p>

::: info
<a id="filepos4331654"></a>
<p><code>const</code> conversions and array or function to pointer are the only automatic conversions for arguments to parameters with template types.</p>
:::

<h5>Function Parameters That Use the Same Template Parameter Type</h5>
<p>A template type parameter can be used as the type of more than one function parameter. Because there are limited conversions, the arguments to such parameters must have essentially the same type. If the deduced types do not match, then the call is an error. For example, our <code>compare</code> function (§ <a href="154-16.1._defining_a_template.html#filepos4156441">16.1.1</a>, p. <a href="154-16.1._defining_a_template.html#filepos4156441">652</a>) takes two <code>const T&amp;</code> parameters. Its arguments must have essentially the same type:</p>

```c++
long lng;
compare(lng, 1024); // error: cannot instantiate compare(long, int)
```

<p>This call is in error because the arguments to <code>compare</code> don’t have the same type. The template argument deduced from the first argument is <code>long</code>; the one for the second is <code>int</code>. These types don’t match, so template argument deduction fails.</p>
<p>If we want to allow normal conversions on the arguments, we can define the function with two type parameters:</p>

```c++
// argument types can differ but must be compatible
template <typename A, typename B>
int flexibleCompare(const A& v1, const B& v2)
{
    if (v1 < v2) return -1;
    if (v2 < v1) return 1;
    return 0;
}
```

<p>Now the user may supply arguments of different types:</p>

```c++
long lng;
flexibleCompare(lng, 1024); // ok: calls flexibleCompare(long, int)
```

<p>Of course, a <code>&lt;</code> operator must exist that can compare values of those types.</p>
<h5>Normal Conversions Apply for Ordinary Arguments</h5>
<p>A function template can have parameters that are defined using ordinary types—that is, types that do not involve a template type parameter. Such arguments have no special processing; they are converted as usual to the corresponding type of the parameter (§ <a href="063-6.1._function_basics.html#filepos1415571">6.1</a>, p. <a href="063-6.1._function_basics.html#filepos1415571">203</a>). For example, consider the following template:</p>

```c++
template <typename T> ostream &print(ostream &os, const T &obj)
{
    return os << obj;
}
```

<p>The first function parameter has a known type, <code>ostream&amp;</code>. The second parameter, <code>obj</code>, has a template parameter type. Because the type of <code>os</code> is fixed, normal conversions are applied to arguments passed to <code>os</code> when <code>print</code> is called:</p>

```c++
print(cout, 42); // instantiates print(ostream&, int)
ofstream f("output");
print(f, 10);    // uses print(ostream&, int); converts f to ostream&
```

<p>In the first call, the type of the first argument exactly matches the type of the first parameter. This call will cause a version of <code>print</code> that takes an <code>ostream&amp;</code> and an <code>int</code> to be instantiated. In the second call, the first argument is an <code>ofstream</code> and there is a conversion from <code>ofstream</code> to <code>ostream&amp;</code> (§ <a href="084-8.2._file_input_and_output.html#filepos2114912">8.2.1</a>, p. <a href="084-8.2._file_input_and_output.html#filepos2114912">317</a>). Because the type of this parameter does not depend on a template parameter, the compiler will implicitly convert <code>f</code> to <code>ostream&amp;</code>.</p>

::: info
<p>Normal conversions are applied to arguments whose type is not a template parameter.</p>
:::

::: info
<p>Exercises Section 16.2.1</p>
<p><strong>Exercise 16.32:</strong> What happens during template argument deduction?</p>
<p><strong>Exercise 16.33:</strong> Name two type conversions allowed on function arguments involved in template argument deduction.</p>
<p><strong>Exercise 16.34:</strong> Given only the following code, explain whether each of these calls is legal. If so, what is the type of <code>T</code>? If not, why not?</p>

```c++
template <class T> int compare(const T&, const T&);
```

<p>(a) <code>compare("hi", "world");</code></p>
<p>(b) <code>compare("bye", "dad");</code></p>
<p><strong>Exercise 16.35:</strong> Which, if any, of the following calls are errors? If the call is legal, what is the type of <code>T</code>? If the call is not legal, what is the problem?</p>

```c++
template <typename T> T calc(T, int);
template <typename T> T fcn(T, T);
double d;    float f;    char c;
```

<p>(a) <code>calc(c, 'c');</code></p>
<p>(b) <code>calc(d, f);</code></p>
<p>(c) <code>fcn(c, 'c');</code></p>
<p>(d) <code>fcn(d, f);</code></p>
<p><strong>Exercise 16.36:</strong> What happens in the following calls:</p>

```c++
template <typename T> f1(T, T);
template <typename T1, typename T2) f2(T1, T2);
int i = 0, j = 42, *p1 = &i, *p2 = &j;
const int *cp1 = &i, *cp2 = &j;
```

<p>(a) <code>f1(p1, p2);</code></p>
<p>(b) <code>f2(p1, p2);</code></p>
<p>(c) <code>f1(cp1, cp2);</code></p>
<p>(d) <code>f2(cp1, cp2);</code></p>
<p>(e) <code>f1(p1, cp1);</code></p>
<p>(f) <code>f2(p1, cp1);</code></p>
:::

<h4 id="filepos4344365">16.2.2. Function-Template Explicit Arguments</h4>
<Badge type="info" text="Fundamental" />
<p>In some situations, it is not possible for the compiler to deduce the types of the template arguments. In others, we want to allow the user to control the template <a id="filepos4344735"></a>instantiation. Both cases arise most often when a function return type differs from any of those used in the parameter list.</p>
<h5>Specifying an Explicit Template Argument</h5>
<p>As an example in which we want to let the user specify which type to use, we’ll define a function template named <code>sum</code> that takes arguments of two different types. We’d like to let the user specify the type of the result. That way the user can choose whatever precision is appropriate.</p>
<p>We can let the user control the type of the return by defining a third template parameter to represent the return type:</p>

```c++
// T1 cannot be deduced: it doesn't appear in the function parameter list
template <typename T1, typename T2, typename T3>
T1 sum(T2, T3);
```

<p>In this case, there is no argument whose type can be used to deduce the type of <code>T1</code>. The caller must provide an <strong><a href="160-defined_terms.html#filepos4550678" id="filepos4346395">explicit template argument</a></strong> for this parameter on each call to <code>sum</code>.</p>
<p>We supply an explicit template argument to a call the same way that we define an instance of a class template. Explicit template arguments are specified inside angle brackets after the function name and before the argument list:</p>

```c++
// T1 is explicitly specified; T2 and T3 are inferred from the argument types
auto val3 = sum<long long>(i, lng); // long long sum(int, long)
```

<p>This call explicitly specifies the type for <code>T1</code>. The compiler will deduce the types for <code>T2</code> and <code>T3</code> from the types of <code>i</code> and <code>lng</code>.</p>
<p>Explicit template argument(s) are matched to corresponding template parameter(s) from left to right; the first template argument is matched to the first template parameter, the second argument to the second parameter, and so on. An explicit template argument may be omitted only for the trailing (right-most) parameters, and then only if these can be deduced from the function parameters. If our <code>sum</code> function had been written as</p>

```c++
// poor design: users must explicitly specify all three template parameters
template <typename T1, typename T2, typename T3>
T3 alternative_sum(T2, T1);
```

<p>then we would always have to specify arguments for all three parameters:</p>

```c++
// error: can't infer initial template parameters
auto val3 = alternative_sum<long long>(i, lng);
// ok: all three parameters are explicitly specified
auto val2 = alternative_sum<long long, int, long>(i, lng);
```

<h5>Normal Conversions Apply for Explicitly Specified Arguments</h5>
<p>For the same reasons that normal conversions are permitted for parameters that are defined using ordinary types (§ <a href="155-16.2._template_argument_deduction.html#filepos4324892">16.2.1</a>, p. <a href="155-16.2._template_argument_deduction.html#filepos4324892">680</a>), normal conversions also apply for arguments whose template type parameter is explicitly specified:</p>
<p><a id="filepos4350678"></a></p>

```c++
long lng;
compare(lng, 1024);       // error: template parameters don't match
compare<long>(lng, 1024); // ok: instantiates compare(long, long)
compare<int>(lng, 1024);  // ok: instantiates compare(int, int)
```

<p>As we’ve seen, the first call is in error because the arguments to <code>compare</code> must have the same type. If we explicitly specify the template parameter type, normal conversions apply. Thus, the call to <code>compare&lt;long&gt;</code> is equivalent to calling a function taking two <code>const long&amp;</code> parameters. The <code>int</code> parameter is automatically converted to <code>long</code>. In the second call, <code>T</code> is explicitly specified as <code>int</code>, so <code>lng</code> is converted to <code>int</code>.</p>

::: info
<p>Exercises Section 16.2.2</p>
<p><strong>Exercise 16.37:</strong> The library <code>max</code> function has two function parameters and returns the larger of its arguments. This function has one template type parameter. Could you call <code>max</code> passing it an <code>int</code> and a <code>double</code>? If so, how? If not, why not?</p>
<p><strong>Exercise 16.38:</strong> When we call <code>make_shared</code> (§ <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos2907541">12.1.1</a>, p. <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos2907541">451</a>), we have to provide an explicit template argument. Explain why that argument is needed and how it is used.</p>
<p><strong>Exercise 16.39:</strong> Use an explicit template argument to make it sensible to pass two string literals to the original version of <code>compare</code> from § <a href="154-16.1._defining_a_template.html#filepos4156441">16.1.1</a> (p. <a href="154-16.1._defining_a_template.html#filepos4156441">652</a>).</p>
:::

<h4 id="filepos4354202">16.2.3. Trailing Return Types and Type Transformation</h4>
<Badge type="danger" text="Advanced" />
<p>Using an explicit template argument to represent a template function’s return type works well when we want to let the user determine the return type. In other cases, requiring an explicit template argument imposes a burden on the user with no compensating advantage. For example, we might want to write a function that takes a pair of iterators denoting a sequence and returns a reference to an element in the sequence:</p>

```c++
template <typename It>
??? &fcn(It beg, It end)
{
    // process the range
    return *beg;  // return a reference to an element from the range
}
```

<p>We don’t know the exact type we want to return, but we do know that we want that type to be a reference to the element type of the sequence we’re processing:</p>

```c++
vector<int> vi = {1,2,3,4,5};
Blob<string> ca = { "hi", "bye" };
auto &i = fcn(vi.begin(), vi.end()); // fcn should return int&
auto &s = fcn(ca.begin(), ca.end()); // fcn should return string&
```

<a id="filepos4356678"></a><a id="filepos4356686"></a><Badge type="tip" text="C++11" />
<p>Here, we know that our function will return <code>*beg</code>, and we know that we can use <code>decltype(*beg)</code> to obtain the type of that expression. However, <code>beg</code> doesn’t exist until the parameter list has been seen. To define this function, we must use a trailing return type (§ <a href="065-6.3._return_types_and_the_return_statement.html#filepos1583824">6.3.3</a>, p. <a href="065-6.3._return_types_and_the_return_statement.html#filepos1583824">229</a>). Because a trailing return appears after the parameter list, it can use the function’s parameters:</p>

```c++
// a trailing return lets us declare the return type after the parameter list is seen
template <typename It>
auto fcn(It beg, It end) -> decltype(*beg)
{
    // process the range
    return *beg;  // return a reference to an element from the range
}
```

<p>Here we’ve told the compiler that <code>fcn</code>’s return type is the same as the type returned by dereferencing its <code>beg</code> parameter. The dereference operator returns an lvalue (§ <a href="039-4.1._fundamentals.html#filepos999677">4.1.1</a>, p. <a href="039-4.1._fundamentals.html#filepos999677">136</a>), so the type deduced by <code>decltype</code> is a reference to the type of the element that <code>beg</code> denotes. Thus, if <code>fcn</code> is called on a sequence of <code>string</code>s, the return type will be <code>string&amp;</code>. If the sequence is <code>int</code>, the return will be <code>int&amp;</code>.</p>
<h5>The Type Transformation Library Template Classes</h5>
<p>Sometimes we do not have direct access to the type that we need. For example, we might want to write a function similar to <code>fcn</code> that returns an element by value (§ <a href="065-6.3._return_types_and_the_return_statement.html#filepos1552941">6.3.2</a>, p. <a href="065-6.3._return_types_and_the_return_statement.html#filepos1552941">224</a>), rather than a reference to an element.</p>
<p>The problem we face in writing this function is that we know almost nothing about the types we’re passed. In this function, the only operations we know we can use are iterator operations, and there are no iterator operations that yield elements (as opposed to references to elements).</p>
<p>To obtain the element type, we can use a library <strong><a href="160-defined_terms.html#filepos4557460" id="filepos4360331">type transformation</a></strong> template. These templates are defined in the <code>type_traits</code> header. In general the classes in <code>type_traits</code> are used for so-called template metaprogramming, a topic that is beyond the scope of this Primer. However, the type transformation templates are useful in ordinary programming as well. These templates are described in <a href="155-16.2._template_argument_deduction.html#filepos4361085">Table 16.1</a> and we’ll see how they are implemented in § <a href="158-16.5._template_specializations.html#filepos4508634">16.5</a> (p. <a href="158-16.5._template_specializations.html#filepos4508634">710</a>).</p>
<p><a id="filepos4361085"></a>Table 16.1. Standard Type Transformation Templates</p>

| For `Mod<T>`, where Mod is | If `T` is                    | Then `Mod<T>::type` is |
|----------------------------|------------------------------|------------------------|
| `remove_reference`         | `X&` or `X&&`                | `X`                    |
|                            | otherwise                    | `T`                    |
| `add_const`                | `X&`, `const X`, or function | `T`                    |
|                            | otherwise                    | `const T`              |
| `add_lvalue_reference`     | `X&`                         | `T&`                   |
|                            | `X&&`                        | `X&`                   |
|                            | otherwise                    | `T&`                   |
| `add_rvalue_reference`     | `X&` or `X&&`                | `T`                    |
|                            | otherwise                    | `T&&`                  |
| `remove_pointer`           | `X*`                         | `X`                    |
|                            | otherwise                    | `T`                    |
| `add_pointer`              | `X&` or `X&&`                | `X*`                   |
|                            | otherwise                    | `T*`                   |
| `make_signed`              | `unsigned X`                 | `X`                    |
|                            | otherwise                    | `T`                    |
| `make_unsigned`            | `signed type`                | `unsigned T`           |
|                            | otherwise                    | `T`                    |
| `remove_extent`            | `X[n]`                       | `X`                    |
|                            | otherwise                    | `T`                    |
| `remove_all_extents`       | `X[n1][n2]...`               | `X`                    |
|                            | otherwise                    | `T`                    |

<p>In this case, we can use <code>remove_reference</code> to obtain the element type. The <code>remove_reference</code> template has one template type parameter and a <code>(public)</code> type member named <code>type</code>. If we instantiate <code>remove_reference</code> with a reference type, then <code>type</code> will be the referred-to type. For example, if we instantiate <code>remove_reference&lt;int&amp;&gt;</code>, the <code>type</code> member will be <code>int</code>. Similarly, if we instantiate <code>remove_reference&lt;string&amp;&gt;, type</code> will be <code>string</code>, and so on. More generally, given that <code>beg</code> is an iterator:</p>

```c++
remove_reference<decltype(*beg)>::type
```

<p>will be the type of the element to which <code>beg</code> refers: <code>decltype(*beg)</code> returns the reference type of the element type. <code>remove_reference::type</code> strips off the reference, leaving the element type itself.</p>
<p>Using <code>remove_reference</code> and a trailing return with <code>decltype</code>, we can write our function to return a copy of an element’s value:</p>
<p><a id="filepos4363733"></a></p>

```c++
// must use typename to use a type member of a template parameter; see § 16.1.3 (p. 670)
template <typename It>
auto fcn2(It beg, It end) ->
    typename remove_reference<decltype(*beg)>::type
{
    // process the range
    return *beg;  // return a copy of an element from the range
}
```

<p>Note that <code>type</code> is member of a class that depends on a template parameter. As a result, we must use <code>typename</code> in the declaration of the return type to tell the compiler that <code>type</code> represents a type (§ <a href="154-16.1._defining_a_template.html#filepos4259709">16.1.3</a>, p. <a href="154-16.1._defining_a_template.html#filepos4259709">670</a>).</p>
<p>Each of the type transformation templates described in <a href="155-16.2._template_argument_deduction.html#filepos4361085">Table 16.1</a> works similarly to <code>remove_reference</code>. Each template has a <code>public</code> member named <code>type</code> that represents a type. That type may be related to the template’s own template type parameter in a way that is indicated by the template’s name. If it is not possible (or not necessary) to transform the template’s parameter, the <code>type</code> member is the template parameter type itself. For example, if <code>T</code> is a pointer type, then <code>remove_pointer&lt;T&gt;::type</code> is the type to which <code>T</code> points. If <code>T</code> isn’t a pointer, then no transformation is needed. In this case, <code>type</code> is the same type as <code>T</code>.</p>

::: info
<a id="filepos4366706"></a><p>Exercises Section 16.2.3</p>
<p><strong>Exercise 16.40:</strong> Is the following function legal? If not, why not? If it is legal, what, if any, are the restrictions on the argument type(s) that can be passed, and what is the return type?</p>

```c++
template <typename It>
auto fcn3(It beg, It end) -> decltype(*beg + 0)
{
    // process the range
    return *beg;  // return a copy of an element from the range
}
```

<p><strong>Exercise 16.41:</strong> Write a version of <code>sum</code> with a return type that is guaranteed to be large enough to hold the result of the addition.</p>
:::

<h4 id="filepos4368159">16.2.4. Function Pointers and Argument Deduction</h4>
<Badge type="danger" text="Advanced" />
<p>When we initialize or assign a function pointer (§ <a href="069-6.7._pointers_to_functions.html#filepos1702852">6.7</a>, p. <a href="069-6.7._pointers_to_functions.html#filepos1702852">247</a>) from a function template, the compiler uses the type of the pointer to deduce the template argument(s).</p>
<p>As an example, assume we have a function pointer that points to a function returning an <code>int</code> that takes two parameters, each of which is a reference to a <code>const int</code>. We can use that pointer to point to an instantiation of <code>compare</code>:</p>

```c++
template <typename T> int compare(const T&, const T&);
// pf1 points to the instantiation int compare(const int&, const int&)
int (*pf1)(const int&, const int&) = compare;
```

<p>The type of the parameters in <code>pf1</code> determines the type of the template argument for <code>T</code>. The template argument for <code>T</code> is <code>int</code>. The pointer <code>pf1</code> points to the instantiation of <code>compare</code> with <code>T</code> bound to <code>int</code>. It is an error if the template arguments cannot be determined from the function pointer type:</p>

```c++
// overloaded versions of func; each takes a different function pointer type
void func(int(*)(const string&, const string&));
void func(int(*)(const int&, const int&));
func(compare); // error: which instantiation of compare?
```

<p>The problem is that by looking at the type of <code>func</code>’s parameter, it is not possible to determine a unique type for the template argument. The call to <code>func</code> could instantiate the version of <code>compare</code> that takes <code>int</code>s or the version that takes <code>string</code>s. Because it is not possible to identify a unique instantiation for the argument to <code>func</code>, this call won’t compile.</p>
<p>We can disambiguate the call to <code>func</code> by using explicit template arguments:</p>

```c++
// ok: explicitly specify which version of compare to instantiate
func(compare<int>);  // passing compare(const int&, const int&)
```

<p>This expression calls the version of <code>func</code> that takes a function pointer with two <code>const int&amp;</code> parameters.</p>

::: info
<a id="filepos4373730"></a>
<p>When the address of a function-template instantiation is taken, the context must be such that it allows a unique type or value to be determined for each template parameter.</p>
:::

<h4 id="filepos4374182">16.2.5. Template Argument Deduction and References</h4>
<Badge type="danger" text="Advanced" />
<p>In order to understand type deduction from a call to a function such as</p>

```c++
template <typename T> void f(T &p);
```

<p>in which the function’s parameter <code>p</code> is a reference to a template type parameter <code>T</code>, it is important to keep in mind two points: Normal reference binding rules apply; and <code>const</code>s are low level, not top level.</p>
<h5>Type Deduction from Lvalue Reference Function Parameters</h5>
<p>When a function parameter is an ordinary (lvalue) reference to a template type parameter (i.e., that has the form <code>T&amp;</code>), the binding rules say that we can pass only an lvalue (e.g., a variable or an expression that returns a reference type). That argument might or might not have a <code>const</code> type. If the argument is <code>const</code>, then <code>T</code> will be deduced as a <code>const</code> type:</p>

```c++
template <typename T> void f1(T&);  // argument must be an lvalue
// calls to f1 use the referred-to type of the argument as the template parameter type
f1(i);   //  i is an int; template parameter T is int
f1(ci);  //  ci is a const int; template parameter T is const int
f1(5);   //  error: argument to a & parameter must be an lvalue
```

<p>If a function parameter has type <code>const T&amp;</code>, normal binding rules say that we can pass any kind of argument—an object (<code>const</code> or otherwise), a temporary, or a literal value. When the function parameter is itself <code>const</code>, the type deduced for <code>T</code> will not be a <code>const</code> type. The <code>const</code> is already part of the <em>function</em> parameter type; therefore, it does not also become part of the <em>template</em> parameter type:</p>

```c++
template <typename T> void f2(const T&); // can take an rvalue
// parameter in f2 is const &; const in the argument is irrelevant
// in each of these three calls, f2's function parameter is inferred as const int&
f2(i);  // i is an int; template parameter T is int
f2(ci); // ci is a const int, but template parameter T is int
f2(5);  // a const & parameter can be bound to an rvalue; T is int
```

<h5>Type Deduction from Rvalue Reference Function Parameters</h5>
<p>When a function parameter is an rvalue reference (§ <a href="126-13.6._moving_objects.html#filepos3429349">13.6.1</a>, p. <a href="126-13.6._moving_objects.html#filepos3429349">532</a>) (i.e., has the form <code>T&amp;&amp;)</code>, normal binding rules say that we can pass an rvalue to this parameter. When we do so, type deduction behaves similarly to deduction for an ordinary lvalue reference function parameter. The deduced type for <code>T</code> is the type of the rvalue:</p>

```c++
template <typename T> void f3(T&&);
f3(42); // argument is an rvalue of type int; template parameter T is int
```

<h5><a id="filepos4383510"></a>Reference Collapsing and Rvalue Reference Parameters</h5>
<p>Assuming <code>i</code> is an <code>int</code> object, we might think that a call such as <code>f3(i)</code> would be illegal. After all, <code>i</code> is an lvalue, and normally we cannot bind an rvalue reference to an lvalue. However, the language defines two exceptions to normal binding rules that allow this kind of usage. These exceptions are the foundation for how library facilities such as <code>move</code> operate.</p>
<p>The first exception affects how type deduction is done for rvalue reference parameters. When we pass an lvalue (e.g., <code>i</code>) to a function parameter that is an rvalue reference to a template type parameter (e.g, <code>T&amp;&amp;)</code>, the compiler deduces the template type parameter as the argument’s lvalue reference type. So, when we call <code>f3(i)</code>, the compiler deduces the type of <code>T</code> as <code>int&amp;</code>, not <code>int</code>.</p>
<p>Deducing <code>T</code> as <code>int&amp;</code> would seem to mean that <code>f3</code>’s function parameter would be an rvalue reference to the type <code>int&amp;</code>. Ordinarily, we cannot (directly) define a reference to a reference (§ <a href="023-2.3._compound_types.html#filepos396246">2.3.1</a>, p. <a href="023-2.3._compound_types.html#filepos396246">51</a>). However, it is possible to do so indirectly through a type alias (§ <a href="025-2.5._dealing_with_types.html#filepos536134">2.5.1</a>, p. <a href="025-2.5._dealing_with_types.html#filepos536134">67</a>) or through a template type parameter.</p>
<a id="filepos4385972"></a><Badge type="tip" text="C++11" />
<p>In such contexts, we see the second exception to the normal binding rules: If we indirectly create a reference to a reference, then those references “collapse.” In all but one case, the references collapse to form an ordinary lvalue reference type. The new standard, expanded the collapsing rules to include rvalue references. References collapse to form an rvalue reference only in the specific case of an rvalue reference to an rvalue reference. That is, for a given type <code>X</code>:</p>
<ul><li><code>X&amp; &amp;, X&amp; &amp;&amp;</code>, and <code>X&amp;&amp; &amp;</code> all collapse to type <code>X&amp;</code></li><li>The type <code>X&amp;&amp; &amp;&amp;</code> collapses to <code>X&amp;&amp;</code></li></ul>

::: info
<p>Reference collapsing applies only when a reference to a reference is created indirectly, such as in a type alias or a template parameter.</p>
:::

<p>The combination of the reference collapsing rule and the special rule for type deduction for rvalue reference parameters means that we can call <code>f3</code> on an lvalue. When we pass an lvalue to <code>f3</code>’s (rvalue reference) function parameter, the compiler will deduce <code>T</code> as an lvalue reference type:</p>

```c++
f3(i);  // argument is an lvalue; template parameter T is int&
f3(ci); // argument is an lvalue; template parameter T is const int&
```

<p>When a <em>template</em> parameter <code>T</code> is deduced as a reference type, the collapsing rule says that the <em>function</em> parameter <code>T&amp;&amp;</code> collapses to an lvalue reference type. For example, the resulting instantiation for <code>f3(i)</code> would be something like</p>

```c++
// invalid code, for illustration purposes only
void f3<int&>(int& &&); // when T is int&, function parameter is int& &&
```

<p>The function parameter in <code>f3</code> is <code>T&amp;&amp;</code> and <code>T</code> is <code>int&amp;</code>, so <code>T&amp;&amp;</code> is <code>int&amp; &amp;&amp;</code>, which collapses to <code>int&amp;</code>. Thus, even though the form of the function parameter in <code>f3</code> is an rvalue reference (i.e., <code>T&amp;&amp;)</code>, this call instantiates <code>f3</code> with an lvalue reference type (i.e., <code>int&amp;)</code>:</p>

```c++
void f3<int&>(int&); // when T is int&, function parameter collapses to int&
```

<p><a id="filepos4392563"></a>There are two important consequences from these rules:</p>
<ul><li>A function parameter that is an rvalue reference to a template type parameter (e.g., <code>T&amp;&amp;)</code> can be bound to an lvalue; and</li><li>If the argument is an lvalue, then the deduced template argument type will be an lvalue reference type and the function parameter will be instantiated as an (ordinary) lvalue reference parameter (<code>T&amp;</code>)</li></ul>

<p>It is also worth noting that by implication, we can pass any type of argument to a <code>T&amp;&amp;</code> function parameter. A parameter of such a type can (obviously) be used with rvalues, and as we’ve just seen, can be used by lvalues as well.</p>

::: info
<p>An argument of any type can be passed to a function parameter that is an rvalue reference to a template parameter type (i.e., <code>T&amp;&amp;)</code>. When an lvalue is passed to such a parameter, the function parameter is instantiated as an ordinary, lvalue reference (<code>T&amp;</code>).</p>
:::

<h5>Writing Template Functions with Rvalue Reference Parameters</h5>
<p>The fact that the template parameter can be deduced to a reference type can have surprising impacts on the code inside the template:</p>

```c++
template <typename T> void f3(T&& val)
{
    T t = val;  // copy or binding a reference?
    t = fcn(t); // does the assignment change only t or val and t?
    if (val == t) { /* ... */ } // always true if T is a reference type
}
```

<p>When we call <code>f3</code> on an rvalue, such as the literal 42, <code>T</code> is <code>int</code>. In this case, the local variable <code>t</code> has type <code>int</code> and is initialized by copying the value of the parameter <code>val</code>. When we assign to <code>t</code>, the parameter <code>val</code> remains unchanged.</p>
<p>On the other hand, when we call <code>f3</code> on the lvalue <code>i</code>, then <code>T</code> is <code>int&amp;</code>. When we define and initialize the local variable <code>t</code>, that variable has type <code>int&amp;</code>. The initialization of <code>t</code> binds <code>t</code> to <code>val</code>. When we assign to <code>t</code>, we change <code>val</code> at the same time. In this instantiation of <code>f3</code>, the <code>if</code> test will always yield <code>true</code>.</p>
<p>It is surprisingly hard to write code that is correct when the types involved might be plain (nonreference) types or reference types (although the type transformation classes such as <code>remove_reference</code> can help (§ <a href="155-16.2._template_argument_deduction.html#filepos4354202">16.2.3</a>, p. <a href="155-16.2._template_argument_deduction.html#filepos4354202">684</a>)).</p>
<p>In practice, rvalue reference parameters are used in one of two contexts: Either the template is forwarding its arguments, or the template is overloaded. We’ll look at forwarding in § <a href="155-16.2._template_argument_deduction.html#filepos4417678">16.2.7</a> (p. <a href="155-16.2._template_argument_deduction.html#filepos4417678">692</a>) and at template overloading in § <a href="156-16.3._overloading_and_templates.html#filepos4436613">16.3</a> (p. <a href="156-16.3._overloading_and_templates.html#filepos4436613">694</a>).</p>
<p>For now, it’s worth noting that function templates that use rvalue references often use overloading in the same way as we saw in § <a href="126-13.6._moving_objects.html#filepos3505762">13.6.3</a> (p. <a href="126-13.6._moving_objects.html#filepos3505762">544</a>):</p>

```c++
template <typename T> void f(T&&);      // binds to nonconst rvalues
template <typename T> void f(const T&); // lvalues and const rvalues
```

<p>As with nontemplate functions, the first version will bind to modifiable rvalues and the second to lvalues or to <code>const</code> rvalues.</p>

::: info
<a id="filepos4400661"></a><p>Exercises Section 16.2.5</p>
<p><strong>Exercise 16.42:</strong> Determine the type of <code>T</code> and of <code>val</code> in each of the following calls:</p>

```c++
template <typename T> void g(T&& val);
int i = 0; const int ci = i;
```

<p>(a) <code>g(i);</code></p>
<p>(b) <code>g(ci);</code></p>
<p>(c) <code>g(i * ci);</code></p>
<p><strong>Exercise 16.43:</strong> Using the function defined in the previous exercise, what would the template parameter of <code>g</code> be if we called <code>g(i = ci)?</code></p>
<p><strong>Exercise 16.44:</strong> Using the same three calls as in the first exercise, determine the types for <code>T</code> if <code>g</code>’s function parameter is declared as <code>T</code> (not <code>T&amp;&amp;)</code>. What if <code>g</code>’s function parameter is <code>const T&amp;?</code></p>
<p><strong>Exercise 16.45:</strong> Given the following template, explain what happens if we call <code>g</code> on a literal value such as 42. What if we call <code>g</code> on a variable of type <code>int</code>?</p>

```c++
template <typename T> void g(T&& val) { vector<T> v; }
```

:::

<h4 id="filepos4403933">16.2.6. Understanding <code>std::move</code></h4>
<Badge type="danger" text="Advanced" />
<p>The library <code>move</code> function (§ <a href="126-13.6._moving_objects.html#filepos3429349">13.6.1</a>, p. <a href="126-13.6._moving_objects.html#filepos3429349">533</a>) is a good illustration of a template that uses rvalue references. Fortunately, we can use <code>move</code> without understanding the template mechanisms that it uses. However, looking at how <code>move</code> works can help cement our general understanding, and use, of templates.</p>
<p>In § <a href="126-13.6._moving_objects.html#filepos3443291">13.6.2</a> (p. <a href="126-13.6._moving_objects.html#filepos3443291">534</a>) we noted that although we cannot directly bind an rvalue reference to an lvalue, we can use <code>move</code> to obtain an rvalue reference bound to an lvalue. Because <code>move</code> can take arguments of essentially any type, it should not be surprising that <code>move</code> is a function template.</p>
<h5>How <code>std::move</code> Is Defined</h5>
<p>The standard defines <code>move</code> as follows:</p>

```c++
// for the use of typename in the return type and the cast see § 16.1.3 (p. 670)
// remove_reference is covered in § 16.2.3 (p. 684)
template <typename T>
typename remove_reference<T>::type&& move(T&& t)
{
   // static_cast covered in § 4.11.3 (p. 163)
   return static_cast<typename remove_reference<T>::type&&>(t);
}
```

<p>This code is short but subtle. First, <code>move</code>’s function parameter, <code>T&amp;&amp;</code>, is an rvalue reference to a template parameter type. Through reference collapsing, this parameter can match arguments of any type. In particular, we can pass either an lvalue or an rvalue to <code>move</code>:</p>

```c++
string s1("hi!"), s2;
s2 = std::move(string("bye!")); // ok: moving from an rvalue
s2 = std::move(s1);  // ok: but after the assigment s1 has indeterminate value
```

<h5><a id="filepos4408477"></a>How <code>std::move</code> Works</h5>
<Badge type="warning" text="Tricky" />
<p>In the first assignment, the argument to <code>move</code> is the rvalue result of the <code>string</code> constructor, <code>string("bye")</code>. As we’ve seen, when we pass an rvalue to an rvalue reference function parameter, the type deduced from that argument is the referred-to type (§ <a href="155-16.2._template_argument_deduction.html#filepos4374182">16.2.5</a>, p. <a href="155-16.2._template_argument_deduction.html#filepos4374182">687</a>). Thus, in <code>std::move(string("bye!"))</code>:</p>
<ul><li>The deduced type of <code>T</code> is <code>string</code>.</li><li>Therefore, <code>remove_reference</code> is instantiated with <code>string</code>.</li><li>The <code>type</code> member of <code>remove_reference&lt;string&gt;</code> is <code>string</code>.</li><li>The return type of <code>move</code> is <code>string&amp;&amp;</code>.</li><li><code>move</code>’s function parameter, <code>t</code>, has type <code>string&amp;&amp;</code>.</li></ul>

<p>Accordingly, this call instantiates <code>move&lt;string&gt;</code>, which is the function</p>

```c++
string&& move(string &&t)
```

<p>The body of this function returns <code>static_cast&lt;string&amp;&amp;&gt;(t)</code>. The type of <code>t</code> is already <code>string&amp;&amp;</code>, so the cast does nothing. Therefore, the result of this call is the rvalue reference it was given.</p>
<p>Now consider the second assignment, which calls <code>std::move(s1)</code>. In this call, the argument to <code>move</code> is an lvalue. This time:</p>
<ul><li>The deduced type of <code>T</code> is <code>string&amp;</code> (reference to <code>string</code>, not plain <code>string</code>).</li><li>Therefore, <code>remove_reference</code> is instantiated with <code>string&amp;</code>.</li><li>The <code>type</code> member of <code>remove_reference&lt;string&amp;&gt;</code> is <code>string</code>,</li><li>The return type of <code>move</code> is still <code>string&amp;&amp;</code>.</li><li><code>move</code>’s function parameter, <code>t</code>, instantiates as <code>string&amp; &amp;&amp;</code>, which collapses to <code>string&amp;</code>.</li></ul>

<p>Thus, this call instantiates <code>move&lt;string&amp;&gt;</code>, which is</p>

```c++
string&& move(string &t)
```

<p>and which is exactly what we’re after—we want to bind an rvalue reference to an lvalue. The body of this instantiation returns <code>static_cast&lt;string&amp;&amp;&gt;(t)</code>. In this case, the type of <code>t</code> is <code>string&amp;</code>, which the cast converts to <code>string&amp;&amp;</code>.</p>
<h5><code>static_cast</code> from an Lvalue to an Rvalue Reference Is Permitted</h5>
<p>Ordinarily, a <code>static_cast</code> can perform only otherwise legitimate conversions (§ <a href="049-4.11._type_conversions.html#filepos1189032">4.11.3</a>, p. <a href="049-4.11._type_conversions.html#filepos1189032">163</a>). However, there is again a special dispensation for rvalue references: Even though we cannot implicitly convert an lvalue to an rvalue reference, we can <em>explicitly</em> cast an lvalue to an rvalue reference using <code>static_cast</code>.</p>
<a id="filepos4415674"></a><Badge type="tip" text="C++11" />
<p>Binding an rvalue reference to an lvalue gives code that operates on the rvalue reference permission to clobber the lvalue. There are times, such as in our <code>StrVec reallocate</code>
<a id="filepos4415999"></a>function in § <a href="126-13.6._moving_objects.html#filepos3429349">13.6.1</a> (p. <a href="126-13.6._moving_objects.html#filepos3429349">533</a>), when we know it is safe to clobber an lvalue. By <em>letting</em> us do the cast, the language allows this usage. By <em>forcing</em> us to use a cast, the language tries to prevent us from doing so accidentally.</p>
<p>Finally, although we can write such casts directly, it is much easier to use the library <code>move</code> function. Moreover, using <code>std::move</code> consistently makes it easy to find the places in our code that might potentially clobber lvalues.</p>

::: info
<p>Exercises Section 16.2.6</p>
<p><strong>Exercise 16.46:</strong> Explain this loop from <code>StrVec::reallocate</code> in § <a href="125-13.5._classes_that_manage_dynamic_memory.html#filepos3380687">13.5</a> (p. <a href="125-13.5._classes_that_manage_dynamic_memory.html#filepos3380687">530</a>):</p>

```c++
for (size_t i = 0; i != size(); ++i)
    alloc.construct(dest++, std::move(*elem++));
```

:::

<h4 id="filepos4417678">16.2.7. Forwarding</h4>
<Badge type="danger" text="Advanced" />
<p>Some functions need to forward one or more of their arguments with their types <em>unchanged</em> to another, forwarded-to, function. In such cases, we need to preserve everything about the forwarded arguments, including whether or not the argument type is <code>const</code>, and whether the argument is an lvalue or an rvalue.</p>
<p>As an example, we’ll write a function that takes a callable expression and two additional arguments. Our function will call the given callable with the other two arguments in reverse order. The following is a first cut at our flip function:</p>

```c++
// template that takes a callable and two parameters
// and calls the given callable with the parameters ''flipped''
// flip1 is an incomplete implementation: top-level const and references are lost
template <typename F, typename T1, typename T2>
void flip1(F f, T1 t1, T2 t2)
{
    f(t2, t1);
}
```

<p>This template works fine until we want to use it to call a function that has a reference parameter:</p>

```c++
void f(int v1, int &v2) // note v2 is a reference
{
    cout << v1 << " " << ++v2 << endl;
}
```

<p>Here <code>f</code> changes the value of the argument bound to <code>v2</code>. However, if we call <code>f</code> through <code>flip1</code>, the changes made by <code>f</code> do not affect the original argument:</p>

```c++
f(42, i);        // f changes its argument i
flip1(f, j, 42); // f called through flip1 leaves j unchanged
```

<p>The problem is that <code>j</code> is passed to the <code>t1</code> parameter in <code>flip1</code>. That parameter has is a plain, nonreference type, <code>int</code>, not an <code>int&amp;</code>. That is, the instantiation of this call to <code>flip1</code> is</p>
<p><a id="filepos4422623"></a></p>

```c++
void flip1(void(*fcn)(int, int&), int t1, int t2);
```

<p>The value of <code>j</code> is copied into <code>t1</code>. The reference parameter in <code>f</code> is bound to <code>t1</code>, not to <code>j</code>.</p>
<h5>Defining Function Parameters That Retain Type Information</h5>
<Badge type="warning" text="Tricky" />
<p>To pass a reference through our flip function, we need to rewrite our function so that its parameters preserve the “lvalueness” of its given arguments. Thinking ahead a bit, we can imagine that we’d also like to preserve the <code>const</code>ness of the arguments as well.</p>
<p>We can preserve all the type information in an argument by defining its corresponding function parameter as an rvalue reference to a template type parameter. Using a reference parameter (either lvalue or rvalue) lets us preserve <code>const</code>ness, because the <code>const</code> in a reference type is low-level. Through reference collapsing (§ <a href="155-16.2._template_argument_deduction.html#filepos4374182">16.2.5</a>, p. <a href="155-16.2._template_argument_deduction.html#filepos4374182">688</a>), if we define the function parameters as <code>T1&amp;&amp;</code> and <code>T2&amp;&amp;</code>, we can preserve the lvalue/rvalue property of flip’s arguments (§ <a href="155-16.2._template_argument_deduction.html#filepos4374182">16.2.5</a>, p. <a href="155-16.2._template_argument_deduction.html#filepos4374182">687</a>):</p>

```c++
template <typename F, typename T1, typename T2>
void flip2(F f, T1 &&t1, T2 &&t2)
{
    f(t2, t1);
}
```

<p>As in our earlier call, if we call <code>flip2(f, j, 42)</code>, the lvalue <code>j</code> is passed to the parameter <code>t1</code>. However, in <code>flip2</code>, the type deduced for <code>T1</code> is <code>int&amp;</code>, which means that the type of <code>t1</code> collapses to <code>int&amp;</code>. The reference <code>t1</code> is bound to <code>j</code>. When <code>flip2</code> calls <code>f</code>, the reference parameter <code>v2</code> in <code>f</code> is bound to <code>t1</code>, which in turn is bound to <code>j</code>. When <code>f</code> increments <code>v2</code>, it is changing the value of <code>j</code>.</p>

::: info
<p>A function parameter that is an rvalue reference to a template type parameter (i.e., <code>T&amp;&amp;</code>) preserves the <code>const</code>ness and lvalue/rvalue property of its corresponding argument.</p>
:::

<p>This version of <code>flip2</code> solves one half of our problem. Our <code>flip2</code> function works fine for functions that take lvalue references but cannot be used to call a function that has an rvalue reference parameter. For example:</p>

```c++
void g(int &&i, int& j)
{
    cout << i << " " << j << endl;
}
```

<p>If we try to call <code>g</code> through <code>flip2</code>, we will be passing the parameter <code>t2</code> to <code>g</code>’s rvalue reference parameter. Even if we pass an rvalue to <code>flip2</code>:</p>

```c++
flip2(g, i, 42); // error: can't initialize int&& from an lvalue
```

<p>what is passed to <code>g</code> will be the parameter named <code>t2</code> inside <code>flip2</code>. A function parameter, like any other variable, is an lvalue expression (§ <a href="126-13.6._moving_objects.html#filepos3429349">13.6.1</a>, p. <a href="126-13.6._moving_objects.html#filepos3429349">533</a>). As a result, the call to <code>g</code> in <code>flip2</code> passes an lvalue to <code>g</code>’s rvalue reference parameter.</p>
<h5><a id="filepos4430345"></a>Using <code>std::forward</code> to Preserve Type Information in a Call</h5>
<Badge type="warning" text="Tricky" />
<p>We can use a new library facility named <code>forward</code> to pass <code>flip2</code>’s parameters in a way that preserves the types of the original arguments. Like <code>move, forward</code> is defined in the <code>utility</code> header. Unlike <code>move, forward</code> must be called with an explicit template argument (§ <a href="155-16.2._template_argument_deduction.html#filepos4344365">16.2.2</a>, p. <a href="155-16.2._template_argument_deduction.html#filepos4344365">682</a>). <code>forward</code> returns an rvalue reference to that explicit argument type. That is, the return type of <code>forward&lt;T&gt;</code> is <code>T&amp;&amp;</code>.</p>
<a id="filepos4431692"></a><Badge type="tip" text="C++11" />
<p>Ordinarily, we use <code>forward</code> to pass a function parameter that is defined as an rvalue reference to a template type parameter. Through reference collapsing on its return type, <code>forward</code> preserves the lvalue/rvalue nature of its given argument:</p>

```c++
template <typename Type> intermediary(Type &&arg)
{
    finalFcn(std::forward<Type>(arg));
    // ...
}
```

<p>Here we use <code>Type</code>—which is deduced from <code>arg</code>—as <code>forward</code>’s explicit template argument type. Because <code>arg</code> is an rvalue reference to a template type parameter, <code>Type</code> will represent all the type information in the argument passed to <code>arg</code>. If that argument was an rvalue, then <code>Type</code> is an ordinary (nonreference) type and <code>forward&lt;Type&gt;</code> will return <code>Type&amp;&amp;</code>. If the argument was an lvalue, then—through reference collapsing—<code>Type</code> itself is an lvalue reference type. In this case, the return type is an rvalue reference to an lvalue reference type. Again through reference collapsing—this time on the return type—<code>forward&lt;Type&gt;</code> will return an lvalue reference type.</p>

::: info
<p>When used with a function parameter that is an rvalue reference to template type parameter (<code>T&amp;&amp;</code>), <code>forward</code> preserves all the details about an argument’s type.</p>
:::

<p>Using <code>forward</code>, we’ll rewrite our flip function once more:</p>

```c++
template <typename F, typename T1, typename T2>
void flip(F f, T1 &&t1, T2 &&t2)
{
    f(std::forward<T2>(t2), std::forward<T1>(t1));
}
```

<p>If we call <code>flip(g, i, 42), i</code> will be passed to <code>g</code> as an <code>int&amp;</code> and <code>42</code> will be passed as an <code>int&amp;&amp;</code>.</p>

::: info
<p>As with <code>std::move</code>, it’s a good idea not to provide a <code>using</code> declaration for <code>std::forward</code>. § <a href="172-18.2._namespaces.html#filepos4989992">18.2.3</a> (p. <a href="172-18.2._namespaces.html#filepos4989992">798</a>) will explain why.</p>
:::

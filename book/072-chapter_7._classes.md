<h2 id="filepos1741323">Chapter 7. Classes</h2>
<p>Contents</p><ul><li><strong><a href="073-7.1._defining_abstract_data_types.html#filepos1745423">Section 7.1 Defining Abstract Data Types</a></strong></li><li><strong><a href="074-7.2._access_control_and_encapsulation.html#filepos1833387">Section 7.2 Access Control and Encapsulation</a></strong></li><li><strong><a href="075-7.3._additional_class_features.html#filepos1851857">Section 7.3 Additional Class Features</a></strong></li><li><strong><a href="076-7.4._class_scope.html#filepos1923787">Section 7.4 Class Scope</a></strong></li><li><strong><a href="077-7.5._constructors_revisited.html#filepos1952599">Section 7.5 Constructors Revisited</a></strong></li><li><strong><a href="078-7.6._static_class_members.html#filepos2028441">Section 7.6 <code>static</code> Class Members</a></strong></li><li><strong><a href="079-chapter_summary.html#filepos2052488">Chapter Summary</a></strong></li><li><strong><a href="080-defined_terms.html#filepos2054441">Defined Terms</a></strong></li></ul>

<p>In C++ we use classes to define our own data types. By defining types that mirror concepts in the problems we are trying to solve, we can make our programs easier to write, debug, and modify.</p>
<p>This chapter continues the coverage of classes begun in <a href="020-chapter_2._variables_and_basic_types.html#filepos284544">Chapter 2</a>. Here we will focus on the importance of data abstraction, which lets us separate the implementation of an object from the operations that that object can perform. In <a href="120-chapter_13._copy_control.html#filepos3197881">Chapter 13</a> we’ll learn how to control what happens when objects are copied, moved, assigned, or destroyed. In <a href="129-chapter_14._overloaded_operations_and_conversions.html#filepos3544393">Chapter 14</a> we’ll learn how to define our own operators.</p>
<p><a id="filepos1743863"></a><em>The fundamental ideas</em> behind <strong><a href="080-defined_terms.html#filepos2055814" id="filepos1743917">classes</a></strong> are <strong><a href="080-defined_terms.html#filepos2059150" id="filepos1743990">data abstraction</a></strong> and <strong><a href="080-defined_terms.html#filepos2060188" id="filepos1744072">encapsulation</a></strong>. Data abstraction is a programming (and design) technique that relies on the separation of <strong><a href="080-defined_terms.html#filepos2062510" id="filepos1744238">interface</a></strong> and <strong><a href="080-defined_terms.html#filepos2061767" id="filepos1744313">implementation</a></strong>. The interface of a class consists of the operations that users of the class can execute. The implementation includes the class’ data members, the bodies of the functions that constitute the interface, and any functions needed to define the class that are not intended for general use.</p>
<p>Encapsulation enforces the separation of a class’ interface and implementation. A class that is encapsulated hides its implementation—users of the class can use the interface but have no access to the implementation.</p>
<p>A class that uses data abstraction and encapsulation defines an <strong><a href="080-defined_terms.html#filepos2054580" id="filepos1745102">abstract data type</a></strong>. In an abstract data type, the class designer worries about how the class is implemented. Programmers who use the class need not know how the type works. They can instead think <em>abstractly</em> about what the type does.</p>

<h3 id="filepos1745423">7.1. Defining Abstract Data Types</h3>
<p>The <code>Sales_item</code> class that we used in <a href="010-chapter_1._getting_started.html#filepos113276">Chapter 1</a> is an abstract data type. We use a <code>Sales_item</code> object by using its interface (i.e., the operations described in § <a href="015-1.5._introducing_classes.html#filepos222335">1.5.1</a> (p. <a href="015-1.5._introducing_classes.html#filepos222335">20</a>)). We have no access to the data members stored in a <code>Sales_item</code> object. Indeed, we don’t even know what data members that class has.</p>
<p>Our <code>Sales_data</code> class (§ <a href="026-2.6._defining_our_own_data_structures.html#filepos578460">2.6.1</a>, p. <a href="026-2.6._defining_our_own_data_structures.html#filepos578460">72</a>) is not an abstract data type. It lets users of the class access its data members and forces users to write their own operations. To make <code>Sales_data</code> an abstract type, we need to define operations for users of <code>Sales_data</code> to use. Once <code>Sales_data</code> defines its own operations, we can encapsulate (that is, hide) its data members.</p>
<h4 id="filepos1746914">7.1.1. Designing the <code>Sales_data</code> Class</h4>
<Badge type="info" text="Fundamental" />
<p>Ultimately, we want <code>Sales_data</code> to support the same set of operations as the <code>Sales_item</code> class. The <code>Sales_item</code> class had one <strong><a href="080-defined_terms.html#filepos2062846" id="filepos1747562">member function</a></strong> (§ <a href="015-1.5._introducing_classes.html#filepos237516">1.5.2</a>, p. <a href="015-1.5._introducing_classes.html#filepos237516">23</a>), named <code>isbn</code>, and supported the <code>+</code>, <code>=</code>, <code>+=, &lt;&lt;</code>, and <code>&gt;&gt;</code> operators.</p>
<p>We’ll learn how to define our own operators in <a href="129-chapter_14._overloaded_operations_and_conversions.html#filepos3544393">Chapter 14</a>. For now, we’ll define ordinary (named) functions for these operations. For reasons that we will explain in § <a href="130-14.1._basic_concepts.html#filepos3549336">14.1</a> (p. <a href="130-14.1._basic_concepts.html#filepos3549336">555</a>), the functions that do addition and IO will not be members of <code>Sales_data</code>. Instead, we’ll define those functions as ordinary functions. The function that handles compound assignment will be a member, and for reasons we’ll explain in § <a href="073-7.1._defining_abstract_data_types.html#filepos1827343">7.1.5</a> (p. <a href="073-7.1._defining_abstract_data_types.html#filepos1827343">267</a>), our class doesn’t need to define assignment.</p>
<p>Thus, the interface to <code>Sales_data</code> consists of the following operations:</p>
<ul><li>An <code>isbn</code> member function to return the object’s <small>ISBN</small></li><li>A <code>combine</code> member function to add one <code>Sales_data</code> object into another</li><li>A function named <code>add</code> to add two <code>Sales_data</code> objects</li><li>A <code>read</code> function to read data from an <code>istream</code> into a <code>Sales_data</code> object</li><li>A <code>print</code> function to print the value of a <code>Sales_data</code> object on an <code>ostream</code></li></ul>

::: info
<a id="filepos1750685"></a><p>Key Concept: Different Kinds of Programming Roles</p>
<p>Programmers tend to think about the people who will run their applications as <em>users.</em> Similarly a class designer designs and implements a class for <em>users</em> of that class. In this case, the user is a programmer, not the ultimate user of the application.</p>
<p>When we refer to a <em>user,</em> the context makes it clear which kind of user is meant. If we speak of <em>user code</em> or the <em>user</em> of the <code>Sales_data</code> class, we mean a programmer who is using a class. If we speak of the <em>user</em> of the bookstore application, we mean the manager of the store who is running the application.</p>
<p>C++ programmers tend to speak of <em>users</em> interchangeably as users of the application or users of a class.</p>
<p>In simple applications, the user of a class and the designer of the class might be one and the same person. Even in such cases, it is useful to keep the roles distinct. When we design the interface of a class, we should think about how easy it will be to use the class. When we use the class, we shouldn’t think about how the class works.</p>
<p>Authors of successful applications do a good job of understanding and implementing the needs of the application’s users. Similarly, good class designers pay close attention to the needs of the programmers who will use the class. A well-designed class has an interface that is intuitive and easy to use and has an implementation that is efficient enough for its intended use.</p>
:::

<h5>Using the Revised <code>Sales_data</code> Class</h5>
<p>Before we think about how to implement our class, let’s look at how we can use our interface functions. As one example, we can use these functions to write a version of the bookstore program from § <a href="016-1.6._the_bookstore_program.html#filepos244566">1.6</a> (p. <a href="016-1.6._the_bookstore_program.html#filepos244566">24</a>) that works with <code>Sales_data</code> objects rather than <code>Sales_item</code>s:</p>

```c++
Sales_data total;         // variable to hold the running sum
if (read(cin, total))  {  // read the first transaction
    Sales_data trans;     // variable to hold data for the next transaction
    while(read(cin, trans)) {      //  read the remaining transactions
        if (total.isbn() == trans.isbn())   // check the isbns
            total.combine(trans);  // update the running total
        else {
            print(cout, total) << endl;  // print the results
            total = trans;               // process the next book
        }
    }
    print(cout, total) << endl;          // print the last transaction
} else {                                 // there was no input
    cerr << "No data?!" << endl;         // notify the user
}
```

<p>We start by defining a <code>Sales_data</code> object to hold the running total. Inside the <code>if</code> condition, we call <code>read</code> to read the first transaction into <code>total</code>. This condition works like other loops we’ve written that used the <code>&gt;&gt;</code> operator. Like the <code>&gt;&gt;</code> operator, our <code>read</code> function will return its stream parameter, which the condition <a id="filepos1757625"></a>checks (§ <a href="049-4.11._type_conversions.html#filepos1178431">4.11.2</a>, p. <a href="049-4.11._type_conversions.html#filepos1178431">162</a>). If the <code>read</code> fails, we fall through to the <code>else</code> to print an error message.</p>
<p>If there are data to read, we define <code>trans</code>, which we’ll use to hold each transaction. The condition in the <code>while</code> also checks the stream returned by <code>read</code>. So long as the input operations in <code>read</code> succeed, the condition succeeds and we have another transaction to process.</p>
<p>Inside the <code>while</code>, we call the <code>isbn</code> members of <code>total</code> and <code>trans</code> to fetch their respective <small>ISBN</small>s. If <code>total</code> and <code>trans</code> refer to the same book, we call <code>combine</code> to add the components of <code>trans</code> into the running total in <code>total</code>. If <code>trans</code> represents a new book, we call <code>print</code> to print the total for the previous book. Because <code>print</code> returns a reference to its stream parameter, we can use the result of <code>print</code> as the left-hand operand of the <code>&lt;&lt;</code>. We do so to print a newline following the output generated by <code>print</code>. We next assign <code>trans</code> to <code>total</code>, thus setting up to process the records for the next book in the file.</p>
<p>After we have exhausted the input, we have to remember to print the data for the last transaction, which we do in the call to <code>print</code> following the <code>while</code> loop.</p>

::: info
<p>Exercises Section 7.1.1</p>
<p><strong>Exercise 7.1:</strong> Write a version of the transaction-processing program from § <a href="016-1.6._the_bookstore_program.html#filepos244566">1.6</a> (p. <a href="016-1.6._the_bookstore_program.html#filepos244566">24</a>) using the <code>Sales_data</code> class you defined for the exercises in § <a href="026-2.6._defining_our_own_data_structures.html#filepos578460">2.6.1</a> (p. <a href="026-2.6._defining_our_own_data_structures.html#filepos578460">72</a>).</p>
:::

<h4 id="filepos1761316">7.1.2. Defining the Revised <code>Sales_data</code> Class</h4>
<Badge type="info" text="Fundamental" />
<p>Our revised class will have the same data members as the version we defined in § <a href="026-2.6._defining_our_own_data_structures.html#filepos578460">2.6.1</a> (p. <a href="026-2.6._defining_our_own_data_structures.html#filepos578460">72</a>): <code>bookNo</code>, a <code>string</code> representing the <small>ISBN</small>; <code>units_sold</code>, an <code>unsigned</code> that says how many copies of the book were sold; and <code>revenue</code>, a <code>double</code> representing the total revenue for those sales.</p>
<p>As we’ve seen, our class will also have two member functions, <code>combine</code> and <code>isbn</code>. In addition, we’ll give <code>Sales_data</code> another member function to return the average price at which the books were sold. This function, which we’ll name <code>avg_price</code>, isn’t intended for general use. It will be part of the implementation, not part of the interface.</p>
<p>We define (§ <a href="063-6.1._function_basics.html#filepos1415571">6.1</a>, p. <a href="063-6.1._function_basics.html#filepos1415571">202</a>) and declare (§ <a href="063-6.1._function_basics.html#filepos1441405">6.1.2</a>, p. <a href="063-6.1._function_basics.html#filepos1441405">206</a>) member functions similarly to ordinary functions. Member functions <em>must</em> be declared inside the class. Member functions <em>may</em> be defined inside the class itself or outside the class body. Nonmember functions that are part of the interface, such as <code>add</code>, <code>read</code>, and <code>print</code>, are declared and defined outside the class.</p>
<p>With this knowledge, we’re ready to write our revised version of <code>Sales_data</code>:</p>

```c++
struct Sales_data {
    // new members: operations on Sales_data objects
    std::string isbn() const { return bookNo; }
    Sales_data& combine(const Sales_data&);
    double avg_price() const;
    // data members are unchanged from § 2.6.1 (p. 72)
    std::string bookNo;
    unsigned units_sold = 0;
    double revenue = 0.0;
};
// nonmember Sales_data interface functions
Sales_data add(const Sales_data&, const Sales_data&);
std::ostream &print(std::ostream&, const Sales_data&);
std::istream &read(std::istream&, Sales_data&);
```

::: info
<p>Functions defined in the class are implicitly <code>inline</code> (§ <a href="067-6.5._features_for_specialized_uses.html#filepos1645920">6.5.2</a>, p. <a href="067-6.5._features_for_specialized_uses.html#filepos1645920">238</a>).</p>
:::

<h5><a id="filepos1766208"></a>Defining Member Functions</h5>
<p>Although every member must be declared inside its class, we can define a member function’s body either inside or outside of the class body. In <code>Sales_data, isbn</code> is defined inside the class; <code>combine</code> and <code>avg_price</code> will be defined elsewhere.</p>
<p>We’ll start by explaining the <code>isbn</code> function, which returns a <code>string</code> and has an empty parameter list:</p>

```c++
std::string isbn() const { return bookNo; }
```

<p>As with any function, the body of a member function is a block. In this case, the block contains a single <code>return</code> statement that returns the <code>bookNo</code> data member of a <code>Sales_data</code> object. The interesting thing about this function is how it gets the object from which to fetch the <code>bookNo</code> member.</p>
<h5>Introducing <code>this</code></h5>
<Badge type="warning" text="Tricky" />
<p>Let’s look again at a call to the <code>isbn</code> member function:</p>

```c++
total.isbn()
```

<p>Here we use the dot operator (§ <a href="044-4.6._the_member_access_operators.html#filepos1101794">4.6</a>, p. <a href="044-4.6._the_member_access_operators.html#filepos1101794">150</a>) to fetch the <code>isbn</code> member of the object named <code>total</code>, which we then call.</p>
<p>With one exception that we’ll cover in § <a href="078-7.6._static_class_members.html#filepos2028441">7.6</a> (p. <a href="078-7.6._static_class_members.html#filepos2028441">300</a>), when we call a member function we do so on behalf of an object. When <code>isbn</code> refers to members of <code>Sales_data</code> (e.g., <code>bookNo</code>), it is referring implicitly to the members of the object on which the function was called. In this call, when <code>isbn</code> returns <code>bookNo</code>, it is implicitly returning <code>total.bookNo</code>.</p>
<p>Member functions access the object on which they were called through an extra, implicit parameter named <code>this</code>. When we call a member function, <code>this</code> is initialized with the address of the object on which the function was invoked. For example, when we call</p>

```c++
total.isbn()
```

<p>the compiler passes the address of <code>total</code> to the implicit <code>this</code> parameter in <code>isbn</code>. It is as if the compiler rewrites this call as</p>
<p><a id="filepos1770956"></a></p>

```c++
// pseudo-code illustration of how a call to a member function is translated
Sales_data::isbn(&total)
```

<p>which calls the <code>isbn</code> member of <code>Sales_data</code> passing the address of <code>total</code>.</p>
<p>Inside a member function, we can refer directly to the members of the object on which the function was called. We do not have to use a member access operator to use the members of the object to which <code>this</code> points. Any direct use of a member of the class is assumed to be an implicit reference through <code>this</code>. That is, when <code>isbn</code> uses <code>bookNo</code>, it is implicitly using the member to which <code>this</code> points. It is as if we had written <code>this-&gt;bookNo</code>.</p>
<p>The <code>this</code> parameter is defined for us implicitly. Indeed, it is illegal for us to define a parameter or variable named <code>this</code>. Inside the body of a member function, we can use <code>this</code>. It would be legal, although unnecessary, to define <code>isbn</code> as</p>

```c++
std::string isbn() const { return this->bookNo; }
```

<p>Because <code>this</code> is intended to always refer to “this” object, <code>this</code> is a <code>const</code> pointer (§ <a href="024-2.4._const_qualifier.html#filepos491891">2.4.2</a>, p. <a href="024-2.4._const_qualifier.html#filepos491891">62</a>). We cannot change the address that <code>this</code> holds.</p>
<h5>Introducing <code>const</code> Member Functions</h5>
<p>The other important part about the <code>isbn</code> function is the keyword <code>const</code> that follows the parameter list. The purpose of that <code>const</code> is to modify the type of the implicit <code>this</code> pointer.</p>
<p>By default, the type of <code>this</code> is a <code>const</code> pointer to the non<code>const</code> version of the class type. For example, by default, the type of <code>this</code> in a <code>Sales_data</code> member function is <code>Sales_data *const</code>. Although <code>this</code> is implicit, it follows the normal initialization rules, which means that (by default) we cannot bind <code>this</code> to a <code>const</code> object (§ <a href="024-2.4._const_qualifier.html#filepos491891">2.4.2</a>, p. <a href="024-2.4._const_qualifier.html#filepos491891">62</a>). This fact, in turn, means that we cannot call an ordinary member function on a <code>const</code> object.</p>
<p>If <code>isbn</code> were an ordinary function and if <code>this</code> were an ordinary pointer parameter, we would declare <code>this</code> as <code>const Sales_data *const</code>. After all, the body of <code>isbn</code> doesn’t change the object to which <code>this</code> points, so our function would be more flexible if <code>this</code> were a pointer to <code>const</code> (§ <a href="064-6.2._argument_passing.html#filepos1479382">6.2.3</a>, p. <a href="064-6.2._argument_passing.html#filepos1479382">213</a>).</p>
<p>However, <code>this</code> is implicit and does not appear in the parameter list. There is no place to indicate that <code>this</code> should be a pointer to <code>const</code>. The language resolves this problem by letting us put <code>const</code> after the parameter list of a member function. A <code>const</code> following the parameter list indicates that <code>this</code> is a pointer to <code>const</code>. Member functions that use <code>const</code> in this way are <a href="080-defined_terms.html#filepos2057171" id="filepos1777780"><code>const</code>
<strong>member functions</strong></a>.</p>
<p>We can think of the body of <code>isbn</code> as if it were written as</p>

```c++
// pseudo-code illustration of how the implicit this pointer is used
// this code is illegal: we may not explicitly define the this pointer ourselves
// note that this is a pointer to const because isbn is a const member
std::string Sales_data::isbn(const Sales_data *const this)
{ return this->isbn; }
```

<p>The fact that <code>this</code> is a pointer to <code>const</code> means that <code>const</code> member functions cannot change the object on which they are called. Thus, <code>isbn</code> may read but not write to the data members of the objects on which it is called.</p>

::: info
<a id="filepos1780381"></a>
<p>Objects that are <code>const</code>, and references or pointers to <code>const</code> objects, may call only <code>const</code> member functions.</p>
:::

<h5>Class Scope and Member Functions</h5>
<p>Recall that a class is itself a scope (§ <a href="026-2.6._defining_our_own_data_structures.html#filepos578460">2.6.1</a>, p. <a href="026-2.6._defining_our_own_data_structures.html#filepos578460">72</a>). The definitions of the member functions of a class are nested inside the scope of the class itself. Hence, <code>isbn</code>’s use of the name <code>bookNo</code> is resolved as the data member defined inside <code>Sales_data</code>.</p>
<p>It is worth noting that <code>isbn</code> can use <code>bookNo</code> even though <code>bookNo</code> is defined <em>after</em>
<code>isbn</code>. As we’ll see in § <a href="076-7.4._class_scope.html#filepos1931587">7.4.1</a> (p. <a href="076-7.4._class_scope.html#filepos1931587">283</a>), the compiler processes classes in two steps—the member declarations are compiled first, after which the member function bodies, if any, are processed. Thus, member function bodies may use other members of their class regardless of where in the class those members appear.</p>
<h5>Defining a Member Function outside the Class</h5>
<p>As with any other function, when we define a member function outside the class body, the member’s definition must match its declaration. That is, the return type, parameter list, and name must match the declaration in the class body. If the member was declared as a <code>const</code> member function, then the definition must also specify <code>const</code> after the parameter list. The name of a member defined outside the class must include the name of the class of which it is a member:</p>

```c++
double Sales_data::avg_price() const {
    if (units_sold)
        return revenue/units_sold;
    else
        return 0;
}
```

<p>The function name, <code>Sales_data::avg_price</code>, uses the scope operator (§ <a href="012-1.2._a_first_look_at_inputoutput.html#filepos136281">1.2</a>, p. <a href="012-1.2._a_first_look_at_inputoutput.html#filepos136281">8</a>) to say that we are defining the function named <code>avg_price</code> that is declared in the scope of the <code>Sales_data</code> class. Once the compiler sees the function name, the rest of the code is interpreted as being inside the scope of the class. Thus, when <code>avg_price</code> refers to <code>revenue</code> and <code>units_sold</code>, it is implicitly referring to the members of <code>Sales_data</code>.</p>
<h5>Defining a Function to Return “This” Object</h5>
<p>The <code>combine</code> function is intended to act like the compound assignment operator, <code>+=</code>. The object on which this function is called represents the left-hand operand of the assignment. The right-hand operand is passed as an explicit argument:</p>

```c++
Sales_data& Sales_data::combine(const Sales_data &rhs)
{
    units_sold += rhs.units_sold; // add the members of rhs into
    revenue += rhs.revenue;       // the members of ''this'' object
    return *this; // return the object on which the function was called
}
```

<p><a id="filepos1786297"></a>When our transaction-processing program calls</p>

```c++
total.combine(trans); // update the running total
```

<p>the address of <code>total</code> is bound to the implicit <code>this</code> parameter and <code>rhs</code> is bound to <code>trans</code>. Thus, when <code>combine</code> executes</p>

```c++
units_sold += rhs.units_sold; // add the members of rhs into
```

<p>the effect is to add <code>total.units_sold</code> and <code>trans.units_sold</code>, storing the result back into <code>total.units_sold</code>.</p>
<p>The interesting part about this function is its return type and the <code>return</code> statement. Ordinarily, when we define a function that operates like a built-in operator, our function should mimic the behavior of that operator. The built-in assignment operators return their left-hand operand as an lvalue (§ <a href="042-4.4._assignment_operators.html#filepos1066463">4.4</a>, p. <a href="042-4.4._assignment_operators.html#filepos1066463">144</a>). To return an lvalue, our <code>combine</code> function must return a reference (§ <a href="065-6.3._return_types_and_the_return_statement.html#filepos1552941">6.3.2</a>, p. <a href="065-6.3._return_types_and_the_return_statement.html#filepos1552941">226</a>). Because the left-hand operand is a <code>Sales_data</code> object, the return type is <code>Sales_data&amp;</code>.</p>
<p>As we’ve seen, we do not need to use the implicit <code>this</code> pointer to access the members of the object on which a member function is executing. However, we do need to use <code>this</code> to access the object as a whole:</p>

```c++
return *this; // return the object on which the function was called
```

<p>Here the <code>return</code> statement dereferences <code>this</code> to obtain the object on which the function is executing. That is, for the call above, we return a reference to <code>total</code>.</p>

::: info
<p>Exercises Section 7.1.2</p>
<p><strong>Exercise 7.2:</strong> Add the <code>combine</code> and <code>isbn</code> members to the <code>Sales_data</code> class you wrote for the exercises in § <a href="026-2.6._defining_our_own_data_structures.html#filepos586875">2.6.2</a> (p. <a href="026-2.6._defining_our_own_data_structures.html#filepos586875">76</a>).</p>
<p><strong>Exercise 7.3:</strong> Revise your transaction-processing program from § <a href="073-7.1._defining_abstract_data_types.html#filepos1746914">7.1.1</a> (p. <a href="073-7.1._defining_abstract_data_types.html#filepos1746914">256</a>) to use these members.</p>
<p><strong>Exercise 7.4:</strong> Write a class named <code>Person</code> that represents the name and address of a person. Use a <code>string</code> to hold each of these elements. Subsequent exercises will incrementally add features to this class.</p>
<p><strong>Exercise 7.5:</strong> Provide operations in your <code>Person</code> class to return the name and address. Should these functions be <code>const</code>? Explain your choice.</p>
:::

<h4 id="filepos1792181">7.1.3. Defining Nonmember Class-Related Functions</h4>
<Badge type="info" text="Fundamental" />
<p>Class authors often define auxiliary functions, such as our <code>add</code>, <code>read</code>, and <code>print</code> functions. Although such functions define operations that are conceptually part of the interface of the class, they are not part of the class itself.</p>
<p>We define nonmember functions as we would any other function. As with any other function, we normally separate the declaration of the function from its <a id="filepos1793028"></a>definition (§ <a href="063-6.1._function_basics.html#filepos1441405">6.1.2</a>, p. <a href="063-6.1._function_basics.html#filepos1441405">206</a>). Functions that are conceptually part of a class, but not defined inside the class, are typically declared (but not defined) in the same header as the class itself. That way users need to include only one file to use any part of the interface.</p>

::: info
<p>Ordinarily, nonmember functions that are part of the interface of a class should be declared in the same header as the class itself.</p>
:::

<h5>Defining the <code>read</code> and <code>print</code> Functions</h5>
<p>The <code>read</code> and <code>print</code> functions do the same job as the code in § <a href="026-2.6._defining_our_own_data_structures.html#filepos586875">2.6.2</a> (p. <a href="026-2.6._defining_our_own_data_structures.html#filepos586875">75</a>) and not surprisingly, the bodies of our functions look a lot like the code presented there:</p>

```c++
// input transactions contain ISBN, number of copies sold, and sales price
istream &read(istream &is, Sales_data &item)
{
    double price = 0;
    is >> item.bookNo >> item.units_sold >> price;
    item.revenue = price * item.units_sold;
    return is;
}
ostream &print(ostream &os, const Sales_data &item)
{
    os << item.isbn() << " " << item.units_sold << " "
       << item.revenue << " " << item.avg_price();
    return os;
}
```

<p>The <code>read</code> function reads data from the given stream into the given object. The <code>print</code> function prints the contents of the given object on the given stream.</p>
<p>However, there are two points worth noting about these functions. First, both <code>read</code> and <code>write</code> take a reference to their respective IO class types. The IO classes are types that cannot be copied, so we may only pass them by reference (§ <a href="064-6.2._argument_passing.html#filepos1462468">6.2.2</a>, p. <a href="064-6.2._argument_passing.html#filepos1462468">210</a>). Moreover, reading or writing to a stream changes that stream, so both functions take ordinary references, not references to <code>const</code>.</p>
<p>The second thing to note is that <code>print</code> does not print a newline. Ordinarily, functions that do output should do minimal formatting. That way user code can decide whether the newline is needed.</p>
<h5>Defining the <code>add</code> Function</h5>
<p>The <code>add</code> function takes two <code>Sales_data</code> objects and returns a new <code>Sales_data</code> representing their sum:</p>

```c++
Sales_data add(const Sales_data &lhs, const Sales_data &rhs)
{
    Sales_data sum = lhs;  // copy data members from lhs into sum
    sum.combine(rhs);      // add data members from rhs into sum
    return sum;
}
```

<p><a id="filepos1798940"></a>In the body of the function we define a new <code>Sales_data</code> object named <code>sum</code> to hold the sum of our two transactions. We initialize <code>sum</code> as a copy of <code>lhs</code>. By default, copying a class object copies that object’s members. After the copy, the <code>bookNo, units_sold</code>, and <code>revenue</code> members of <code>sum</code> will have the same values as those in <code>lhs</code>. Next we call <code>combine</code> to add the <code>units_sold</code> and <code>revenue</code> members of <code>rhs</code> into <code>sum</code>. When we’re done, we return a copy of <code>sum</code>.</p>

::: info
<p>Exercises Section 7.1.3</p>
<p><strong>Exercise 7.6:</strong> Define your own versions of the <code>add</code>, <code>read</code>, and <code>print</code> functions.</p>
<p><strong>Exercise 7.7:</strong> Rewrite the transaction-processing program you wrote for the exercises in § <a href="073-7.1._defining_abstract_data_types.html#filepos1761316">7.1.2</a> (p. <a href="073-7.1._defining_abstract_data_types.html#filepos1761316">260</a>) to use these new functions.</p>
<p><strong>Exercise 7.8:</strong> Why does <code>read</code> define its <code>Sales_data</code> parameter as a plain reference and <code>print</code> define its parameter as a reference to <code>const</code>?</p>
<p><strong>Exercise 7.9:</strong> Add operations to read and print <code>Person</code> objects to the code you wrote for the exercises in § <a href="073-7.1._defining_abstract_data_types.html#filepos1761316">7.1.2</a> (p. <a href="073-7.1._defining_abstract_data_types.html#filepos1761316">260</a>).</p>
<p><strong>Exercise 7.10:</strong> What does the condition in the following <code>if</code> statement do?</p>

```c++
if (read(read(cin, data1), data2))
```

:::

<h4 id="filepos1802479">7.1.4. Constructors</h4>
<Badge type="info" text="Fundamental" />
<p>Each class defines how objects of its type can be initialized. Classes control object initialization by defining one or more special member functions known as <strong><a href="080-defined_terms.html#filepos2057980" id="filepos1802827">constructors</a></strong>. The job of a constructor is to initialize the data members of a class object. A constructor is run whenever an object of a class type is created.</p>
<p>In this section, we’ll introduce the basics of how to define a constructor. Constructors are a surprisingly complex topic. Indeed, we’ll have more to say about constructors in § <a href="077-7.5._constructors_revisited.html#filepos1952599">7.5</a> (p. <a href="077-7.5._constructors_revisited.html#filepos1952599">288</a>), § <a href="148-15.7._constructors_and_copy_control.html#filepos3973987">15.7</a> (p. <a href="148-15.7._constructors_and_copy_control.html#filepos3973987">622</a>), and § <a href="171-18.1._exception_handling.html#filepos4887288">18.1.3</a> (p. <a href="171-18.1._exception_handling.html#filepos4887288">777</a>), and in <a href="120-chapter_13._copy_control.html#filepos3197881">Chapter 13</a>.</p>
<p>Constructors have the same name as the class. Unlike other functions, constructors have no return type. Like other functions, constructors have a (possibly empty) parameter list and a (possibly empty) function body. A class can have multiple constructors. Like any other overloaded function (§ <a href="066-6.4._overloaded_functions.html#filepos1597234">6.4</a>, p. <a href="066-6.4._overloaded_functions.html#filepos1597234">230</a>), the constructors must differ from each other in the number or types of their parameters.</p>
<p>Unlike other member functions, constructors may not be declared as <code>const</code> (§ <a href="073-7.1._defining_abstract_data_types.html#filepos1761316">7.1.2</a>, p. <a href="073-7.1._defining_abstract_data_types.html#filepos1761316">258</a>). When we create a <code>const</code> object of a class type, the object does not assume its “<code>const</code>ness” until after the constructor completes the object’s initialization. Thus, constructors can write to <code>const</code> objects during their construction.</p>
<h5>The Synthesized Default Constructor</h5>
<Badge type="warning" text="Tricky" />
<p>Our <code>Sales_data</code> class does not define any constructors, yet the programs we’ve written that use <code>Sales_data</code> objects compile and run correctly. As an example, the program on page <a href="073-7.1._defining_abstract_data_types.html#filepos1750685">255</a> defined two objects:</p>
<p><a id="filepos1805469"></a></p>

```c++
Sales_data total;     // variable to hold the running sum
Sales_data trans;     // variable to hold data for the next transaction
```

<p>The question naturally arises: How are <code>total</code> and <code>trans</code> initialized?</p>
<p>We did not supply an initializer for these objects, so we know that they are default initialized (§ <a href="022-2.2._variables.html#filepos350704">2.2.1</a>, p. <a href="022-2.2._variables.html#filepos350704">43</a>). Classes control default initialization by defining a special constructor, known as the <strong><a href="080-defined_terms.html#filepos2059620" id="filepos1806598">default constructor</a></strong>. The default constructor is one that takes no arguments.</p>
<p>As we’ll, see the default constructor is special in various ways, one of which is that if our class does not <em>explicitly</em> define any constructors, the compiler will <em>implicitly</em> define the default constructor for us</p>
<p>The compiler-generated constructor is known as the <strong><a href="080-defined_terms.html#filepos2065640" id="filepos1807151">synthesized default constructor</a></strong>. For most classes, this synthesized constructor initializes each data member of the class as follows:</p>
<ul><li>If there is an in-class initializer (§ <a href="026-2.6._defining_our_own_data_structures.html#filepos578460">2.6.1</a>, p. <a href="026-2.6._defining_our_own_data_structures.html#filepos578460">73</a>), use it to initialize the member.</li><li>Otherwise, default-initialize (§ <a href="022-2.2._variables.html#filepos350704">2.2.1</a>, p. <a href="022-2.2._variables.html#filepos350704">43</a>) the member.</li></ul>

<p>Because <code>Sales_data</code> provides initializers for <code>units_sold</code> and <code>revenue</code>, the synthesized default constructor uses those values to initialize those members. It default initializes <code>bookNo</code> to the empty string.</p>
<h5>Some Classes Cannot Rely on the Synthesized Default Constructor</h5>
<p>Only fairly simple classes—such as the current definition of <code>Sales_data</code>—can rely on the synthesized default constructor. The most common reason that a class must define its own default constructor is that the compiler generates the default for us <em>only if we do not define any other constructors for the class.</em> If we define any constructors, the class will not have a default constructor unless we define that constructor ourselves. The basis for this rule is that if a class requires control to initialize an object in one case, then the class is likely to require control in all cases.</p>

::: info
<p>The compiler generates a default constructor automatically only if a class declares <em>no</em> constructors.</p>
:::

<p>A second reason to define the default constructor is that for some classes, the synthesized default constructor does the wrong thing. Remember that objects of built-in or compound type (such as arrays and pointers) that are defined inside a block have undefined value when they are default initialized (§ <a href="022-2.2._variables.html#filepos350704">2.2.1</a>, p. <a href="022-2.2._variables.html#filepos350704">43</a>). The same rule applies to members of built-in type that are default initialized. Therefore, classes that have members of built-in or compound type should ordinarily either initialize those members inside the class or define their own version of the default constructor. Otherwise, users could create objects with members that have undefined value.</p>

::: warning
<p>Classes that have members of built-in or compound type usually should rely on the synthesized default constructor <em>only</em> if all such members have in-class initializers.</p>
:::

<p><a id="filepos1810987"></a>A third reason that some classes must define their own default constructor is that sometimes the compiler is unable to synthesize one. For example, if a class has a member that has a class type, and that class doesn’t have a default constructor, then the compiler can’t initialize that member. For such classes, we must define our own version of the default constructor. Otherwise, the class will not have a usable default constructor. We’ll see in § <a href="121-13.1._copy_assign_and_destroy.html#filepos3263004">13.1.6</a> (p. <a href="121-13.1._copy_assign_and_destroy.html#filepos3263004">508</a>) additional circumstances that prevent the compiler from generating an appropriate default constructor.</p>
<h5>Defining the <code>Sales_data</code> Constructors</h5>
<p>For our <code>Sales_data</code> class we’ll define four constructors with the following parameters:</p>
<ul><li>An <code>istream&amp;</code> from which to read a transaction.</li><li>A <code>const string&amp;</code> representing an <small>ISBN</small>, an <code>unsigned</code> representing the count of how many books were sold, and a <code>double</code> representing the price at which the books sold.</li><li>A <code>const string&amp;</code> representing an <small>ISBN</small>. This constructor will use default values for the other members.</li><li>An empty parameter list (i.e., the default constructor) which as we’ve just seen we must define because we have defined other constructors.</li></ul>

<p>Adding these members to our class, we now have</p>

```c++
struct Sales_data {
    // constructors added
    Sales_data() = default;
    Sales_data(const std::string &s): bookNo(s) { }
    Sales_data(const std::string &s, unsigned n, double p):
               bookNo(s), units_sold(n), revenue(p*n) { }
    Sales_data(std::istream &);
    // other members as before
    std::string isbn() const { return bookNo; }
    Sales_data& combine(const Sales_data&);
    double avg_price() const;
    std::string bookNo;
    unsigned units_sold = 0;
    double revenue = 0.0;
};
```

<h5>What <code>= default</code> Means</h5>
<p>We’ll start by explaining the default constructor:</p>

```c++
Sales_data() = default;
```

<p>First, note that this constructor defines the default constructor because it takes no arguments. We are defining this constructor <em>only</em> because we want to provide other constructors as well as the default constructor. We want this constructor to do exactly the same work as the synthesized version we had been using.</p>
<p><a id="filepos1815669"></a>Under the new standard, if we want the default behavior, we can ask the compiler to generate the constructor for us by writing <code>= default</code> after the parameter list. The <code>= default</code> can appear with the declaration inside the class body or on the definition outside the class body. Like any other function, if the <code>= default</code> appears inside the class body, the default constructor will be inlined; if it appears on the definition outside the class, the member will not be inlined by default.</p>
<a id="filepos1816504"></a><Badge type="tip" text="C++11" />

::: warning
<p>The default constructor works for <code>Sales_data</code> only because we provide initializers for the data members with built-in type. If your compiler does not support in-class initializers, your default constructor should use the constructor initializer list (described immediately following) to initialize every member of the class.</p>
:::

<h5>Constructor Initializer List</h5>
<p>Next we’ll look at the other two constructors that were defined inside the class:</p>

```c++
Sales_data(const std::string &s): bookNo(s) { }
Sales_data(const std::string &s, unsigned n, double p):
           bookNo(s), units_sold(n), revenue(p*n) { }
```

<p>The new parts in these definitions are the colon and the code between it and the curly braces that define the (empty) function bodies. This new part is a <strong><a href="080-defined_terms.html#filepos2058283" id="filepos1818233">constructor initializer list</a></strong>, which specifies initial values for one or more data members of the object being created. The constructor initializer is a list of member names, each of which is followed by that member’s initial value in parentheses (or inside curly braces). Multiple member initializations are separated by commas.</p>
<p>The constructor that has three parameters uses its first two parameters to initialize the <code>bookNo</code> and <code>units_sold</code> members. The initializer for <code>revenue</code> is calculated by multiplying the number of books sold by the price per book.</p>
<p>The constructor that has a single <code>string</code> parameter uses that <code>string</code> to initialize <code>bookNo</code> but does not explicitly initialize the <code>units_sold</code> and <code>revenue</code> members. When a member is omitted from the constructor initializer list, it is implicitly initialized using the same process as is used by the synthesized default constructor. In this case, those members are initialized by the in-class initializers. Thus, the constructor that takes a <code>string</code> is equivalent to</p>

```c++
// has the same behavior as the original constructor defined above
Sales_data(const std::string &s):
           bookNo(s), units_sold(0), revenue(0){ }
```

<p>It is usually best for a constructor to use an in-class initializer if one exists and gives the member the correct value. On the other hand, if your compiler does not yet support in-class initializers, then every constructor should explicitly initialize every member of built-in type.</p>

::: tip
<p>Best Practices</p>
<p>Constructors should not override in-class initializers except to use a different initial value. If you can’t use in-class initializers, each constructor should explicitly initialize every member of built-in type.</p>
:::

<p><a id="filepos1821542"></a>It is worth noting that both constructors have empty function bodies. The only work these constructors need to do is give the data members their values. If there is no further work, then the function body is empty.</p>
<h5>Defining a Constructor outside the Class Body</h5>
<p>Unlike our other constructors, the constructor that takes an <code>istream</code> does have work to do. Inside its function body, this constructor calls <code>read</code> to give the data members new values:</p>

```c++
Sales_data::Sales_data(std::istream &is)
{
    read(is, *this); // read will read a transaction from is into this object
}
```

<p>Constructors have no return type, so this definition starts with the name of the function we are defining. As with any other member function, when we define a constructor outside of the class body, we must specify the class of which the constructor is a member. Thus, <code>Sales_data::Sales_data</code> says that we’re defining the <code>Sales_data</code> member named <code>Sales_data</code>. This member is a constructor because it has the same name as its class.</p>
<p>In this constructor there is no constructor initializer list, although technically speaking, it would be more correct to say that the constructor initializer list is empty. Even though the constructor initializer list is empty, the members of this object are still initialized before the constructor body is executed.</p>
<p>Members that do not appear in the constructor initializer list are initialized by the corresponding in-class initializer (if there is one) or are default initialized. For <code>Sales_data</code> that means that when the function body starts executing, <code>bookNo</code> will be the empty <code>string</code>, and <code>units_sold</code> and <code>revenue</code> will both be <code>0</code>.</p>
<p>To understand the call to <code>read</code>, remember that <code>read</code>’s second parameter is a reference to a <code>Sales_data</code> object. In § <a href="073-7.1._defining_abstract_data_types.html#filepos1761316">7.1.2</a> (p. <a href="073-7.1._defining_abstract_data_types.html#filepos1761316">259</a>), we noted that we use <code>this</code> to access the object as a whole, rather than a member of the object. In this case, we use <code>*this</code> to pass “this” object as an argument to the <code>read</code> function.</p>

::: info
<p>Exercises Section 7.1.4</p>
<p><strong>Exercise 7.11:</strong> Add constructors to your <code>Sales_data</code> class and write a program to use each of the constructors.</p>
<p><strong>Exercise 7.12:</strong> Move the definition of the <code>Sales_data</code> constructor that takes an <code>istream</code> into the body of the <code>Sales_data</code> class.</p>
<p><strong>Exercise 7.13:</strong> Rewrite the program from page <a href="073-7.1._defining_abstract_data_types.html#filepos1750685">255</a> to use the <code>istream</code> constructor.</p>
<p><strong>Exercise 7.14:</strong> Write a version of the default constructor that explicitly initializes the members to the values we have provided as in-class initializers.</p>
<p><strong>Exercise 7.15:</strong> Add appropriate constructors to your <code>Person</code> class.</p>
:::

<h4 id="filepos1827343"><a id="filepos1827376"></a>7.1.5. Copy, Assignment, and Destruction</h4>
<Badge type="info" text="Fundamental" />
<p>In addition to defining how objects of the class type are initialized, classes also control what happens when we copy, assign, or destroy objects of the class type. Objects are copied in several contexts, such as when we initialize a variable or when we pass or return an object by value (§ <a href="064-6.2._argument_passing.html#filepos1453096">6.2.1</a>, p. <a href="064-6.2._argument_passing.html#filepos1453096">209</a>, and § <a href="065-6.3._return_types_and_the_return_statement.html#filepos1552941">6.3.2</a>, p. <a href="065-6.3._return_types_and_the_return_statement.html#filepos1552941">224</a>). Objects are assigned when we use the assignment operator (§ <a href="042-4.4._assignment_operators.html#filepos1066463">4.4</a>, p. <a href="042-4.4._assignment_operators.html#filepos1066463">144</a>). Objects are destroyed when they cease to exist, such as when a local object is destroyed on exit from the block in which it was created (§ <a href="063-6.1._function_basics.html#filepos1431793">6.1.1</a>, p. <a href="063-6.1._function_basics.html#filepos1431793">204</a>). Objects stored in a <code>vector</code> (or an array) are destroyed when that <code>vector</code> (or array) is destroyed.</p>
<p>If we do not define these operations, the compiler will synthesize them for us. Ordinarily, the versions that the compiler generates for us execute by copying, assigning, or destroying each member of the object. For example, in our bookstore program in § <a href="073-7.1._defining_abstract_data_types.html#filepos1746914">7.1.1</a> (p. <a href="073-7.1._defining_abstract_data_types.html#filepos1746914">255</a>), when the compiler executes this assignment</p>

```c++
total = trans;               // process the next book
```

<p>it executes as if we had written</p>

```c++
// default assignment for Sales_data is equivalent to:
total.bookNo = trans.bookNo;
total.units_sold = trans.units_sold;
total.revenue = trans.revenue;
```

<p>We’ll show how we can define our own versions of these operations in <a href="120-chapter_13._copy_control.html#filepos3197881">Chapter 13</a>.</p>
<h5>Some Classes Cannot Rely on the Synthesized Versions</h5>
<Badge type="warning" text="Tricky" />
<p>Although the compiler will synthesize the copy, assignment, and destruction operations for us, it is important to understand that for some classes the default versions do not behave appropriately. In particular, the synthesized versions are unlikely to work correctly for classes that allocate resources that reside outside the class objects themselves. As one example, in <a href="113-chapter_12._dynamic_memory.html#filepos2900383">Chapter 12</a> we’ll see how C++ programs allocate and manage dynamic memory. As we’ll see in § <a href="121-13.1._copy_assign_and_destroy.html#filepos3244603">13.1.4</a> (p. <a href="121-13.1._copy_assign_and_destroy.html#filepos3244603">504</a>), classes that manage dynamic memory, generally cannot rely on the synthesized versions of these operations.</p>
<p>However, it is worth noting that many classes that need dynamic memory can (and generally should) use a <code>vector</code> or a <code>string</code> to manage the necessary storage. Classes that use <code>vector</code>s and <code>string</code>s avoid the complexities involved in allocating and deallocating memory.</p>
<p>Moreover, the synthesized versions for copy, assignment, and destruction work correctly for classes that have <code>vector</code> or <code>string</code> members. When we copy or assign an object that has a <code>vector</code> member, the <code>vector</code> class takes care of copying or assigning the elements in that member. When the object is destroyed, the <code>vector</code> member is destroyed, which in turn destroys the elements in the <code>vector</code>. Similarly for <code>string</code>s.</p>

::: warning
<p>Until you know how to define the operations covered in <a href="120-chapter_13._copy_control.html#filepos3197881">Chapter 13</a>, the resources your classes allocate should be stored directly as data members of the class.</p>
:::

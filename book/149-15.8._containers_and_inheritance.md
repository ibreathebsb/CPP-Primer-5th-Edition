<h3 id="filepos4017857"><a id="filepos4017890"></a>15.8. Containers and Inheritance</h3>
<Badge type="info" text="Fundamental" />
<p>When we use a container to store objects from an inheritance hierarchy, we generally must store those objects indirectly. We cannot put objects of types related by inheritance directly into a container, because there is no way to define a container that holds elements of differing types.</p>
<p>As an example, assume we want to define a <code>vector</code> to hold several books that a customer wants to buy. It should be easy to see that we can’t use a <code>vector</code> that holds <code>Bulk_quote</code> objects. We can’t convert <code>Quote</code> objects to <code>Bulk_quote</code> (§<a href="143-15.2._defining_base_and_derived_classes.html#filepos3837843">15.2.3</a>, p. <a href="143-15.2._defining_base_and_derived_classes.html#filepos3837843">602</a>), so we wouldn’t be able to put <code>Quote</code> objects into that <code>vector</code>.</p>
<p>It may be somewhat less obvious that we also can’t use a <code>vector</code> that holds objects of type <code>Quote</code>. In this case, we can put <code>Bulk_quote</code> objects into the container. However, those objects would no longer be <code>Bulk_quote</code> objects:</p>

```c++
vector<Quote> basket;
basket.push_back(Quote("0-201-82470-1", 50));
// ok, but copies only the Quote part of the object into basket
basket.push_back(Bulk_quote("0-201-54848-8", 50, 10, .25));
// calls version defined by Quote, prints 750, i.e., 15 * $50
cout << basket.back().net_price(15) << endl;
```

<p>The elements in <code>basket</code> are <code>Quote</code> objects. When we add a <code>Bulk_quote</code> object to the <code>vector</code> its derived part is ignored (§<a href="143-15.2._defining_base_and_derived_classes.html#filepos3837843">15.2.3</a>, p. <a href="143-15.2._defining_base_and_derived_classes.html#filepos3837843">603</a>).</p>

::: warning
<p>Because derived objects are “sliced down” when assigned to a base-type object, containers and types related by inheritance do not mix well.</p>
:::

<h4>Put (Smart) Pointers, Not Objects, in Containers</h4>
<p>When we need a container that holds objects related by inheritance, we typically define the container to hold pointers (preferably smart pointers (§<a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos2904799">12.1</a>, p. <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos2904799">450</a>)) to the base class. As usual, the dynamic type of the object to which those pointers point might be the base-class type or a type derived from that base:</p>

```c++
vector<shared_ptr<Quote>> basket;
basket.push_back(make_shared<Quote>("0-201-82470-1", 50));
basket.push_back(
    make_shared<Bulk_quote>("0-201-54848-8", 50, 10, .25));
// calls the version defined by Quote; prints 562.5, i.e., 15 * $50 less the discount
cout << basket.back()->net_price(15) << endl;
```

<p>Because <code>basket</code> holds <code>shared_ptr</code>s, we must dereference the value returned by <code>basket.back()</code> to get the object on which to run <code>net_price</code>. We do so by using <code>-&gt;</code> in the call to <code>net_price</code>. As usual, the version of <code>net_price</code> that is called depends on the dynamic type of the object to which that pointer points.</p>
<p>It is worth noting that we defined <code>basket</code> as <code>shared_ptr&lt;Quote&gt;</code>, yet in the second <code>push_back</code> we passed a <code>shared_ptr</code> to a <code>Bulk_quote</code> object. Just as we can convert an ordinary pointer to a derived type to a pointer to an base-class type (§<a href="143-15.2._defining_base_and_derived_classes.html#filepos3806030">15.2.2</a>, p. <a href="143-15.2._defining_base_and_derived_classes.html#filepos3806030">597</a>), we can also convert a smart pointer to a derived type to a <a id="filepos4025113"></a>smart pointer to an base-class type. Thus, <code>make_shared&lt;Bulk_quote&gt;</code> returns a <code>shared_ptr&lt;Bulk_quote&gt;</code> object, which is converted to <code>shared_ptr&lt;Quote&gt;</code> when we call <code>push_back</code>. As a result, despite appearances, all of the elements of <code>basket</code> have the same type.</p>

::: info
<p>Exercises Section 15.8</p>
<p><strong>Exercise 15.28:</strong> Define a <code>vector</code> to hold <code>Quote</code> objects but put <code>Bulk_quote</code> objects into that <code>vector</code>. Compute the total <code>net_price</code> of all the elements in the <code>vector</code>.</p>
<p><strong>Exercise 15.29:</strong> Repeat your program, but this time store <code>shared_ptr</code>s to objects of type <code>Quote</code>. Explain any discrepancy in the sum generated by the this version and the previous program. If there is no discrepancy, explain why there isn’t one.</p>
:::

<h4 id="filepos4027082">15.8.1. Writing a <code>Basket</code> Class</h4>
<Badge type="danger" text="Advanced" />
<p>One of the ironies of object-oriented programming in C++ is that we cannot use objects directly to support it. Instead, we must use pointers and references. Because pointers impose complexity on our programs, we often define auxiliary classes to help manage that complexity. We’ll start by defining a class to represent a basket:</p>

```c++
class Basket {
public:
    // Basket uses synthesized default constructor and copy-control members
    void add_item(const std::shared_ptr<Quote> &sale)
        { items.insert(sale); }
    // prints the total price for each book and the overall total for all items in the basket
    double total_receipt(std::ostream&) const;
private:
    // function to compare shared_ptrs needed by the multiset member
    static bool compare(const std::shared_ptr<Quote> &lhs,
                        const std::shared_ptr<Quote> &rhs)
    { return lhs->isbn() < rhs->isbn(); }
    // multiset to hold multiple quotes, ordered by the compare member
    std::multiset<std::shared_ptr<Quote>, decltype(compare)*>
                  items{compare};
};
```

<p>Our class uses a <code>multiset</code> (§<a href="108-11.2._overview_of_the_associative_containers.html#filepos2741390">11.2.1</a>, p. <a href="108-11.2._overview_of_the_associative_containers.html#filepos2741390">423</a>) to hold the transactions, so that we can store multiple transactions for the same book, and so that all the transactions for a given book will be kept together (§<a href="108-11.2._overview_of_the_associative_containers.html#filepos2751456">11.2.2</a>, p. <a href="108-11.2._overview_of_the_associative_containers.html#filepos2751456">424</a>).</p>
<p>The elements in our <code>multiset</code> are <code>shared_ptr</code>s and there is no less-than operator for <code>shared_ptr</code>. As a result, we must provide our own comparison operation to order the elements (§<a href="108-11.2._overview_of_the_associative_containers.html#filepos2751456">11.2.2</a>, p. <a href="108-11.2._overview_of_the_associative_containers.html#filepos2751456">425</a>). Here, we define a <code>private static</code> member, named <code>compare</code>, that compares the <code>isbn</code>s of the objects to which the <code>shared_ptr</code>s point. We initialize our <code>multiset</code> to use this comparison function through an in-class initializer (§<a href="075-7.3._additional_class_features.html#filepos1852806">7.3.1</a>, p. <a href="075-7.3._additional_class_features.html#filepos1852806">274</a>):</p>
<p><a id="filepos4031746"></a></p>

```c++
// multiset to hold multiple quotes, ordered by the compare member
std::multiset<std::shared_ptr<Quote>, decltype(compare)*>
              items{compare};
```

<p>This declaration can be hard to read, but reading from left to right, we see that we are defining a <code>multiset</code> of <code>shared_ptr</code>s to <code>Quote</code> objects. The <code>multiset</code> will use a function with the same type as our <code>compare</code> member to order the elements. The <code>multiset</code> member is named <code>items</code>, and we’re initializing <code>items</code> to use our <code>compare</code> function.</p>
<h5>Defining the Members of <code>Basket</code></h5>
<p>The <code>Basket</code> class defines only two operations. We defined the <code>add_item</code> member inside the class. That member takes a <code>shared_ptr</code> to a dynamically allocated <code>Quote</code> and puts that <code>shared_ptr</code> into the <code>multiset</code>. The second member, <code>total_receipt</code>, prints an itemized bill for the contents of the basket and returns the price for all the items in the basket:</p>

```c++
double Basket::total_receipt(ostream &os) const
{
    double sum = 0.0;   // holds the running total
    // iter refers to the first element in a batch of elements with the same ISBN
    // upper_bound returns an iterator to the element just past the end of that batch
    for (auto iter = items.cbegin();
              iter != items.cend();
              iter = items.upper_bound(*iter)) {
        // we know there's at least one element with this key in the Basket
        // print the line item for this book
        sum += print_total(os, **iter, items.count(*iter));
    }
    os << "Total Sale: " << sum << endl; // print the final overall total
    return sum;
}
```

<p>Our <code>for</code> loop starts by defining and initializing <code>iter</code> to refer to the first element in the <code>multiset</code>. The condition checks whether <code>iter</code> is equal to <code>items.cend()</code>. If so, we’ve processed all the purchases and we drop out of the <code>for</code>. Otherwise, we process the next book.</p>
<p>The interesting bit is the “increment” expression in the <code>for</code>. Rather than the usual loop that reads each element, we advance <code>iter</code> to refer to the next key. We skip over all the elements that match the current key by calling <code>upper_bound</code> (§<a href="109-11.3._operations_on_associative_containers.html#filepos2829910">11.3.5</a>, p. <a href="109-11.3._operations_on_associative_containers.html#filepos2829910">438</a>). The call to <code>upper_bound</code> returns the iterator that refers to the element just past the last one with the same key as in <code>iter</code>. The iterator we get back denotes either the end of the set or the next book.</p>
<p>Inside the <code>for</code> loop, we call <code>print_total</code> (§<a href="142-15.1._oop_an_overview.html#filepos3782427">15.1</a>, p. <a href="142-15.1._oop_an_overview.html#filepos3782427">593</a>) to print the details for each book in the basket:</p>

```c++
sum += print_total(os, **iter, items.count(*iter));
```

<p>The arguments to <code>print_total</code> are an <code>ostream</code> on which to write, a <code>Quote</code> object to process, and a count. When we dereference <code>iter</code>, we get a <code>shared_ptr</code>
<a id="filepos4039452"></a>that points to the object we want to print. To get that object, we must dereference that <code>shared_ptr</code>. Thus, <code>**iter</code> is a <code>Quote</code> object (or an object of a type derived from <code>Quote</code>). We use the <code>multiset count</code> member (§<a href="109-11.3._operations_on_associative_containers.html#filepos2829910">11.3.5</a>, p. <a href="109-11.3._operations_on_associative_containers.html#filepos2829910">436</a>) to determine how many elements in the <code>multiset</code> have the same key (i.e., the same <small>ISBN</small>).</p>
<p>As we’ve seen, <code>print_total</code> makes a virtual call to <code>net_price</code>, so the resulting price depends on the dynamic type of <code>**iter</code>. The <code>print_total</code> function prints the total for the given book and returns the total price that it calculated. We add that result into <code>sum</code>, which we print after we complete the <code>for</code> loop.</p>
<h5>Hiding the Pointers</h5>
<p>Users of <code>Basket</code> still have to deal with dynamic memory, because <code>add_item</code> takes a <code>shared_ptr</code>. As a result, users have to write code such as</p>

```c++
Basket bsk;
bsk.add_item(make_shared<Quote>("123", 45));
bsk.add_item(make_shared<Bulk_quote>("345", 45, 3, .15));
```

<p>Our next step will be to redefine <code>add_item</code> so that it takes a <code>Quote</code> object instead of a <code>shared_ptr</code>. This new version of <code>add_item</code> will handle the memory allocation so that our users no longer need to do so. We’ll define two versions, one that will copy its given object and the other that will move from it (§<a href="126-13.6._moving_objects.html#filepos3505762">13.6.3</a>, p. <a href="126-13.6._moving_objects.html#filepos3505762">544</a>):</p>

```c++
void add_item(const Quote& sale);  // copy the given object
void add_item(Quote&& sale);       // move the given object
```

<p>The only problem is that <code>add_item</code> doesn’t know what type to allocate. When it does its memory allocation, <code>add_item</code> will copy (or move) its <code>sale</code> parameter. Somewhere there will be a <code>new</code> expression such as:</p>

```c++
new Quote(sale)
```

<p>Unfortunately, this expression won’t do the right thing: <code>new</code> allocates an object of the type we request. This expression allocates an object of type <code>Quote</code> and copies the <code>Quote</code> portion of <code>sale</code>. However, <code>sale</code> might refer to a <code>Bulk_quote</code> object, in which case, that object will be sliced down.</p>
<h5>Simulating Virtual Copy</h5>
<Badge type="warning" text="Tricky" />
<p>We’ll solve this problem by giving our <code>Quote</code> classes a virtual member that allocates a copy of itself.</p>

```c++
class Quote {
public:
    // virtual function to return a dynamically allocated copy of itself
    // these members use reference qualifiers; see §13.6.3 (p. 546)
    virtual Quote* clone() const & {return new Quote(*this);}
    virtual Quote* clone() &&
                        {return new Quote(std::move(*this));}
    // other members as before
};
class Bulk_quote : public Quote {
    Bulk_quote* clone() const & {return new Bulk_quote(*this);}
    Bulk_quote* clone() &&
                   {return new Bulk_quote(std::move(*this));}
    // other members as before
};
```

<p>Because we have a copy and a move version of <code>add_item</code>, we defined lvalue and rvalue versions of <code>clone</code> (§<a href="126-13.6._moving_objects.html#filepos3505762">13.6.3</a>, p. <a href="126-13.6._moving_objects.html#filepos3505762">546</a>). Each <code>clone</code> function allocates a new object of its own type. The <code>const</code> lvalue reference member copies itself into that newly allocated object; the rvalue reference member moves its own data.</p>
<p>Using <code>clone</code>, it is easy to write our new versions of <code>add_item</code>:</p>

```c++
class Basket {
public:
    void add_item(const Quote& sale) // copy the given object
      { items.insert(std::shared_ptr<Quote>(sale.clone())); }
    void add_item(Quote&& sale)      // move the given object
      { items.insert(
          std::shared_ptr<Quote>(std::move(sale).clone())); }
    // other members as before
};
```

<p>Like <code>add_item</code> itself, <code>clone</code> is overloaded based on whether it is called on an lvalue or an rvalue. Thus, the first version of <code>add_item</code> calls the <code>const</code> lvalue version of <code>clone</code>, and the second version calls the rvalue reference version. Note that in the rvalue version, although the type of <code>sale</code> is an rvalue reference type, <code>sale</code> (like any other variable) is an lvalue (§<a href="126-13.6._moving_objects.html#filepos3429349">13.6.1</a>, p. <a href="126-13.6._moving_objects.html#filepos3429349">533</a>). Therefore, we call <code>move</code> to bind an rvalue reference to <code>sale</code>.</p>
<p>Our <code>clone</code> function is also virtual. Whether the <code>Quote</code> or <code>Bulk_quote</code> function is run, depends (as usual) on the dynamic type of <code>sale</code>. Regardless of whether we copy or move the data, <code>clone</code> returns a pointer to a newly allocated object, of its own type. We bind a <code>shared_ptr</code> to that object and call <code>insert</code> to add this newly allocated object to <code>items</code>. Note that because <code>shared_ptr</code> supports the derived-to-base conversion (§<a href="143-15.2._defining_base_and_derived_classes.html#filepos3806030">15.2.2</a>, p. <a href="143-15.2._defining_base_and_derived_classes.html#filepos3806030">597</a>), we can bind a <code>shared_ptr&lt;Quote</code> to a <code>Bulk_quote*</code>.</p>

::: info
<p>Exercises Section 15.8.1</p>
<p><strong>Exercise 15.30:</strong> Write your own version of the <code>Basket</code> class and use it to compute prices for the same transactions as you used in the previous exercises.</p>
:::

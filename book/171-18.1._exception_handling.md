<h3 id="filepos4855328">18.1. Exception Handling</h3>
<p><strong><a href="175-defined_terms.html#filepos5107360" id="filepos4855463">Exception handling</a></strong> allows independently developed parts of a program to communicate about and handle problems that arise at run time. Exceptions let us separate problem detection from problem resolution. One part of the program can detect a problem and can pass the job of resolving that problem to another part of the program. The detecting part need not know anything about the handling part, and vice versa.</p>
<p>In § <a href="059-5.6._try_blocks_and_exception_handling.html#filepos1368051">5.6</a> (p. <a href="059-5.6._try_blocks_and_exception_handling.html#filepos1368051">193</a>) we introduced the basic concepts and mechanics of using exceptions. In this section we’ll expand our coverage of these basics. Effective use of exception handling requires understanding what happens when an exception is thrown, what happens when it is caught, and the meaning of the objects that communicate what went wrong.</p>
<h4 id="filepos4856427">18.1.1. Throwing an Exception</h4>
<p>In C++, an exception is <strong><a href="175-defined_terms.html#filepos5114981" id="filepos4856590">raised</a></strong> by <strong>throwing</strong> an expression. The type of the thrown expression, together with the current call chain, determines which <strong><a href="175-defined_terms.html#filepos5110121" id="filepos4856792">handler</a></strong> will deal with the exception. The selected handler is the one nearest in the call chain that matches the type of the thrown object. The type and contents of that object allow the throwing part of the program to inform the handling part about what went wrong.</p>
<p>When a <code>throw</code> is executed, the statement(s) following the <code>throw</code> are not executed. Instead, control is transferred from the <code>throw</code> to the matching <code>catch</code>. That <code>catch</code> might be local to the same function or might be in a function that directly or indirectly called the function in which the exception occurred. The fact that control passes from one location to another has two important implications:</p>
<ul><li>Functions along the call chain may be prematurely exited.</li><li>When a handler is entered, objects created along the call chain will have been destroyed.</li></ul>

<p>Because the statements following a <code>throw</code> are not executed, a <code>throw</code> is like a <code>return:</code> It is usually part of a conditional statement or is the last (or only) statement in a function.</p>
<h5><a id="filepos4858722"></a>Stack Unwinding</h5>
<p>When an exception is thrown, execution of the current function is suspended and the search for a matching <code>catch</code> clause begins. If the <code>throw</code> appears inside a <a href="175-defined_terms.html#filepos5117274" id="filepos4859097"><code>try</code>
<strong>block</strong></a>, the <code>catch</code> clauses associated with that <code>try</code> are examined. If a matching <code>catch</code> is found, the exception is handled by that <code>catch</code>. Otherwise, if the <code>try</code> was itself nested inside another <code>try</code>, the search continues through the <code>catch</code> clauses of the enclosing <code>try</code>s. If no matching <code>catch</code> is found, the current function is exited, and the search continues in the calling function.</p>
<p>If the call to the function that threw is in a <code>try</code> block, then the <code>catch</code> clauses associated with that <code>try</code> are examined. If a matching <code>catch</code> is found, the exception is handled. Otherwise, if that <code>try</code> was nested, the <code>catch</code> clauses of the enclosing <code>try</code>s are searched. If no catch is found, the calling function is also exited. The search continues in the function that called the just exited one, and so on.</p>
<p>This process, known as <strong><a href="175-defined_terms.html#filepos5115865" id="filepos4861240">stack unwinding</a></strong>, continues up the chain of nested function calls until a <code>catch</code> clause for the exception is found, or the <code>main</code> function itself is exited without having found a matching <code>catch</code>.</p>
<p>Assuming a matching <code>catch</code> is found, that <code>catch</code> is entered, and the program continues by executing the code inside that <code>catch</code>. When the <code>catch</code> completes, execution continues at the point immediately after the last <code>catch</code> clause associated with that <code>try</code> block.</p>
<p>If no matching <code>catch</code> is found, the program is exited. Exceptions are intended for events that prevent the program from continuing normally. Therefore, once an exception is raised, it cannot remain unhandled. If no matching <code>catch</code> is found, the program calls the library <code>terminate</code> function. As its name implies, <code>terminate</code> stops execution of the program.</p>

::: info
<p>An exception that is not caught terminates the program.</p>
:::

<h5>Objects Are Automatically Destroyed during Stack Unwinding</h5>
<p>During stack unwinding, blocks in the call chain may be exited prematurely. In general, these blocks will have created local objects. Ordinarily, local objects are destroyed when the block in which they are created is exited. Stack unwinding is no exception. When a block is exited during stack unwinding, the compiler guarantees that objects created in that block are properly destroyed. If a local object is of class type, the destructor for that object is called automatically. As usual, the compiler does no work to destroy objects of built-in type.</p>
<p>If an exception occurs in a constructor, then the object under construction might be only partially constructed. Some of its members might have been initialized, but others might not have been initialized before the exception occurred. Even if the object is only partially constructed, we are guaranteed that the constructed members will be properly destroyed.</p>
<p>Similarly, an exception might occur during initialization of the elements of an array or a library container type. Again, we are guaranteed that the elements (if any) that were constructed before the exception occurred will be destroyed.</p>
<h5><a id="filepos4865062"></a>Destructors and Exceptions</h5>
<p>The fact that destructors are run—but code inside a function that frees a resource may be bypassed—affects how we structure our programs. As we saw in § <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos3024819">12.1.4</a> (p. <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos3024819">467</a>), if a block allocates a resource, and an exception occurs before the code that frees that resource, the code to free the resource will not be executed. On the other hand, resources allocated by an object of class type generally will be freed by their destructor. By using classes to control resource allocation, we ensure that resources are properly freed, whether a function ends normally or via an exception.</p>
<p>The fact that destructors are run during stack unwinding affects how we write destructors. During stack unwinding, an exception has been raised but is not yet handled. If a new exception is thrown during stack unwinding and not caught in the function that threw it, <code>terminate</code> is called. Because destructors may be invoked during stack unwinding, they should never throw exceptions that the destructor itself does not handle. That is, if a destructor does an operation that might throw, it should wrap that operation in a <code>try</code> block and handle it locally to the destructor.</p>
<p>In practice, because destructors free resources, it is unlikely that they will throw exceptions. All of the standard library types guarantee that their destructors will not raise an exception.</p>

::: warning
<p>During stack unwinding, destructors are run on local objects of class type. Because destructors are run automatically, they should not throw. If, during stack unwinding, a destructor throws an exception that it does not also catch, the program will be terminated.</p>
:::

<h5>The Exception Object</h5>
<p>The compiler uses the thrown expression to copy initialize (§ <a href="121-13.1._copy_assign_and_destroy.html#filepos3203084">13.1.1</a>, p. <a href="121-13.1._copy_assign_and_destroy.html#filepos3203084">497</a>) a special object known as the <strong><a href="175-defined_terms.html#filepos5108038" id="filepos4867759">exception object</a></strong>. As a result, the expression in a <code>throw</code> must have a complete type (§ <a href="075-7.3._additional_class_features.html#filepos1897012">7.3.3</a>, p. <a href="075-7.3._additional_class_features.html#filepos1897012">278</a>). Moreover, if the expression has class type, that class must have an accessible destructor and an accessible copy or move constructor. If the expression has an array or function type, the expression is converted to its corresponding pointer type.</p>
<p>The exception object resides in space, managed by the compiler, that is guaranteed to be accessible to whatever <code>catch</code> is invoked. The exception object is destroyed after the exception is completely handled.</p>
<p>As we’ve seen, when an exception is thrown, blocks along the call chain are exited until a matching handler is found. When a block is exited, the memory used by the local objects in that block is freed. As a result, it is almost certainly an error to throw a pointer to a local object. It is an error for the same reasons that it is an error to return a pointer to a local object (§ <a href="065-6.3._return_types_and_the_return_statement.html#filepos1552941">6.3.2</a>, p. <a href="065-6.3._return_types_and_the_return_statement.html#filepos1552941">225</a>) from a function. If the pointer points to an object in a block that is exited before the <code>catch</code>, then that local object will have been destroyed before the <code>catch</code>.</p>
<p>When we throw an expression, the static, compile-time type (§ <a href="143-15.2._defining_base_and_derived_classes.html#filepos3837843">15.2.3</a>, p. <a href="143-15.2._defining_base_and_derived_classes.html#filepos3837843">601</a>) of that expression determines the type of the exception object. This point is essential to keep in mind, because many applications throw expressions whose type comes <a id="filepos4869804"></a>from an inheritance hierarchy. If a <code>throw</code> expression dereferences a pointer to a base-class type, and that pointer points to a derived-type object, then the thrown object is sliced down (§ <a href="143-15.2._defining_base_and_derived_classes.html#filepos3837843">15.2.3</a>, p. <a href="143-15.2._defining_base_and_derived_classes.html#filepos3837843">603</a>); only the base-class part is thrown.</p>

::: warning
<p>Throwing a pointer requires that the object to which the pointer points exist wherever the corresponding handler resides.</p>
:::

::: info
<p>Exercises Section 18.1.1</p>
<p><strong>Exercise 18.1:</strong> What is the type of the exception object in the following <code>throw</code>s?</p>
<p><strong>(a)</strong>
<code>range_error r("error");</code></p>

```c++
throw r;
```

<p><strong>(b)</strong>
<code>exception *p = &amp;r;</code></p>

```c++
throw *p;
```

<p>What would happen if the <code>throw</code> in (b) were written as <code>throw p</code>?</p>
<p><strong>Exercise 18.2:</strong> Explain what happens if an exception occurs at the indicated point:</p>

```c++
void exercise(int *b, int *e)
{
    vector<int> v(b, e);
    int *p = new int[v.size()];
    ifstream in("ints");
    // exception occurs here
}
```

<p><strong>Exercise 18.3:</strong> There are two ways to make the previous code work correctly if an exception is thrown. Describe them and implement them.</p>
:::

<h4 id="filepos4873158">18.1.2. Catching an Exception</h4>
<p>The <strong><a href="175-defined_terms.html#filepos5106683" id="filepos4873301">exception declaration</a></strong> in a <a href="175-defined_terms.html#filepos5105424" id="filepos4873381"><code>catch</code>
<strong>clause</strong></a> looks like a function parameter list with exactly one parameter. As in a parameter list, we can omit the name of the catch parameter if the <code>catch</code> has no need to access the thrown expression.</p>
<p>The type of the declaration determines what kinds of exceptions the handler can catch. The type must be a complete type (§ <a href="075-7.3._additional_class_features.html#filepos1897012">7.3.3</a>, p. <a href="075-7.3._additional_class_features.html#filepos1897012">278</a>). The type can be an lvalue reference but may not be an rvalue reference (§ <a href="126-13.6._moving_objects.html#filepos3429349">13.6.1</a>, p. <a href="126-13.6._moving_objects.html#filepos3429349">532</a>).</p>
<p>When a <code>catch</code> is entered, the parameter in its exception declaration is initialized by the exception object. As with function parameters, if the <code>catch</code> parameter has a nonreference type, then the parameter in the <code>catch</code> is a copy of the exception object; changes made to the parameter inside the <code>catch</code> are made to a local copy, not to the exception object itself. If the parameter has a reference type, then like any reference parameter, the <code>catch</code> parameter is just another name for the exception object. Changes made to the parameter are made to the exception object.</p>
<p>Also like a function parameter, a <code>catch</code> parameter that has a base-class type can be initialized by an exception object that has a type derived from the parameter type. If the <code>catch</code> parameter has a nonreference type, then the exception object <a id="filepos4875631"></a>will be sliced down (§ <a href="143-15.2._defining_base_and_derived_classes.html#filepos3837843">15.2.3</a>, p. <a href="143-15.2._defining_base_and_derived_classes.html#filepos3837843">603</a>), just as it would be if such an object were passed to an ordinary function by value. On the other hand, if the parameter is a reference to a base-class type, then the parameter is bound to the exception object in the usual way.</p>
<p>Again, as with a function parameter, the static type of the exception declaration determines the actions that the <code>catch</code> may perform. If the <code>catch</code> parameter has a base-class type, then the <code>catch</code> cannot use any members that are unique to the derived type.</p>

::: tip
<p>Best Practices</p>
<p>Ordinarily, a <code>catch</code> that takes an exception of a type related by inheritance ought to define its parameter as a reference.</p>
:::

<h5>Finding a Matching Handler</h5>
<p>During the search for a matching <code>catch</code>, the <code>catch</code> that is found is not necessarily the one that matches the exception best. Instead, the selected <code>catch</code> is the <em>first</em> one that matches the exception at all. As a consequence, in a list of <code>catch</code> clauses, the most specialized <code>catch</code> must appear first.</p>
<p>Because <code>catch</code> clauses are matched in the order in which they appear, programs that use exceptions from an inheritance hierarchy must order their <code>catch</code> clauses so that handlers for a derived type occur before a <code>catch</code> for its base type.</p>
<p>The rules for when an exception matches a <code>catch</code> exception declaration are much more restrictive than the rules used for matching arguments with parameter types. Most conversions are not allowed—the types of the exception and the <code>catch</code> declaration must match exactly with only a few possible differences:</p>
<ul><li>Conversions from non<code>const</code> to <code>const</code> are allowed. That is, a <code>throw</code> of a non<code>const</code> object can match a <code>catch</code> specified to take a reference to <code>const</code>.</li><li>Conversions from derived type to base type are allowed.</li><li>An array is converted to a pointer to the type of the array; a function is converted to the appropriate pointer to function type.</li></ul>

<p>No other conversions are allowed to match a <code>catch</code>. In particular, neither the standard arithmetic conversions nor conversions defined for class types are permitted.</p>

::: info
<p>Multiple <code>catch</code> clauses with types related by inheritance must be ordered from most derived type to least derived.</p>
:::

<h5>Rethrow</h5>
<p>Sometimes a single <code>catch</code> cannot completely handle an exception. After some corrective actions, a <code>catch</code> may decide that the exception must be handled by a function further up the call chain. A <code>catch</code> passes its exception out to another <code>catch</code> by <strong><a href="175-defined_terms.html#filepos5115285" id="filepos4881200">rethrowing</a></strong> the exception. A rethrow is a <code>throw</code> that is not followed by an expression:</p>

```c++
throw;
```

<p><a id="filepos4881607"></a>An empty <code>throw</code> can appear only in a <code>catch</code> or in a function called (directly or indirectly) from a <code>catch</code>. If an empty <code>throw</code> is encountered when a handler is not active, <code>terminate</code> is called.</p>
<p>A rethrow does not specify an expression; the (current) exception object is passed up the chain.</p>
<p>In general, a <code>catch</code> might change the contents of its parameter. If, after changing its parameter, the <code>catch</code> rethrows the exception, then those changes will be propagated only if the <code>catch</code>’s exception declaration is a reference:</p>

```c++
catch (my_error &eObj) {     // specifier is a reference type
    eObj.status = errCodes::severeErr; // modifies the exception object
    throw; // the status member of the exception object is severeErr
} catch (other_error eObj) { // specifier is a nonreference type
    eObj.status = errCodes::badErr;    // modifies the local copy only
    throw; // the status member of the exception object is unchanged
}
```

<h5>The Catch-All Handler</h5>
<p>Sometimes we want to catch any exception that might occur, regardless of type. Catching every possible exception can be a problem: Sometimes we don’t know what types might be thrown. Even when we do know all the types, it may be tedious to provide a specific <code>catch</code> clause for every possible exception. To catch all exceptions, we use an ellipsis for the exception declaration. Such handlers, sometimes known as <strong><a href="175-defined_terms.html#filepos5104804" id="filepos4884962">catch-all</a></strong> handlers, have the form <code>catch(...)</code>. A catch-all clause matches any type of exception.</p>
<p>A <code>catch(...)</code> is often used in combination with a rethrow expression. The <code>catch</code> does whatever local work can be done and then rethrows the exception:</p>

```c++
void manip() {
    try {
        // actions that cause an exception to be thrown
    }
    catch (...) {
        // work to partially handle the exception
        throw;
    }
}
```

<p>A <code>catch(...)</code> clause can be used by itself or as one of several <code>catch</code> clauses.</p>

::: info
<p>If a <code>catch(...)</code> is used in combination with other <code>catch</code> clauses, it must be last. Any <code>catch</code> that follows a catch-all can never be matched.</p>
:::

<h4 id="filepos4887288">18.1.3. Function <code>try</code> Blocks and Constructors</h4>
<p>In general, exceptions can occur at any point in the program’s execution. In particular, an exception might occur while processing a constructor initializer. Constructor initializers execute before the constructor body is entered. A <code>catch</code> inside <a id="filepos4887878"></a>the constructor body can’t handle an exception thrown by a constructor initializer because a <code>try</code> block inside the constructor body would not yet be in effect when the exception is thrown.</p>

::: info
<p>Exercises Section 18.1.2</p>
<p><strong>Exercise 18.4:</strong> Looking ahead to the inheritance hierarchy in <a href="171-18.1._exception_handling.html#filepos4889339">Figure 18.1</a> (p. <a href="171-18.1._exception_handling.html#filepos4889339">783</a>), explain what’s wrong with the following <code>try</code> block. Correct it.</p>

```c++
try {
    // use of the C++ standard library
} catch(exception) {
    // ...
} catch(const runtime_error &re) {
    // ...
} catch(overflow_error eobj) { /* ... */ }
```

<a id="filepos4889339"></a><img alt="Image" src="/images/00132.jpg"/>
<p>Figure 18.1. Standard <code>exception</code> Class Hierarchy</p>
<p><strong>Exercise 18.5:</strong> Modify the following <code>main</code> function to catch any of the exception types shown in <a href="171-18.1._exception_handling.html#filepos4889339">Figure 18.1</a> (p. <a href="171-18.1._exception_handling.html#filepos4889339">783</a>):</p>

```c++
int main() {
    // use of the C++ standard library
}
```

<p>The handlers should print the error message associated with the exception before calling <code>abort</code> (defined in the header <code>cstdlib</code>) to terminate <code>main</code>.</p>
<p><strong>Exercise 18.6:</strong> Given the following exception types and <code>catch</code> clauses, write a <code>throw</code> expression that creates an exception object that can be caught by each <code>catch</code> clause:</p>
<p><strong>(a)</strong>
<code>class exceptionType { };</code></p>

```c++
catch(exceptionType *pet) { }
```

<p><strong>(b)</strong>
<code>catch(...) { }</code></p>
<p><strong>(c)</strong>
<code>typedef int EXCPTYPE;</code></p>

```c++
catch(EXCPTYPE) { }
```

:::

<p>To handle an exception from a constructor initializer, we must write the constructor as a <a href="175-defined_terms.html#filepos5109234" id="filepos4892438"><strong>function</strong>
<code>try</code>
<strong>block</strong></a>. A function <code>try</code> block lets us associate a group of <code>catch</code> clauses with the initialization phase of a constructor (or the destruction phase of a destructor) as well as with the constructor’s (or destructor’s) function body. As an example, we might wrap the <code>Blob</code> constructors (§ <a href="154-16.1._defining_a_template.html#filepos4193169">16.1.2</a>, p. <a href="154-16.1._defining_a_template.html#filepos4193169">662</a>) in a function <code>try</code> block:</p>

```c++
template <typename T>
Blob<T>::Blob(std::initializer_list<T> il) try :
              data(std::make_shared<std::vector<T>>(il)) {
         /* empty body */
} catch(const std::bad_alloc &e) { handle_out_of_memory(e); }
```

<p>Notice that the keyword <code>try</code> appears before the colon that begins the constructor initializer list and before the curly brace that forms the (in this case empty) constructor function body. The <code>catch</code> associated with this <code>try</code> can be used to handle <a id="filepos4894536"></a>exceptions thrown either from within the member initialization list or from within the constructor body.</p>
<p>It is worth noting that an exception can happen while initializing the constructor’s parameters. Such exceptions are <em>not</em> part of the function <code>try</code> block. The function <code>try</code> block handles only exceptions that occur once the constructor begins executing. As with any other function call, if an exception occurs during parameter initialization, that exception is part of the calling expression and is handled in the caller’s context.</p>

::: info
<p>The only way for a constructor to handle an exception from a constructor initializer is to write the constructor as a function <code>try</code> block.</p>
:::

::: info
<p>Exercises Section 18.1.3</p>
<p><strong>Exercise 18.7:</strong> Define your <code>Blob</code> and <code>BlobPtr</code> classes from <a href="153-chapter_16._templates_and_generic_programming.html#filepos4150078">Chapter 16</a> to use function <code>try</code> blocks for their constructors.</p>
:::

<h4 id="filepos4896504">18.1.4. The <code>noexcept</code> Exception Specification</h4>
<p>It can be helpful both to users and to the compiler to know that a function will not throw any exceptions. Knowing that a function will not throw simplifies the task of writing code that calls that function. Moreover, if the compiler knows that no exceptions will be thrown, it can (sometimes) perform optimizations that must be suppressed if code might throw.</p>
<a id="filepos4897184"></a><img alt="Image" src="/images/00008.jpg"/>
<p>Under the new standard, a function can specify that it does not throw exceptions by providing a <a href="175-defined_terms.html#filepos5113452" id="filepos4897368"><code>noexcept</code>
<strong>specification</strong></a>. The keyword <code>noexcept</code> following the function parameter list indicates that the function won’t throw:</p>

```c++
void recoup(int) noexcept;   // won't throw
void alloc(int);             // might throw
```

<p>These declarations say that <code>recoup</code> will not throw any exceptions and that <code>alloc</code> might. We say that <code>recoup</code> has a <strong><a href="175-defined_terms.html#filepos5114294" id="filepos4898708">nonthrowing specification</a></strong>.</p>
<p>The <code>noexcept</code> specifier must appear on all of the declarations and the corresponding definition of a function or on none of them. The specifier precedes a trailing return (§ <a href="065-6.3._return_types_and_the_return_statement.html#filepos1583824">6.3.3</a>, p. <a href="065-6.3._return_types_and_the_return_statement.html#filepos1583824">229</a>). We may also specify <code>noexcept</code> on the declaration and definition of a function pointer. It may not appear in a <code>typedef</code> or type alias. In a member function the <code>noexcept</code> specifier follows any <code>const</code> or reference qualifiers, and it precedes <code>final, override</code>, or <code>= 0</code> on a virtual function.</p>
<h5>Violating the Exception Specification</h5>
<p>It is important to understand that the compiler does not check the <code>noexcept</code> specification at compile time. In fact, the compiler is not permitted to reject a function with a <code>noexcept</code> specifier merely because it contains a <code>throw</code> or calls a function that might throw (however, kind compilers will warn about such usages):</p>
<p><a id="filepos4900567"></a></p>

```c++
// this function will compile, even though it clearly violates its exception specification
void f() noexcept       // promises not to throw any exception
{
    throw exception();  // violates the exception specification
}
```

<p>As a result, it is possible that a function that claims it will not throw will in fact throw. If a <code>noexcept</code> function does throw, <code>terminate</code> is called, thereby enforcing the promise not to throw at run time. It is unspecified whether the stack is unwound. As a result, <code>noexcept</code> should be used in two cases: if we are confident that the function won’t throw, and/or if we don’t know what we’d do to handle the error anyway.</p>
<p>Specifying that a function won’t throw effectively promises the <em>callers</em> of the nonthrowing function that they will never need to deal with exceptions. Either the function won’t throw, or the whole program will terminate; the caller escapes responsibility either way.</p>

::: warning
<p>The compiler in general cannot, and does not, verify exception specifications at compile time.</p>
:::

::: info
<p>Backward Compatibility: Exception Specifications</p>
<p>Earlier versions of C++ had a more elaborate scheme of exception specifications that allowed us to specify the types of exceptions that a function might throw. A function can specify the keyword <code>throw</code> followed by a parenthesized list of types that the function might throw. The <code>throw</code> specifier appeared in the same place as the <code>noexcept</code> specifier does in the current language.</p>
<p>This approach was never widely used and has been deprecated in the current standard. Although these more elaborate specifiers have been deprecated, there is one use of the old scheme that is in widespread use. A function that is designated by <code>throw()</code> promises not to throw any exceptions:</p>

```c++
void recoup(int) noexcept;  // recoup doesn't throw
void recoup(int) throw();   // equivalent declaration
```

<p>These declarations of <code>recoup</code> are equivalent. Both say that <code>recoup</code> won’t throw.</p>
:::

<h5>Arguments to the <code>noexcept</code> Specification</h5>
<p>The <code>noexcept</code> specifier takes an optional argument that must be convertible to <code>bool:</code> If the argument is <code>true</code>, then the function won’t throw; if the argument is <code>false</code>, then the function might throw:</p>

```c++
void recoup(int) noexcept(true);  //  recoup won't throw
void alloc(int) noexcept(false);  //  alloc can throw
```

<h5>The <code>noexcept</code> Operator</h5>
<a id="filepos4906788"></a><img alt="Image" src="/images/00008.jpg"/>
<p>Arguments to the <code>noexcept</code> specifier are often composed using the <a href="175-defined_terms.html#filepos5112716" id="filepos4907003"><code>noexcept</code>
<strong>operator</strong></a>. The <code>noexcept</code> operator is a unary operator that returns a <code>bool</code> rvalue <a id="filepos4907407"></a>constant expression that indicates whether a given expression might throw. Like <code>sizeof</code> (§ <a href="047-4.9._the_sizeof_operator.html#filepos1142429">4.9</a>, p. <a href="047-4.9._the_sizeof_operator.html#filepos1142429">156</a>), <code>noexcept</code> does not evaluate its operand.</p>
<p>For example, this expression yields <code>true</code>:</p>

```c++
noexcept(recoup(i)) // true if calling recoup can't throw, false otherwise
```

<p>because we declared <code>recoup</code> with a <code>noexcept</code> specifier. More generally,</p>

```c++
noexcept(e)
```

<p>is <code>true</code> if all the functions called by <code>e</code> have nonthrowing specifications and <code>e</code> itself does not contain a <code>throw</code>. Otherwise, <code>noexcept(e)</code> returns <code>false</code>.</p>
<p>We can use the <code>noexcept</code> operator to form an exception specifier as follows:</p>

```c++
void f() noexcept(noexcept(g())); // f has same exception specifier as g
```

<p>If the function <code>g</code> promises not to throw, then <code>f</code> also is nonthrowing. If <code>g</code> has no exception specifier, or has an exception specifier that allows exceptions, then <code>f</code> also might throw.</p>

::: info
<p><code>noexcept</code> has two meanings: It is an exception specifier when it follows a function’s parameter list, and it is an operator that is often used as the <code>bool</code> argument to a <code>noexcept</code> exception specifier.</p>
:::

<h5>Exception Specifications and Pointers, Virtuals, and Copy Control</h5>
<p>Although the <code>noexcept</code> specifier is not part of a function’s type, whether a function has an exception specification affects the use of that function.</p>
<p>A pointer to function and the function to which that pointer points must have compatible specifications. That is, if we declare a pointer that has a nonthrowing exception specification, we can use that pointer only to point to similarly qualified functions. A pointer that specifies (explicitly or implicitly) that it might throw can point to any function, even if that function includes a promise not to throw:</p>

```c++
// both recoup and pf1 promise not to throw
void (*pf1)(int) noexcept = recoup;

// ok: recoup won't throw; it doesn't matter that pf2 might
void (*pf2)(int) = recoup;

pf1 = alloc; // error: alloc might throw but pf1 said it wouldn't
pf2 = alloc; // ok: both pf2 and alloc might throw
```

<p>If a virtual function includes a promise not to throw, the inherited virtuals must also promise not to throw. On the other hand, if the base allows exceptions, it is okay for the derived functions to be more restrictive and promise not to throw:</p>

```c++
class Base {
public:
    virtual double f1(double) noexcept; // doesn't throw
    virtual int f2() noexcept(false);   // can throw
    virtual void f3();                  // can throw
};

class Derived : public Base {
public:
    double f1(double);        // error: Base::f1 promises not to throw
    int f2() noexcept(false); // ok: same specification as Base::f2
    void f3() noexcept;       // ok: Derived f3 is more restrictive
};
```

<p>When the compiler synthesizes the copy-control members, it generates an exception specification for the synthesized member. If all the corresponding operation for all the members and base classes promise not to throw, then the synthesized member is <code>noexcept</code>. If any function invoked by the synthesized member can throw, then the synthesized member is <code>noexcept(false)</code>. Moreover, if we do not provide an exception specification for a destructor that we do define, the compiler synthesizes one for us. The compiler generates the same specification as it would have generated had it synthesized the destructor for that class.</p>

::: info
<p>Exercises Section 18.1.4</p>
<p><strong>Exercise 18.8:</strong> Review the classes you’ve written and add appropriate exception specifications to their constructors and destructors. If you think one of your destructors might throw, change the code so that it cannot throw.</p>
:::

<h4 id="filepos4917333">18.1.5. Exception Class Hierarchies</h4>
<p>The standard-library exception classes (§ <a href="059-5.6._try_blocks_and_exception_handling.html#filepos1391364">5.6.3</a>, p. <a href="059-5.6._try_blocks_and_exception_handling.html#filepos1391364">197</a>) form the inheritance hierarchy (<a href="141-chapter_15._objectoriented_programming.html#filepos3778984">Chapter 15</a>) as shown in <a href="171-18.1._exception_handling.html#filepos4889339">Figure 18.1</a>.</p>
<p>The only operations that the <code>exception</code> types define are the copy constructor, copy-assignment operator, a virtual destructor, and a virtual member named <code>what</code>. The <code>what</code> function returns a <code>const char*</code> that points to a null-terminated character array, and is guaranteed not to throw any exceptions.</p>
<p>The <code>exception</code>, <code>bad_cast</code>, and <code>bad_alloc</code> classes also define a default constructor. The <code>runtime_error</code> and <code>logic_error</code> classes do not have a default constructor but do have constructors that take a C-style character string or a library <code>string</code> argument. Those arguments are intended to give additional information about the error. In these classes, <code>what</code> returns the message used to initialize the exception object. Because <code>what</code> is virtual, if we catch a reference to the base-type, a call to the <code>what</code> function will execute the version appropriate to the dynamic type of the exception object.</p>
<h5>Exception Classes for a Bookstore Application</h5>
<p>Applications often extend the <code>exception</code> hierarchy by defining classes derived from <code>exception</code> (or from one of the library classes derived from <code>exception</code>). These application-specific classes represent exceptional conditions specific to the application domain.</p>
<p><a id="filepos4920228"></a>If we were building a real bookstore application, our classes would have been much more complicated than the ones presented in this Primer. One such complexity would be how these classes handled exceptions. In fact, we probably would have defined our own hierarchy of exceptions to represent application-specific problems. Our design might include classes such as</p>

```c++
// hypothetical exception classes for a bookstore application
class out_of_stock: public std::runtime_error {
public:
    explicit out_of_stock(const std::string &s):
                       std::runtime_error(s) { }
};
class isbn_mismatch: public std::logic_error {
public:
    explicit isbn_mismatch(const std::string &s):
                          std::logic_error(s) { }
    isbn_mismatch(const std::string &s,
        const std::string &lhs, const std::string &rhs):
        std::logic_error(s), left(lhs), right(rhs) { }
    const std::string left, right;
};
```

<p>Our application-specific exception types inherit them from the standard exception classes. As with any hierarchy, we can think of the exception classes as being <a id="filepos4922219"></a>organized into layers. As the hierarchy becomes deeper, each layer becomes a more specific exception. For example, the first and most general layer of the hierarchy is represented by class <code>exception</code>. All we know when we catch an object of type <code>exception</code> is that something has gone wrong.</p>
<p>The second layer specializes <code>exception</code> into two broad categories: run-time or logic errors. Run-time errors represent things that can be detected only when the program is executing. Logic errors are, in principle, errors that we could have detected in our application.</p>
<p>Our bookstore exception classes further refine these categories. The class named <code>out_of_stock</code> represents something, particular to our application, that can go wrong at run time. It would be used to signal that an order cannot be fulfilled. The class <code>isbn_mismatch</code> represents a more particular form of <code>logic_error</code>. In principle, a program could prevent and handle this error by comparing the results of <code>isbn()</code> on the objects.</p>
<h5>Using Our Own Exception Types</h5>
<p>We use our own exception classes in the same way that we use one of the standard library classes. One part of the program throws an object of one of these types, and another part catches and handles the indicated problem. As an example, we might define the compound addition operator for our <code>Sales_data</code> class to throw an error of type <code>isbn_mismatch</code> if it detected that the <small>ISBN</small>s didn’t match:</p>

```c++
// throws an exception if both objects do not refer to the same book
Sales_data&
Sales_data::operator+=(const Sales_data& rhs)
{
    if (isbn() != rhs.isbn())
        throw isbn_mismatch("wrong isbns", isbn(), rhs.isbn());
    units_sold += rhs.units_sold;
    revenue += rhs.revenue;
    return *this;
}
```

<p>Code that uses the compound addition operator (or ordinary addition operator, which itself uses the compound addition operator) can detect this error, write an appropriate error message, and continue:</p>

```c++
// use the hypothetical bookstore exceptions
Sales_data item1, item2, sum;
while (cin >> item1 >> item2) {  // read two transactions
    try {
        sum = item1 + item2;     //  calculate their sum
        // use sum
    } catch (const isbn_mismatch &e) {
      cerr << e.what() << ": left isbn(" << e.left
           << ") right isbn(" << e.right << ")" << endl;
    }
}
```

::: info
<a id="filepos4926967"></a><p>Exercises Section 18.1.5</p>
<p><strong>Exercise 18.9:</strong> Define the bookstore exception classes described in this section and rewrite your <code>Sales_data</code> compound assigment operator to throw an exception.</p>
<p><strong>Exercise 18.10:</strong> Write a program that uses the <code>Sales_data</code> addition operator on objects that have differing <small>ISBN</small>s. Write two versions of the program: one that handles the exception and one that does not. Compare the behavior of the programs so that you become familiar with what happens when an uncaught exception occurs.</p>
<p><strong>Exercise 18.11:</strong> Why is it important that the <code>what</code> function doesn’t throw?</p>
:::

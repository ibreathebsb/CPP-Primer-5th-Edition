<h3 id="filepos5104665">Defined Terms</h3><ul><li><p><a href="171-18.1._exception_handling.html#filepos4884962" id="filepos5104804"><strong>catch-all</strong></a> A <code>catch</code> clause in which the exception declaration is <code>(...)</code>. A catch-all clause catches an exception of any type. It is typically used to catch an exception that is detected locally in order to do local cleanup. The exception is then rethrown to another part of the program to deal with the underlying cause of the problem.</p></li><li><p><a href="171-18.1._exception_handling.html#filepos4873381" id="filepos5105424"><strong>catch clause</strong></a> Part of the program that handles an exception. A <code>catch</code> clause consists of the keyword <code>catch</code> followed by an exception declaration and a block of statements. The code inside a <code>catch</code> does whatever is necessary to handle an exception of the type defined in its exception declaration.</p></li><li><p><strong>constructor order</strong> Under nonvirtual inheritance, base classes are constructed in the order in which they are named in the class derivation list. Under virtual inheritance, the virtual base class(es) are constructed before any other bases. They are constructed in the order in which they appear in the derivation list of the derived type. Only the most derived type may initialize a virtual base; constructor initializers for that base that appear in the intermediate base classes are ignored.</p></li><li><p><a href="171-18.1._exception_handling.html#filepos4873301" id="filepos5106683"><strong>exception declaration</strong></a>
<code>catch</code> clause declaration that specifies the type of exception that the <code>catch</code> can handle. The declaration acts like a parameter list, whose single parameter is initialized by the exception <a id="filepos5107081"></a>object. If the exception specifier is a nonreference type, then the exception object is copied to the <code>catch</code>.</p></li><li><p><a href="171-18.1._exception_handling.html#filepos4855463" id="filepos5107360"><strong>exception handling</strong></a> Language-level support for managing run-time anomalies. One independently developed section of code can detect and “raise” an exception that another independently developed part of the program can “handle.” The error-detecting part of the program throws an exception; the error-handling part handles the exception in a <code>catch</code> clause of a <code>try</code> block.</p></li><li><p><a href="171-18.1._exception_handling.html#filepos4867759" id="filepos5108038"><strong>exception object</strong></a> Object used to communicate between the <code>throw</code> and <code>catch</code> sides of an exception. The object is created at the point of the <code>throw</code> and is a copy of the thrown expression. The exception object exists until the last handler for the exception completes. The type of the object is the static type of the thrown expression.</p></li><li><p><a href="172-18.2._namespaces.html#filepos4961358" id="filepos5108719"><strong>file static</strong></a> Name local to a file that is declared with the <code>static</code> keyword. In C and pre-Standard versions of C++, file statics were used to declare objects that could be used in a single file only. File statics are deprecated in C++, having been superseded by the use of unnamed namespaces.</p></li><li><p><a href="171-18.1._exception_handling.html#filepos4892438" id="filepos5109234"><strong>function try block</strong></a> Used to catch exceptions from a constructor initializer. The keyword <code>try</code> appears before the colon that starts the constructor initializer list (or before the open curly of the constructor body if the initizlier list is empty) and closes with one or more <code>catch</code> clauses that appear after the close curly of the constructor body.</p></li><li><p><a href="172-18.2._namespaces.html#filepos4948788" id="filepos5109867"><strong>global namespace</strong></a> The (implicit) namespace in each program that holds all global definitions.</p></li><li><p><a href="171-18.1._exception_handling.html#filepos4856792" id="filepos5110121"><strong>handler</strong></a> Synonym for a <code>catch</code> clause.</p></li><li><p><a href="172-18.2._namespaces.html#filepos4952905" id="filepos5110381"><strong>inline namespace</strong></a> Members of a namespace designated as <code>inline</code> can be used as if they were members of an enclosing namespace.</p></li><li><p><a href="173-18.3._multiple_and_virtual_inheritance.html#filepos5026929" id="filepos5110729"><strong>multiple inheritance</strong></a> Class with more than one direct base class. The derived class inherits the members of all its base classes. A separate access specifier may be provided for each base class.</p></li><li><p><a href="172-18.2._namespaces.html#filepos4929726" id="filepos5111084"><strong>namespace</strong></a> Mechanism for gathering all the names defined by a library or other collection of programs into a single scope. Unlike other scopes in C++, a namespace scope may be defined in several parts. The namepsace may be opened and closed and reopened again in disparate parts of the program.</p></li><li><p><a href="172-18.2._namespaces.html#filepos4965437" id="filepos5111539"><strong>namespace alias</strong></a> Mechanism for defining a synonym for a given namespace:</p></li>

```c++
namespace N1 = N;
```

<li><p>defines <code>N1</code> as another name for the namespace named <code>N</code>. A namespace can have multiple aliases; the namespace name or any of its aliases may be used interchangeably.</p></li><li><p><a href="172-18.2._namespaces.html#filepos4928745" id="filepos5112313"><strong>namespace pollution</strong></a> Occurs when all the names of classes and functions are placed in the global namespace. Large programs that use code written by multiple independent parties often encounter collisions among names if these names are global.</p></li><li><p><a href="171-18.1._exception_handling.html#filepos4907003" id="filepos5112716"><strong>noexcept operator</strong></a> Operator that returns a <code>bool</code> indicating whether a given expression might throw an exception. The expression is unevaluated. The result is a constant expression. Its value is <code>true</code> if the expression does not contain a <code>throw</code> and calls only functions designated as nonthrowing; otherwise the result is <code>false</code>.</p></li><li><p><a href="171-18.1._exception_handling.html#filepos4897368" id="filepos5113452"><strong>noexcept specification</strong></a> Keyword used to indicate whether a function throws. When <code>noexcept</code> follows a function’s parameter list, it may be optionally followed by a parenthesized constant expression that must be convertible to <code>bool</code>. If the expression is omitted, or if it is <code>true</code>, the function throws no exceptions. An expression that is <code>false</code> or a function that has no exception specification may throw any exception.</p></li><li><p><a id="filepos5114286"></a><a href="171-18.1._exception_handling.html#filepos4898708" id="filepos5114294"><strong>nonthrowing specification</strong></a> An exception specification that promises that a function won’t throw. If a nonthrowing functions does throw, <code>terminate</code> is called. Nonthrowing specifiers are <code>noexcept</code> without an argument or with an argument that evaluates as <code>true</code> and <code>throw()</code>.</p></li><li><p><a href="171-18.1._exception_handling.html#filepos4856590" id="filepos5114981"><strong>raise</strong></a> Often used as a synonym for throw. C++ programmers speak of “throwing” or “raising” an exception interchangably.</p></li><li><p><a href="171-18.1._exception_handling.html#filepos4881200" id="filepos5115285"><strong>rethrow</strong></a> A <code>throw</code> that does not specify an expression. A rethrow is valid only from inside a <code>catch</code> clause, or in a function called directly or indirectly from a <code>catch</code>. Its effect is to rethrow the exception object that it received.</p></li><li><p><a href="171-18.1._exception_handling.html#filepos4861240" id="filepos5115865"><strong>stack unwinding</strong></a> The process whereby the functions are exited in the search for a <code>catch</code>. Local objects constructed before the exception are destroyed before entering the corresponding <code>catch</code>.</p></li><li><p><a href="171-18.1._exception_handling.html#filepos4862918" id="filepos5116342"><strong>terminate</strong></a> Library function that is called if an exception is not caught or if an exception occurs while a handler is in process. <code>terminate</code> ends the program.</p></li><li><p><strong>throw e</strong> Expression that interrupts the current execution path. Each <code>throw</code> transfers control to the nearest enclosing <code>catch</code> clause that can handle the type of exception that is thrown. The expression <code>e</code> is copied into the exception object.</p></li><li><p><a href="171-18.1._exception_handling.html#filepos4859097" id="filepos5117274"><strong>try block</strong></a> Block of statements enclosed by the keyword <code>try</code> and one or more <code>catch</code> clauses. If the code inside the <code>try</code> block raises an exception and one of the <code>catch</code> clauses matches the type of the exception, then the exception is handled by that <code>catch</code>. Otherwise, the exception is passed out of the <code>try</code> to a <code>catch</code> further up the call chain.</p></li><li><p><a href="172-18.2._namespaces.html#filepos4957130" id="filepos5118215"><strong>unnamed namespace</strong></a> Namespace that is defined without a name. Names defined in an unnamed namespace may be accessed directly without use of the scope operator. Each file has its own unique unnamed namespace. Names in an unnamed namespace are not visible outside that file.</p></li><li><p><a href="172-18.2._namespaces.html#filepos4967941" id="filepos5118647"><strong>using declaration</strong></a> Mechanism to inject a single name from a namespace into the current scope:</p></li>

```c++
using std::cout;
```

<li><p>makes the name <code>cout</code> from the namespace <code>std</code> available in the current scope. The name <code>cout</code> can subseuquently be used without the <code>std::</code> qualifier.</p></li><li><p><a href="172-18.2._namespaces.html#filepos4969522" id="filepos5119548"><strong>using directive</strong></a> Declaration of the form</p></li>

```c++
using NS;
```

<li><p>makes <em>all</em> the names in the namespace named <code>NS</code> available in the nearest scope containing both the <code>using</code> directive and the namespace itself.</p></li><li><p><a href="173-18.3._multiple_and_virtual_inheritance.html#filepos5074015" id="filepos5120267"><strong>virtual base class</strong></a> Base class that specifies <code>virtual</code> in its own derivation list. A virtual base part occurs only once in a derived object even if the same class appears as a virtual base more than once in the hierarchy. In nonvirtual inheritance a constructor may initialize only its direct base class(es). When a class is inherited virtually, that class is initialized by the most derived class, which therefore should include an initializer for all of its virtual parent(s).</p></li><li><p><a href="173-18.3._multiple_and_virtual_inheritance.html#filepos5073804" id="filepos5120968"><strong>virtual inheritance</strong></a> Form of multiple inheritance in which derived classes share a single copy of a base that is included in the hierarchy more than once.</p></li><li><p><code>::</code>
<strong>operator</strong> Scope operator. Used to access names from a namespace or a class.</p></li>
 
</ul>

<h3 id="filepos2263761">9.3. Sequential Container Operations</h3>
<p>The sequential and associative containers differ in how they organize their elements. These differences affect how elements are stored, accessed, added, and removed. The previous section covered operations common to all containers (those listed in <a href="090-9.2._container_library_overview.html#filepos2188610">Table 9.2</a> (p. <a href="090-9.2._container_library_overview.html#filepos2188610">330</a>)). We’ll cover the operations specific to the sequential containers in the remainder of this chapter.</p>
<h4 id="filepos2264356">9.3.1. Adding Elements to a Sequential Container</h4>
<Badge type="info" text="Fundamental" />
<p>Excepting <code>array</code>, all of the library containers provide flexible memory management. We can add or remove elements dynamically changing the size of the container at run time. <a href="091-9.3._sequential_container_operations.html#filepos2265086">Table 9.5</a> (p. <a href="091-9.3._sequential_container_operations.html#filepos2265086">343</a>) lists the operations that add elements to a (non<code>array</code>) sequential container.</p>
<p><a id="filepos2265086"></a>Table 9.5. Operations That Add Elements to a Sequential Container</p>

::: info
* These operations change the size of the container; they are not supported by `array`.
* `forward_list` has special versions of insert and emplace; see § 9.3.4 (p. 350).
* `push_back` and `emplace_back` not valid for `forward_list`.
* `push_front` and `emplace_front` not valid for `vector` or `string`.
:::

| Expression                                | Explanation                                                                                                                                                                                                                                           |
|-------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `c.push_back(t)` `c.emplace_back(args)`   | Creates an clement with value `t` or constructed from `args` at the end of `c`. Returns `void`.                                                                                                                                                       |
| `c.push_front(t)` `c.emplace_front(args)` | Creates an clement with value `t` or constructed from `args` at the front of `c`. Returns `void`.                                                                                                                                                     |
| `c.insert(t)` `c.emplace(args)`           | Creates an element with value `t` or constructed from `args` before the element denoted by iterator `p`. Returns an iterator referring to the element that was added.                                                                                 |
| `c.insert(p, n, t)`                       | Inserts `n` elements with value `t` before the element denoted by iterator `p`. Returns an iterator to the first element inserted; if `n` is zero, returns `p`.                                                                                       |
| `c.insert(p, b, e)`                       | Inserts the elements from the range denoted by iterators `b` and `e` before the element denoted by iterator `p`. `b` and `e` may not refer to elements in `c`. Returns an iterator to the first element inserted; if the range is empty, returns `p`. |
| `c.insert(p, il)`                         | `il` is a braced list of element values. Inserts the given values before the element denoted by the iterator `p`. Returns an iterator to the first inserted element; if the list is empty returns `p`.                                                |

::: warning
Adding elements to a `vector`, `string`, or `deque` potentially invalidates all existing
wanna iterators, references, and pointers into the container.
:::

<p>When we use these operations, we must remember that the containers use different strategies for allocating elements and that these strategies affect performance. Adding elements anywhere but at the end of a <code>vector</code> or <code>string</code>, or anywhere but the beginning or end of a <code>deque</code>, requires elements to be moved. <a id="filepos2265807"></a>Moreover, adding elements to a <code>vector</code> or a <code>string</code> may cause the entire object to be reallocated. Reallocating an object requires allocating new memory and moving elements from the old space to the new.</p>
<h5>Using <code>push_back</code></h5>
<p>In § <a href="032-3.3._library_vector_type.html#filepos767585">3.3.2</a> (p. <a href="032-3.3._library_vector_type.html#filepos767585">100</a>) we saw that <code>push_back</code> appends an element to the back of a <code>vector</code>. Aside from <code>array</code> and <code>forward_list</code>, every sequential container (including the <code>string</code> type) supports <code>push_back</code>.</p>
<p>As an example, the following loop reads one <code>string</code> at a time into <code>word</code>:</p>

```c++
// read from standard input, putting each word onto the end of container
string word;
while (cin >> word)
    container.push_back(word);
```

<p>The call to <code>push_back</code> creates a new element at the end of <code>container</code>, increasing the <code>size</code> of <code>container</code> by 1. The value of that element is a copy of <code>word</code>. The type of <code>container</code> can be any of <code>list, vector</code>, or <code>deque</code>.</p>
<p>Because <code>string</code> is just a container of characters, we can use <code>push_back</code> to add characters to the end of the <code>string</code>:</p>

```c++
void pluralize(size_t cnt, string &word)
{
    if (cnt > 1)
        word.push_back('s');  // same as word += 's'
}
```

::: info
<p>Key Concept: Container Elements Are Copies</p>
<p>When we use an object to initialize a container, or insert an object into a container, a copy of that object’s value is placed in the container, not the object itself. Just as when we pass an object to a nonreference parameter (§ <a href="064-6.2._argument_passing.html#filepos1453096">6.2.1</a>, p. <a href="064-6.2._argument_passing.html#filepos1453096">209</a>), there is no relationship between the element in the container and the object from which that value originated. Subsequent changes to the element in the container have no effect on the original object, and vice versa.</p>
:::

<h5>Using <code>push_front</code></h5>
<p>In addition to <code>push_back</code>, the <code>list</code>, <code>forward_list</code>, and <code>deque</code> containers support an analogous operation named <code>push_front</code>. This operation inserts a new element at the front of the container:</p>

```c++
list<int> ilist;
// add elements to the start of ilist
for (size_t ix = 0; ix != 4; ++ix)
    ilist.push_front(ix);
```

<p>This loop adds the elements <code>0</code>, <code>1</code>, <code>2</code>, <code>3</code> to the beginning of <code>ilist</code>. Each element is inserted at the <em>new beginning</em> of the <code>list</code>. That is, when we insert <code>1</code>, it goes in <a id="filepos2272668"></a>front of <code>0</code>, and <code>2</code> in front of <code>1</code>, and so forth. Thus, the elements added in a loop such as this one wind up in reverse order. After executing this loop, <code>ilist</code> holds the sequence <code>3,2,1,0</code>.</p>
<p>Note that <code>deque</code>, which like <code>vector</code> offers fast random access to its elements, provides the <code>push_front</code> member even though <code>vector</code> does not. A <code>deque</code> guarantees constant-time insert and delete of elements at the beginning and end of the container. As with <code>vector</code>, inserting elements other than at the front or back of a <code>deque</code> is a potentially expensive operation.</p>
<h5>Adding Elements at a Specified Point in the Container</h5>
<p>The <code>push_back</code> and <code>push_front</code> operations provide convenient ways to insert a single element at the end or beginning of a sequential container. More generally, the <code>insert</code> members let us insert zero or more elements at any point in the container. The <code>insert</code> members are supported for <code>vector</code>, <code>deque</code>, <code>list</code>, and <code>string</code>. <code>forward_list</code> provides specialized versions of these members that we’ll cover in § <a href="091-9.3._sequential_container_operations.html#filepos2317246">9.3.4</a> (p. <a href="091-9.3._sequential_container_operations.html#filepos2317246">350</a>).</p>
<p>Each of the <code>insert</code> functions takes an iterator as its first argument. The iterator indicates where in the container to put the element(s). It can refer to any position in the container, including one past the end of the container. Because the iterator <a id="filepos2275648"></a>might refer to a nonexistent element off the end of the container, and because it is useful to have a way to insert elements at the beginning of a container, element(s) are inserted <em>before</em> the position denoted by the iterator. For example, this statement</p>

```c++
slist.insert(iter, "Hello!"); // insert "Hello!" just before iter
```

<p>inserts a <code>string</code> with value <code>"Hello"</code> just before the element denoted by <code>iter</code>.</p>
<p>Even though some containers do not have a <code>push_front</code> operation, there is no similar constraint on <code>insert</code>. We can <code>insert</code> elements at the beginning of a container without worrying about whether the container has <code>push_front</code>:</p>

```c++
vector<string> svec;
list<string> slist;
// equivalent to calling slist.push_front("Hello!");
slist.insert(slist.begin(), "Hello!");
// no push_front on vector but we can insert before begin()
// warning: inserting anywhere but at the end of a vector might be slow
svec.insert(svec.begin(), "Hello!");
```

::: warning
<p>It is legal to insert anywhere in a <code>vector, deque</code>, or <code>string</code>. However, doing so can be an expensive operation.</p>
:::

<h5>Inserting a Range of Elements</h5>
<p>The arguments to <code>insert</code> that appear after the initial iterator argument are analogous to the container constructors that take the same parameters. The version that takes an element count and a value adds the specified number of identical elements before the given position:</p>

```c++
svec.insert(svec.end(), 10, "Anna");
```

<p>This code inserts ten elements at the end of <code>svec</code> and initializes each of those elements to the <code>string "Anna"</code>.</p>
<p>The versions of <code>insert</code> that take a pair of iterators or an initializer list insert the elements from the given range before the given position:</p>

```c++
vector<string> v = {"quasi", "simba", "frollo", "scar"};
// insert the last two elements of v at the beginning of slist
slist.insert(slist.begin(), v.end() - 2, v.end());
slist.insert(slist.end(), {"these", "words", "will",
                           "go", "at", "the", "end"});
// run-time error: iterators denoting the range to copy from
// must not refer to the same container as the one we are changing
slist.insert(slist.begin(), slist.begin(), slist.end());
```

<p>When we pass a pair of iterators, those iterators may not refer to the same container as the one to which we are adding elements.</p>
<a id="filepos2282312"></a><Badge type="tip" text="C++11" />
<p>Under the new standard, the versions of <code>insert</code> that take a count or a range return an iterator to the first element that was inserted. (In prior versions of the library, these operations returned <code>void.)</code> If the range is empty, no elements are inserted, and the operation returns its first parameter.</p>
<h5><a id="filepos2282884"></a>Using the Return from <code>insert</code></h5>
<p>We can use the value returned by <code>insert</code> to repeatedly insert elements at a specified position in the container:</p>

```c++
list<string> 1st;
auto iter = 1st.begin();
while (cin >> word)
   iter = 1st.insert(iter, word); // same as calling push_front
```

::: info
<p>It is important to understand how this loop operates—in particular, to understand why the loop is equivalent to calling <code>push_front</code>.</p>
:::

<p>Before the loop, we initialize <code>iter</code> to <code>1st.begin()</code>. The first call to <code>insert</code> takes the <code>string</code> we just read and puts it in front of the element denoted by <code>iter</code>. The value returned by <code>insert</code> is an iterator referring to this new element. We assign that iterator to <code>iter</code> and repeat the <code>while</code>, reading another word. As long as there are words to insert, each trip through the <code>while</code> inserts a new element ahead of <code>iter</code> and reassigns to <code>iter</code> the location of the newly inserted element. That element is the (new) first element. Thus, each iteration inserts an element ahead of the first element in the <code>list</code>.</p>
<h5>Using the Emplace Operations</h5>
<p>The new standard introduced three new members—<code>emplace_front, emplace</code>, and <code>emplace_back</code>—that construct rather than copy elements. These operations correspond to the <code>push_front, insert</code>, and <code>push_back</code> operations in that they let us put an element at the front of the container, in front of a given position, or at the back of the container, respectively.</p>
<a id="filepos2286643"></a><Badge type="tip" text="C++11" />
<p>When we call a push or insert member, we pass objects of the element type and those objects are copied into the container. When we call an emplace member, we pass arguments to a constructor for the element type. The emplace members use those arguments to construct an element directly in space managed by the container. For example, assuming <code>c</code> holds <code>Sales_data</code> (§ <a href="073-7.1._defining_abstract_data_types.html#filepos1802479">7.1.4</a>, p. <a href="073-7.1._defining_abstract_data_types.html#filepos1802479">264</a>) elements:</p>

```c++
// construct a Sales_data object at the end of c
// uses the three-argument Sales_data constructor
c.emplace_back("978-0590353403", 25, 15.99);
// error: there is no version of push_back that takes three arguments
c.push_back("978-0590353403", 25, 15.99);
// ok: we create a temporary Sales_data object to pass to push_back
c.push_back(Sales_data("978-0590353403", 25, 15.99));
```

<p>The call to <code>emplace_back</code> and the second call to <code>push_back</code> both create new <code>Sales_data</code> objects. In the call to <code>emplace_back</code>, that object is created directly in space managed by the container. The call to <code>push_back</code> creates a local temporary object that is pushed onto the container.</p>
<p>The arguments to an emplace function vary depending on the element type. The arguments must match a constructor for the element type:</p>
<p><a id="filepos2289837"></a></p>

```c++
// iter refers to an element in c, which holds Sales_data elements
c.emplace_back(); // uses the Sales_data default constructor
c.emplace(iter, "999-999999999"); // uses Sales_data(string)
// uses the Sales_data constructor that takes an ISBN, a count, and a price
c.emplace_front("978-0590353403", 25, 15.99);
```

::: info
<p>The <em>emplace</em> functions construct elements in the container. The arguments to these functions must match a constructor for the element type.</p>
:::

::: info
<p>Exercises Section 9.3.1</p>
<p><strong>Exercise 9.18:</strong> Write a program to read a sequence of <code>string</code>s from the standard input into a <code>deque</code>. Use iterators to write a loop to print the elements in the <code>deque</code>.</p>
<p><strong>Exercise 9.19:</strong> Rewrite the program from the previous exercise to use a <code>list</code>. List the changes you needed to make.</p>
<p><strong>Exercise 9.20:</strong> Write a program to copy elements from a <code>list&lt;int&gt;</code> into two <code>deque</code>s. The even-valued elements should go into one <code>deque</code> and the odd ones into the other.</p>
<p><strong>Exercise 9.21:</strong> Explain how the loop from page <a href="091-9.3._sequential_container_operations.html#filepos2282884">345</a> that used the return from <code>insert</code> to add elements to a <code>list</code> would work if we inserted into a <code>vector</code> instead.</p>
<p><strong>Exercise 9.22:</strong> Assuming <code>iv</code> is a <code>vector</code> of <code>int</code>s, what is wrong with the following program? How might you correct the problem(s)?</p>

```c++
vector<int>::iterator iter = iv.begin(),
                      mid = iv.begin() + iv.size()/2;
while (iter != mid)
    if (*iter == some_val)
        iv.insert(iter, 2 * some_val);
```

:::

<h4 id="filepos2294924">9.3.2. Accessing Elements</h4>
<Badge type="info" text="Fundamental" />
<p><a href="091-9.3._sequential_container_operations.html#filepos2295366">Table 9.6</a> lists the operations we can use to access elements in a sequential container. The access operations are undefined if the container has no elements.</p>
<p><a id="filepos2295366"></a>Table 9.6. Operations to Access Elements in a Sequential Container</p>

::: info
* `at` and subscript operator valid only for `string`, `vector`, `deque`, and `array`.
* `back` not valid for `forward_list`.
:::

| Expression  | Explanation                                                                                                           |
|-------------|-----------------------------------------------------------------------------------------------------------------------|
| `c.back()`  | Returns a reference to the last element in `c`. Undefined if `c` is empty.                                            |
| `c.front()` | Returns a reference to the first element in `c`. Undefined if `c` is empty.                                           |
| `c[n]`      | Returns a reference to the element indexed by the unsigned integral value `n`. Undefined if `n >= c.size()`.          |
| `c.at(n)`   | Returns a reference to the element indexed by `n`. If the index is out of range, throw’s an `out_of_range` exception. |

::: warning
Calling `front` or `back` on an empty container, like using a subscript that is out of
range, is a serious programming error.
:::

<p>Each sequential container, including <code>array</code>, has a <code>front</code> member, and all except <code>forward_list</code> also have a <code>back</code> member. These operations return a reference to the first and last element, respectively:</p>

```c++
// check that there are elements before dereferencing an iterator or calling front or back
if (!c.empty()) {
    // val and val2 are copies of the value of the first element in c
    auto val = *c.begin(), val2 = c.front();
    // val3 and val4 are copies of the of the last element in c
    auto last = c.end();
    auto val3 = *(--last); // can't decrement forward_list iterators
    auto val4 = c.back();  // not supported by forward_list
}
```

<p><a id="filepos2298247"></a>This program obtains references to the first and last elements in <code>c</code> in two different ways. The direct approach is to call <code>front</code> or <code>back</code>. Indirectly, we can obtain a reference to the same element by dereferencing the iterator returned by <code>begin</code> or decrementing and then dereferencing the iterator returned by <code>end</code>.</p>
<p>Two things are noteworthy in this program: The <code>end</code> iterator refers to the (nonexistent) element one past the end of the container. To fetch the last element we must first decrement that iterator. The other important point is that before calling <code>front</code> or <code>back</code> (or dereferencing the iterators from <code>begin</code> or <code>end</code>), we check that <code>c</code> isn’t empty. If the container were empty, the operations inside the <code>if</code> would be undefined.</p>
<h5>The Access Members Return References</h5>
<p>The members that access elements in a container (i.e., <code>front</code>, <code>back</code>, subscript, and <code>at</code>) return references. If the container is a <code>const</code> object, the return is a reference to <code>const</code>. If the container is not <code>const</code>, the return is an ordinary reference that we can use to change the value of the fetched element:</p>

```c++
if (!c.empty()) {
    c.front()  = 42;      // assigns 42 to the first element in c
    auto &v =  c.back();  // get a reference to the last element
    v = 1024;             // changes the element in c
    auto v2 =  c.back();  // v2 is not a reference; it's a copy of c.back()
    v2 = 0;               // no change to the element in c
}
```

<p>As usual, if we use <code>auto</code> to store the return from one of these functions and we want to use that variable to change the element, we must remember to define our variable as a reference type.</p>
<h5>Subscripting and Safe Random Access</h5>
<p>The containers that provide fast random access (<code>string</code>, <code>vector</code>, <code>deque</code>, and <code>array</code>) also provide the subscript operator (§ <a href="032-3.3._library_vector_type.html#filepos778112">3.3.3</a>, p. <a href="032-3.3._library_vector_type.html#filepos778112">102</a>). As we’ve seen, the <a id="filepos2303373"></a>subscript operator takes an index and returns a reference to the element at that position in the container. The index must be “in range,” (i.e., greater than or equal to 0 and less than the size of the container). It is up to the program to ensure that the index is valid; the subscript operator does not check whether the index is in range. Using an out-of-range value for an index is a serious programming error, but one that the compiler will not detect.</p>
<p>If we want to ensure that our index is valid, we can use the <code>at</code> member instead. The <code>at</code> member acts like the subscript operator, but if the index is invalid, <code>at</code> throws an <code>out_of_range</code> exception (§ <a href="059-5.6._try_blocks_and_exception_handling.html#filepos1368051">5.6</a>, p. <a href="059-5.6._try_blocks_and_exception_handling.html#filepos1368051">193</a>):</p>

```c++
vector<string> svec; // empty vector
cout << svec[0];     // run-time error: there are no elements in svec!
cout << svec.at(0);  // throws an out_of_range exception
```

::: info
<p>Exercises Section 9.3.2</p>
<p><strong>Exercise 9.23:</strong> In the first program in this section on page <a href="091-9.3._sequential_container_operations.html#filepos2289837">346</a>, what would the values of <code>val</code>, <code>val2, val3</code>, and <code>val4</code> be if <code>c.size()</code> is <code>1</code>?</p>
<p><strong>Exercise 9.24:</strong> Write a program that fetches the first element in a <code>vector</code> using <code>at</code>, the subscript operator, <code>front</code>, and <code>begin</code>. Test your program on an empty <code>vector</code>.</p>
:::

<h4 id="filepos2306887">9.3.3. Erasing Elements</h4>
<Badge type="info" text="Fundamental" />
<p>Just as there are several ways to add elements to a (non<code>array</code>) container there are also several ways to remove elements. These members are listed in <a href="091-9.3._sequential_container_operations.html#filepos2307392">Table 9.7</a>.</p>
<p><a id="filepos2307392"></a>Table 9.7. <code>erase</code> Operations on Sequential Containers</p>

::: info
* These operations change the size of the container and so are not supported by `array`.
* `forward_list` has a special version of erase; see § 9.3.4 (p. 350).
* `pop_back` not valid for `forward_list`; `pop_front` not valid for `vector` and `string`.
:::

| Expression      | Explanation                                                                                                                                                                                                             |
|-----------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `c.pop_back()`  | Removes last element in `c`. Undefined if `c` is empty. Returns `void`.                                                                                                                                                 |
| `c.pop_front()` | Removes first element in `c`. Undefined if `c` is empty. Returns `void`.                                                                                                                                                |
| `c.erase(p)`    | Removes the element denoted by the iterator `p` and returns an iterator to the element after the one deleted or the off-the-end iterator if `p` denotes the last element. Undefined if `p` is the off-the-end iterator. |
| `c.erase(b, e)` | Removes the range of elements denoted by the iterators `b` and `e`. Returns an iterator to the element after the last one that was deleted, or an off-the-end iterator if `e` is itself an off-the-end iterator.        |
| `c.clear()`     | Removes all the elements in `c`. Returns `void`.                                                                                                                                                                        |

::: warning
Removing elements anywhere but the beginning or end of a `deque` invalidates all
iterators, references, and pointers. Iterators, references, and pointers to elements after
the erasure point in a `vector` or `string` are invalidated.
:::

::: warning
<p>The members that remove elements do not check their argument(s). The programmer must ensure that element(s) exist before removing them.</p>
:::

<h5>The <code>pop_front</code> and <code>pop_back</code> Members</h5>
<p>The <code>pop_front</code> and <code>pop_back</code> functions remove the first and last elements, respectively. Just as there is no <code>push_front</code> for <code>vector</code> and <code>string</code>, there is also no <code>pop_front</code> for those types. Similarly, <code>forward_list</code> does not have <code>pop_back</code>. Like the element access members, we may not use a pop operation on an empty container.</p>
<p>These operations return <code>void</code>. If you need the value you are about to pop, you must store that value before doing the pop:</p>

```c++
while (!ilist.empty()) {
    process(ilist.front()); // do something with the current top of ilist
    ilist.pop_front();      // done; remove the first element
}
```

<h5><a id="filepos2310418"></a>Removing an Element from within the Container</h5>
<p>The <code>erase</code> members remove element(s) at a specified point in the container. We can delete a single element denoted by an iterator or a range of elements marked by a pair of iterators. Both forms of <code>erase</code> return an iterator referring to the location <em>after</em> the (last) element that was removed. That is, if <code>j</code> is the element following <code>i</code>, then <code>erase(i)</code> will return an iterator referring to <code>j</code>.</p>
<p>As an example, the following loop erases the odd elements in a <code>list</code>:</p>

```c++
list<int> lst = {0,1,2,3,4,5,6,7,8,9};
auto it = lst.begin();
while (it != lst.end())
    if (*it % 2)             // if the element is odd
        it = lst.erase(it);  // erase this element
    else
        ++it;
```

<p>On each iteration, we check whether the current element is odd. If so, we <code>erase</code> that element, setting <code>it</code> to denote the element after the one we erased. If <code>*it</code> is even, we increment <code>it</code> so we’ll look at the next element on the next iteration.</p>
<h5>Removing Multiple Elements</h5>
<p>The iterator-pair version of <code>erase</code> lets us delete a range of elements:</p>

```c++
// delete the range of elements between two iterators
// returns an iterator to the element just after the last removed element
elem1 = slist.erase(elem1, elem2); // after the call elem1 == elem2
```

<p>The iterator <code>elem1</code> refers to the first element we want to erase, and <code>elem2</code> refers to one past the last element we want to remove.</p>
<p><a id="filepos2314343"></a>To delete all the elements in a container, we can either call <code>clear</code> or pass the iterators from <code>begin</code> and <code>end</code> to <code>erase</code>:</p>

```c++
slist.clear(); // delete all the elements within the container
slist.erase(slist.begin(), slist.end()); // equivalent
```

::: info
<p>Exercises Section 9.3.3</p>
<p><strong>Exercise 9.25:</strong> In the program on page <a href="091-9.3._sequential_container_operations.html#filepos2310418">349</a> that erased a range of elements, what happens if <code>elem1</code> and <code>elem2</code> are equal? What if <code>elem2</code> or both <code>elem1</code> and <code>elem2</code> are the off-the-end iterator?</p>
<p><strong>Exercise 9.26:</strong> Using the following definition of <code>ia</code>, copy <code>ia</code> into a <code>vector</code> and into a <code>list</code>. Use the single-iterator form of <code>erase</code> to remove the elements with odd values from your <code>list</code> and the even values from your <code>vector</code>.</p>

```c++
int ia[] = { 0, 1, 1, 2, 3, 5, 8, 13, 21, 55, 89 };
```

:::

<h4 id="filepos2317246">9.3.4. Specialized <code>forward_list</code> Operations</h4>
<Badge type="danger" text="Advanced" />
<p>To understand why <code>forward_list</code> has special versions of the operations to add and remove elements, consider what must happen when we remove an element from a singly linked list. As illustrated in <a href="091-9.3._sequential_container_operations.html#filepos2318240">Figure 9.1</a>, removing an element changes the links in the sequence. In this case, removing <em>elem</em><sub>3</sub> changes <em>elem</em><sub>2</sub>; <em>elem</em><sub>2</sub> had pointed to <em>elem</em><sub>3</sub>, but after we remove <em>elem</em><sub>3</sub>, <em>elem</em><sub>2</sub> points to <em>elem</em><sub>4</sub>.</p>
<a id="filepos2318240"></a><img alt="Image" src="/images/00054.jpg"/>
<p>Figure 9.1. <code>forward_list</code> Specialized Operations</p>
<p>When we add or remove an element, the element before the one we added or removed has a different successor. To add or remove an element, we need access to its predecessor in order to update that element’s links. However, <code>forward_list</code> is a singly linked list. In a singly linked list there is no easy way to get to an element’s predecessor. For this reason, the operations to add or remove elements in a <code>forward_list</code> operate by changing the element <em>after</em> the given element. That way, we always have access to the elements that are affected by the change.</p>
<p>Because these operations behave differently from the operations on the other containers, <code>forward_list</code> does not define <code>insert</code>, <code>emplace</code>, or <code>erase</code>. Instead it defines members (listed in <a href="091-9.3._sequential_container_operations.html#filepos2320799">Table 9.8</a>) named <code>insert_after</code>, <code>emplace_after</code>, <a id="filepos2320001"></a>and <code>erase_after</code>. For example, in our illustration, to remove <em>elem</em><sub>3</sub>, we’d call <code>erase_after</code> on an iterator that denoted <em>elem</em><sub>2</sub>. To support these operations, <code>forward_list</code> also defines <code>before_begin</code>, which returns an <strong><a href="096-defined_terms.html#filepos2451895" id="filepos2320526">off-the-beginning</a></strong> iterator. This iterator lets us add or remove elements “after” the nonexistent element before the first one in the list.</p>
<p><a id="filepos2320799"></a>Table 9.8. Operations to Insert or Remove Elements in a <code>forward_list</code></p>

| Expression                                                                                                 | Explanation                                                                                                                                                                                                                                                                                                                                                                  |
|------------------------------------------------------------------------------------------------------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| `lst.before_begin()` `lst.cbefore_begin()`                                                                 | Iterator denoting the nonexistent element just before the beginning of the list. This iterator may not be dereferenced. `cbefore_begin()` returns a `const_iterator`.                                                                                                                                                                                                        |
| `lst.insert_after(p, t)` `lst.insert_after(p, n, t)` `lst.insert_after(p, b, e)` `lst.insert_after(p, il)` | Inserts element(s) after the one denoted by iterator `p`. `t` is an object, `n` is a count, `b` and `e` are iterators denoting a range (`b` and `e` must not refer to `lst`), and `il` is a braced list. Returns an iterator to the fast inserted element. If the range is empty, returns `p`. Undefined if `p` is the off-the-end iterator.                                 |
| `lst.emplace_after(p, args)`                                                                               | Uses `args` to construct an element after the one denoted by iterator `p`. Returns an iterator to the new element. Undefined if `p` is the off-the-end iterator.                                                                                                                                                                                                             |
| `lst.erase_after(p)` `lst.erase_after(b, e)`                                                               | Removes the element after the one denoted by iterator `p` or the range of elements from the one after the iterator `b` up to but not including the one denoted by `e`. Returns an iterator to the element after the one deleted, or the off-the-end iterator if there is no such element. Undefined if `p` denotes the last element in `lst` or is the off-the-end iterator. |

<p>When we add or remove elements in a <code>forward_list</code>, we have to keep track of two iterators—one to the element we’re checking and one to that element’s predecessor. As an example, we’ll rewrite the loop from page <a href="091-9.3._sequential_container_operations.html#filepos2310418">349</a> that removed the odd-valued elements from a <code>list</code> to use a <code>forward_list</code>:</p>

```c++
forward_list<int> flst = {0,1,2,3,4,5,6,7,8,9};
auto prev = flst.before_begin(); // denotes element "off the start" of flst
auto curr = flst.begin();        // denotes the first element in flst
while (curr != flst.end()) {     // while there are still elements to process
    if (*curr % 2)                     // if the element is odd
        curr = flst.erase_after(prev); // erase it and move curr
    else {
        prev = curr;            // move the iterators to denote the next
        ++curr;                 // element and one before the next element
    }
}
```

<p>Here, <code>curr</code> denotes the element we’re checking, and <code>prev</code> denotes the element before <code>curr</code>. We call <code>begin</code> to initialize <code>curr</code>, so that the first iteration checks whether the first element is even or odd. We initialize <code>prev</code> from <code>before_begin</code>, which returns an iterator to the nonexistent element just before <code>curr</code>.</p>
<p>When we find an odd element, we pass <code>prev</code> to <code>erase_after</code>. This call erases the element after the one denoted by <code>prev</code>; that is, it erases the element denoted <a id="filepos2325018"></a>by <code>curr</code>. We reset <code>curr</code> to the return from <code>erase_after</code>, which makes <code>curr</code> denote the next element in the sequence and we leave <code>prev</code> unchanged; <code>prev</code> still denotes the element before the (new) value of <code>curr</code>. If the element denoted by <code>curr</code> is not odd, then we have to move both iterators, which we do in the <code>else</code>.</p>

::: info
<p>Exercises Section 9.3.4</p>
<p><strong>Exercise 9.27:</strong> Write a program to find and remove the odd-valued elements in a <code>forward_list&lt;int&gt;</code>.</p>
<p><strong>Exercise 9.28:</strong> Write a function that takes a <code>forward_list&lt;string&gt;</code> and two additional <code>string</code> arguments. The function should find the first <code>string</code> and insert the second immediately following the first. If the first <code>string</code> is not found, then insert the second <code>string</code> at the end of the list.</p>
:::

<h4 id="filepos2327136">9.3.5. Resizing a Container</h4>
<p>With the usual exception of <code>array</code>s, we can use <code>resize</code>, described in <a href="091-9.3._sequential_container_operations.html#filepos2329363">Table 9.9</a>, to make a container larger or smaller. If the current size is greater than the requested size, elements are deleted from the back of the container; if the current size is less than the new size, elements are added to the back of the container:</p>

```c++
list<int> ilist(10, 42); // ten ints: each has value 42
ilist.resize(15);     // adds five elements of value 0 to the back of ilist
ilist.resize(25, -1); // adds ten elements of value -1 to the back of ilist
ilist.resize(5);      // erases 20 elements from the back of ilist
```

<p><a id="filepos2329363"></a>Table 9.9. Sequential Container Size Operations</p>

::: info
`resize` not valid for `array`.
:::

| Expression       | Explanation                                                                                                                                              |
|------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------|
| `c.resize(n)`    | Resize `c` so that it has `n` elements. If `n < c.size()`, the excess elements are discarded. If new elements must be added, they are value initialized. |
| `c.resize(n, t)` | Resize `c` to have `n` elements. Any elements added have value `t`.                                                                                      |

<p>The <code>resize</code> operation takes an optional element-value argument that it uses to initialize any elements that are added to the container. If this argument is absent, added elements are value initialized (§ <a href="032-3.3._library_vector_type.html#filepos744172">3.3.1</a>, p. <a href="032-3.3._library_vector_type.html#filepos744172">98</a>). If the container holds elements of a class type and <code>resize</code> adds elements, we must supply an initializer or the element type must have a default constructor.</p>

::: warning
If `resize` shrinks the container, then iterators, references, and pointers to the deleted
elements are invalidated; resize on a `vector`, `string`, or `deque` potentially invalidates all
iterators, pointers, and references.
:::

::: info
<a id="filepos2330188"></a><p>Exercises Section 9.3.5</p>
<p><strong>Exercise 9.29:</strong> Given that <code>vec</code> holds 25 elements, what does <code>vec.resize(100)</code> do? What if we next wrote <code>vec.resize(10)</code>?</p>
<p><strong>Exercise 9.30:</strong> What, if any, restrictions does using the version of <code>resize</code> that takes a single argument place on the element type?</p>
:::

<h4 id="filepos2331099">9.3.6. Container Operations May Invalidate Iterators</h4>
<Badge type="info" text="Fundamental" />
<p>Operations that add or remove elements from a container can invalidate pointers, references, or iterators to container elements. An invalidated pointer, reference, or iterator is one that no longer denotes an element. Using an invalidated pointer, reference, or iterator is a serious programming error that is likely to lead to the same kinds of problems as using an uninitialized pointer (§ <a href="023-2.3._compound_types.html#filepos409391">2.3.2</a>, p. <a href="023-2.3._compound_types.html#filepos409391">54</a>).</p>
<p>After an operation that adds elements to a container</p>
<ul><li>Iterators, pointers, and references to a <code>vector</code> or <code>string</code> are invalid if the container was reallocated. If no reallocation happens, indirect references to elements before the insertion remain valid; those to elements after the insertion are invalid.</li><li>Iterators, pointers, and references to a <code>deque</code> are invalid if we add elements anywhere but at the front or back. If we add at the front or back, iterators are invalidated, but references and pointers to existing elements are not.</li><li>Iterators, pointers, and references (including the off-the-end and the before-the-beginning iterators) to a <code>list</code> or <code>forward_list</code> remain valid,</li></ul>

<p>It should not be surprising that when we remove elements from a container, iterators, pointers, and references to the removed elements are invalidated. After all, those elements have been destroyed. After we remove an element,</p>
<ul><li>All other iterators, references, or pointers (including the off-the-end and the before-the-beginning iterators) to a <code>list</code> or <code>forward_list</code> remain valid.</li><li>All other iterators, references, or pointers to a <code>deque</code> are invalidated if the removed elements are anywhere but the front or back. If we remove elements at the back of the <code>deque</code>, the off-the-end iterator is invalidated but other iterators, references, and pointers are unaffected; they are also unaffected if we remove from the front.</li><li>All other iterators, references, or pointers to a <code>vector</code> or <code>string</code> remain valid for elements before the removal point. Note: The off-the-end iterator is always invalidated when we remove elements.</li></ul>

::: warning
<p>It is a serious run-time error to use an iterator, pointer, or reference that has been invalidated.</p>
:::

::: info
<a id="filepos2335296"></a><p>Advice: Managing Iterators</p>
<p>When you use an iterator (or a reference or pointer to a container element), it is a good idea to minimize the part of the program during which an iterator must stay valid.</p>
<p>Because code that adds or removes elements to a container can invalidate iterators, you need to ensure that the iterator is repositioned, as appropriate, after each operation that changes the container. This advice is especially important for <code>vector</code>, <code>string</code>, and <code>deque</code>.</p>
:::

<h5>Writing Loops That Change a Container</h5>
<Badge type="warning" text="Tricky" />
<p>Loops that add or remove elements of a <code>vector, string</code>, or <code>deque</code> must cater to the fact that iterators, references, or pointers might be invalidated. The program must ensure that the iterator, reference, or pointer is refreshed on each trip through the loop. Refreshing an iterator is easy if the loop calls <code>insert</code> or <code>erase</code>. Those operations return iterators, which we can use to reset the iterator:</p>

```c++
// silly loop to remove even-valued elements and insert a duplicate of odd-valued elements
vector<int> vi = {0,1,2,3,4,5,6,7,8,9};
auto iter = vi.begin(); // call begin, not cbegin because we're changing vi
while (iter != vi.end()) {
    if (*iter % 2) {
        iter = vi.insert(iter, *iter);  // duplicate the current element
        iter += 2; // advance past this element and the one inserted before it
    } else
        iter = vi.erase(iter);          // remove even elements
        // don't advance the iterator; iter denotes the element after the one we erased
}
```

<p>This program removes the even-valued elements and duplicates each odd-valued one. We refresh the iterator after both the <code>insert</code> and the <code>erase</code> because either operation can invalidate the iterator.</p>
<p>After the call to <code>erase</code>, there is no need to increment the iterator, because the iterator returned from <code>erase</code> denotes the next element in the sequence. After the call to <code>insert</code>, we increment the iterator twice. Remember, <code>insert</code> inserts <em>before</em> the position it is given and returns an iterator to the inserted element. Thus, after calling <code>insert, iter</code> denotes the (newly added) element in front of the one we are processing. We add two to skip over the element we added and the one we just processed. Doing so positions the iterator on the next, unprocessed element.</p>
<h5>Avoid Storing the Iterator Returned from <code>end</code></h5>
<Badge type="warning" text="Tricky" />
<p>When we add or remove elements in a <code>vector</code> or <code>string</code>, or add elements or remove any but the first element in a <code>deque</code>, the iterator returned by <code>end</code> is <em>always</em> invalidated. Thus, loops that add or remove elements should always call <code>end</code> rather than use a stored copy. Partly for this reason, C++ standard libraries are usually implemented so that calling <code>end()</code> is a very fast operation.</p>
<p>As an example, consider a loop that processes each element and adds a new element following the original. We want the loop to ignore the added elements, <a id="filepos2341868"></a>and to process only the original elements. After each insertion, we’ll position the iterator to denote the next original element. If we attempt to “optimize” the loop, by storing the iterator returned by <code>end()</code>, we’ll have a disaster:</p>

```c++
// disaster: the behavior of this loop is undefined
auto begin = v.begin(),
     end = v.end(); // bad idea, saving the value of the end iterator
while (begin != end) {
    // do some processing
    // insert the new value and reassign begin, which otherwise would be invalid
    ++begin;  // advance begin because we want to insert after this element
    begin = v.insert(begin, 42);  // insert the new value
    ++begin;  // advance begin past the element we just added
}
```

<p>The behavior of this code is undefined. On many implementations, we’ll get an infinite loop. The problem is that we stored the value returned by the <code>end</code> operation in a local variable named <code>end</code>. In the body of the loop, we added an element. Adding an element invalidates the iterator stored in <code>end</code>. That iterator neither refers to an element in <code>v</code> nor any longer refers to one past the last element in <code>v</code>.</p>

::: tip
<p>Don’t cache the iterator returned from <code>end()</code> in loops that insert or delete elements in a <code>deque, string</code>, or <code>vector</code>.</p>
:::

<p>Rather than storing the <code>end()</code> iterator, we must recompute it after each insertion:</p>

```c++
// safer: recalculate end on each trip whenever the loop adds/erases elements
while (begin != v.end()) {
    // do some processing
    ++begin;  // advance begin because we want to insert after this element
    begin = v.insert(begin, 42);  // insert the new value
    ++begin;  // advance begin past the element we just added
}
```

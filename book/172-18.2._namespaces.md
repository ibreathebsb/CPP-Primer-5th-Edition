<h3 id="filepos4928252">18.2. Namespaces</h3>
<p>Large programs tend to use independently developed libraries. Such libraries also tend to define a large number of global names, such as classes, functions, and templates. When an application uses libraries from many different vendors, it is almost inevitable that some of these names will clash. Libraries that put names into the global namespace are said to cause <strong><a href="175-defined_terms.html#filepos5112313" id="filepos4928745">namespace pollution</a></strong>.</p>
<p>Traditionally, programmers avoided namespace pollution by using very long names for the global entities they defined. Those names often contained a prefix indicating which library defined the name:</p>

```c++
class cplusplus_primer_Query { ... };
string cplusplus_primer_make_plural(size_t, string&);
```

<p>This solution is far from ideal: It can be cumbersome for programmers to write and read programs that use such long names.</p>
<p><strong><a href="175-defined_terms.html#filepos5111084" id="filepos4929726">Namespaces</a></strong> provide a much more controlled mechanism for preventing name collisions. Namespaces partition the global namespace. A namespace is a scope. By defining a library’s names inside a namespace, library authors (and users) can avoid the limitations inherent in global names.</p>
<h4 id="filepos4930092">18.2.1. Namespace Definitions</h4>
<p>A namespace definition begins with the keyword <code>namespace</code> followed by the namespace name. Following the namespace name is a sequence of declarations and definitions delimited by curly braces. Any declaration that can appear at global scope can be put into a namespace: classes, variables (with their initializations), functions (with their definitions), templates, and other namespaces:</p>

```c++
namespace cplusplus_primer {
    class Sales_data { / * ... * /};
    Sales_data operator+(const Sales_data&,
                         const Sales_data&);
    class Query { /* ... */ };
    class Query_base { /* ... */};
} // like blocks, namespaces do not end with a semicolon
```

<p><a id="filepos4931600"></a>This code defines a namespace named <code>cplusplus_primer</code> with four members: three classes and an overloaded <code>+</code> operator.</p>
<p>As with any name, a namespace name must be unique within the scope in which the namespace is defined. Namespaces may be defined at global scope or inside another namespace. They may not be defined inside a function or a class.</p>

::: info
<p>A namespace scope does not end with a semicolon.</p>
:::

<h5>Each Namespace Is a Scope</h5>
<p>As is the case for any scope, each name in a namespace must refer to a unique entity within that namespace. Because different namespaces introduce different scopes, different namespaces may have members with the same name.</p>
<p>Names defined in a namespace may be accessed directly by other members of the namespace, including scopes nested within those members. Code outside the namespace must indicate the namespace in which the name is defined:</p>

```c++
cplusplus_primer::Query q =
                cplusplus_primer::Query("hello");
```

<p>If another namespace (say, <code>AddisonWesley</code>) also provides a <code>Query</code> class and we want to use that class instead of the one defined in <code>cplusplus_primer</code>, we can do so by modifying our code as follows:</p>

```c++
AddisonWesley::Query q = AddisonWesley::Query("hello");
```

<h5>Namespaces Can Be Discontiguous</h5>
<p>As we saw in § <a href="158-16.5._template_specializations.html#filepos4508634">16.5</a> (p. <a href="158-16.5._template_specializations.html#filepos4508634">709</a>), unlike other scopes, a namespace can be defined in several parts. Writing a namespace definition:</p>

```c++
namespace nsp {
// declarations
}
```

<p>either defines a new namespace named <code>nsp</code> or adds to an existing one. If the name <code>nsp</code> does not refer to a previously defined namespace, then a new namespace with that name is created. Otherwise, this definition opens an existing namespace and adds declarations to that already existing namespace.</p>
<p>The fact that namespace definitions can be discontiguous lets us compose a namespace from separate interface and implementation files. Thus, a namespace can be organized in the same way that we manage our own class and function definitions:</p>
<ul><li>Namespace members that define classes, and declarations for the functions and objects that are part of the class interface, can be put into header files. These headers can be included by files that use those namespace members.</li><li>The definitions of namespace members can be put in separate source files.</li></ul>

<p><a id="filepos4936358"></a>Organizing our namespaces this way also satisfies the requirement that various entities—non-inline functions, static data members, variables, and so forth—may be defined only once in a program. This requirement applies equally to names defined in a namespace. By separating the interface and implementation, we can ensure that the functions and other names we need are defined only once, but the same declaration will be seen whenever the entity is used.</p>

::: tip
<p>Best Practices</p>
<p>Namespaces that define multiple, unrelated types should use separate files to represent each type (or each collection of related types) that the namespace defines.</p>
:::

<h5>Defining the Primer Namespace</h5>
<p>Using this strategy for separating interface and implementation, we might define the <code>cplusplus_primer</code> library in several separate files. The declarations for <code>Sales_data</code> and its related functions would be placed in <code>Sales_data.h</code>, those for the <code>Query</code> classes of <a href="141-chapter_15._objectoriented_programming.html#filepos3778984">Chapter 15</a> in <code>Query.h</code>, and so on. The corresponding implementation files would be in files such as <code>Sales_data.cc</code> and <code>Query.cc</code>:</p>

```c++
// ---- Sales_data.h----
// #includes should appear before opening the namespace
#include <string>
namespace cplusplus_primer {
    class Sales_data { /* ... */};
    Sales_data operator+(const Sales_data&,
                         const Sales_data&);
    // declarations for the remaining functions in the Sales_data interface
}
// ---- Sales_data.cc----
// be sure any #includes appear before opening the namespace
#include "Sales_data.h"

namespace cplusplus_primer {
// definitions for Sales_data members and overloaded operators
}
```

<p>A program using our library would include whichever headers it needed. The names in those headers are defined inside the <code>cplusplus_primer</code> namespace:</p>

```c++
// ---- user.cc----
// names in the Sales_data.h header are in the cplusplus_primer namespace
#include "Sales_data.h"

int main()
{
    using cplusplus_primer::Sales_data;
    Sales_data trans1, trans2;
    // ...
    return 0;
}
```

<p>This program organization gives the developers and the users of our library the needed modularity. Each class is still organized into its own interface and <a id="filepos4941806"></a>implementation files. A user of one class need not compile names related to the others. We can hide the implementations from our users, while allowing the files <code>Sales_data.cc</code> and <code>user.cc</code> to be compiled and linked into one program without causing any compile-time or link-time errors. Developers of the library can work independently on the implementation of each type.</p>
<p>It is worth noting that ordinarily, we do not put a <code>#include</code> inside the namespace. If we did, we would be attempting to define all the names in that header as members of the enclosing namespace. For example, if our <code>Sales_data.h</code> file opened the <code>cplusplus_primer</code> before including the <code>string</code> header our program would be in error. It would be attempting to define the <code>std</code> namespace nested inside <code>cplusplus_primer</code>.</p>
<h5>Defining Namespace Members</h5>
<p>Assuming the appropriate declarations are in scope, code inside a namespace may use the short form for names defined in the same (or in an enclosing) namespace:</p>

```c++
#include "Sales_data.h"
namespace cplusplus_primer {   // reopen cplusplus_primer
// members defined inside the namespace may use unqualified names
std::istream&
operator>>(std::istream& in, Sales_data& s) { /* ... */}
}
```

<p>It is also possible to define a namespace member outside its namespace definition. The namespace declaration of the name must be in scope, and the definition must specify the namespace to which the name belongs:</p>

```c++
// namespace members defined outside the namespace must use qualified names
cplusplus_primer::Sales_data
cplusplus_primer::operator+(const Sales_data& lhs,
                            const Sales_data& rhs)
{
    Sales_data ret(lhs);
    // ...
}
```

<p>As with class members defined outside a class, once the fully qualified name is seen, we are in the scope of the namespace. Inside the <code>cplusplus_primer</code> namespace, we can use other namespace member names without qualification. Thus, even though <code>Sales_data</code> is a member of the <code>cplusplus_primer</code> namespace, we can use its unqualified name to define the parameters in this function.</p>
<p>Although a namespace member can be defined outside its namespace, such definitions must appear in an enclosing namespace. That is, we can define the <code>Sales_data operator+</code> inside the <code>cplusplus_primer</code> namespace or at global scope. We cannot define this operator in an unrelated namespace.</p>
<h5>Template Specializations</h5>
<p>Template specializations must be defined in the same namespace that contains the original template (§ <a href="158-16.5._template_specializations.html#filepos4508634">16.5</a>, p. <a href="158-16.5._template_specializations.html#filepos4508634">709</a>). As with any other namespace name, so long as <a id="filepos4946800"></a>we have declared the specialization inside the namespace, we can define it outside the namespace:</p>

```c++
// we must declare the specialization as a member of std
namespace std {
    template <> struct hash<Sales_data>;
}
// having added the declaration for the specialization to std
// we can define the specialization outside the std namespace
template <> struct std::hash<Sales_data>
{
    size_t operator()(const Sales_data& s) const
    { return hash<string>()(s.bookNo) ^
             hash<unsigned>()(s.units_sold) ^
             hash<double>()(s.revenue); }
    // other members as before
};
```

<h5>The Global Namespace</h5>
<p>Names defined at global scope (i.e., names declared outside any class, function, or namespace) are defined inside the <strong><a href="175-defined_terms.html#filepos5109867" id="filepos4948788">global namespace</a></strong>. The global namespace is implicitly declared and exists in every program. Each file that defines entities at global scope (implicitly) adds those names to the global namespace.</p>
<p>The scope operator can be used to refer to members of the global namespace. Because the global namespace is implicit, it does not have a name; the notation</p>

```c++
::member_name
```

<p>refers to a member of the global namespace.</p>
<h5>Nested Namespaces</h5>
<p>A nested namespace is a namespace defined inside another namespace:</p>

```c++
namespace cplusplus_primer {
    // first nested namespace: defines the Query portion of the library
    namespace QueryLib {
        class Query { /* ... */ };
        Query operator&(const Query&, const Query&);
        // ...
    }
    // second nested namespace: defines the Sales_data portion of the library
    namespace Bookstore {
        class Quote { /* ... */ };
        class Disc_quote : public Quote { /* ... */ };
        // ...
    }
}
```

<p>The <code>cplusplus_primer</code> namespace now contains two nested namespaces: the namespaces named <code>QueryLib</code> and <code>Bookstore</code>.</p>
<p><a id="filepos4951703"></a>A nested namespace is a nested scope—its scope is nested within the namespace that contains it. Nested namespace names follow the normal rules: Names declared in an inner namespace hide declarations of the same name in an outer namespace. Names defined inside a nested namespace are local to that inner namespace. Code in the outer parts of the enclosing namespace may refer to a name in a nested namespace only through its qualified name: For example, the name of the class declared in the nested namespace <code>QueryLib</code> is</p>

```c++
cplusplus_primer::QueryLib::Query
```

<h5>Inline Namespaces</h5>
<a id="filepos4952747"></a><img alt="Image" src="/images/00008.jpg"/>
<p>The new standard introduced a new kind of nested namespace, an <strong><a href="175-defined_terms.html#filepos5110381" id="filepos4952905">inline namespace</a></strong>. Unlike ordinary nested namespaces, names in an inline namespace can be used as if they were direct members of the enclosing namespace. That is, we need not qualify names from an inline namespace by their namespace name. We can access them using only the name of the enclosing namespace.</p>
<p>An inline namespace is defined by preceding the keyword <code>namespace</code> with the keyword <code>inline</code>:</p>

```c++
inline namespace FifthEd {
    // namespace for the code from the Primer Fifth Edition
}
namespace FifthEd { // implicitly inline
    class Query_base { /* ... * /};
    // other Query-related declarations
}
```

<p>The keyword must appear on the first definition of the namespace. If the namespace is later reopened, the keyword <code>inline</code> need not be, but may be, repeated.</p>
<p>Inline namespaces are often used when code changes from one release of an application to the next. For example, we can put all the code from the current edition of the Primer into an inline namespace. Code for previous versions would be in non-inlined namespaces:</p>

```c++
namespace FourthEd {
    class Item_base { /* ... */};
    class Query_base { /* ... */};
    // other code from the Fourth Edition
}
```

<p>The overall <code>cplusplus_primer</code> namespace would include the definitions of both namespaces. For example, assuming that each namespace was defined in a header with the corresponding name, we’d define <code>cplusplus_primer</code> as follows:</p>

```c++
namespace cplusplus_primer {
#include "FifthEd.h"
#include "FourthEd.h"
}
```

<p><a id="filepos4956469"></a>Because <code>FifthEd</code> is inline, code that refers to <code>cplusplus_primer::</code> will get the version from that namespace. If we want the earlier edition code, we can access it as we would any other nested namespace, by using the names of all the enclosing namespaces: for example, <code>cplusplus_primer::FourthEd::Query_base</code>.</p>
<h5>Unnamed Namespaces</h5>
<p>An <strong><a href="175-defined_terms.html#filepos5118215" id="filepos4957130">unnamed namespace</a></strong> is the keyword <code>namespace</code> followed immediately by a block of declarations delimited by curly braces. Variables defined in an unnamed namespace have static lifetime: They are created before their first use and destroyed when the program ends.</p>
<p>An unnamed namespace may be discontiguous within a given file but does not span files. Each file has its own unnamed namespace. If two files contain unnamed namespaces, those namespaces are unrelated. Both unnamed namespaces can define the same name; those definitions would refer to different entities. If a header defines an unnamed namespace, the names in that namespace define different entities local to each file that includes the header.</p>

::: info
<p>Unlike other namespaces, an unnamed namespace is local to a particular file and never spans multiple files.</p>
:::

<p>Names defined in an unnamed namespace are used directly; after all, there is no namespace name with which to qualify them. It is not possible to use the scope operator to refer to members of unnamed namespaces.</p>
<p>Names defined in an unnamed namespace are in the same scope as the scope at which the namespace is defined. If an unnamed namespace is defined at the outermost scope in the file, then names in the unnamed namespace must differ from names defined at global scope:</p>

```c++
int i;   // global declaration for i
namespace {
    int i;
}
// ambiguous: defined globally and in an unnested, unnamed namespace
i = 10;
```

<p>In all other ways, the members of an unnamed namespace are normal program entities. An unnamed namespace, like any other namespace, may be nested inside another namespace. If the unnamed namespace is nested, then names in it are accessed in the normal way, using the enclosing namespace name(s):</p>

```c++
namespace local {
    namespace {
        int i;
    }
}
// ok: i defined in a nested unnamed namespace is distinct from global i
local::i = 42;
```

::: warning
<a id="filepos4960971"></a><p>Unnamed Namespaces Replace File Statics</p>
<p>Prior to the introduction of namespaces, programs declared names as <code>static</code> to make them local to a file. The use of <em><a href="175-defined_terms.html#filepos5108719" id="filepos4961358">file statics</a></em> is inherited from C. In C, a global entity declared <code>static</code> is invisible outside the file in which it is declared.</p>
<p>The use of file <code>static</code> declarations is deprecated by the C++ standard. File statics should be avoided and unnamed namespaces used instead.</p>
:::

::: info
<p>Exercises Section 18.2.1</p>
<p><strong>Exercise 18.12:</strong> Organize the programs you have written to answer the questions in each chapter into their own namespaces. That is, namespace <code>chapter15</code> would contain code for the <code>Query</code> programs and <code>chapter10</code> would contain the <code>TextQuery</code> code. Using this structure, compile the <code>Query</code> code examples.</p>
<p><strong>Exercise 18.13:</strong> When might you use an unnamed namespace?</p>
<p><strong>Exercise 18.14:</strong> Suppose we have the following declaration of the <code>operator*</code> that is a member of the nested namespace <code>mathLib::MatrixLib</code>:</p>

```c++
namespace mathLib {
    namespace MatrixLib {
        class matrix { /* ... */ };
        matrix operator*
               (const matrix &, const matrix &);
        // ...
    }
}
```

<p>How would you declare this operator in global scope?</p>
:::

<h4 id="filepos4964533">18.2.2. Using Namespace Members</h4>
<p>Referring to namespace members as <code>namespace_name::member_name</code> is admittedly cumbersome, especially if the namespace name is long. Fortunately, there are ways to make it easier to use namespace members. Our programs have used one of these ways, <code>using</code> declarations (§ <a href="030-3.1._namespace_using_declarations.html#filepos638596">3.1</a>, p. <a href="030-3.1._namespace_using_declarations.html#filepos638596">82</a>). The others, namespace aliases and <code>using</code> directives, will be described in this section.</p>
<h5>Namespace Aliases</h5>
<p>A <strong><a href="175-defined_terms.html#filepos5111539" id="filepos4965437">namespace alias</a></strong> can be used to associate a shorter synonym with a namespace name. For example, a long namespace name such as</p>

```c++
namespace cplusplus_primer      { /* ... */ };
```

<p>can be associated with a shorter synonym as follows:</p>

```c++
namespace primer = cplusplus_primer;
```

<p><a id="filepos4966330"></a>A namespace alias declaration begins with the keyword <code>namespace</code>, followed by the alias name, followed by the <code>=</code> sign, followed by the original namespace name and a semicolon. It is an error if the original namespace name has not already been defined as a namespace.</p>
<p>A namespace alias can also refer to a nested namespace:</p>

```c++
namespace Qlib = cplusplus_primer::QueryLib;
Qlib::Query q;
```

::: info
<p>A namespace can have many synonyms, or aliases. All the aliases and the original namespace name can be used interchangeably.</p>
:::

<h5><code>using</code> Declarations: A Recap</h5>
<p>A <a href="175-defined_terms.html#filepos5118647" id="filepos4967941"><code>using</code>
<strong>declaration</strong></a> introduces only one namespace member at a time. It allows us to be very specific regarding which names are used in our programs.</p>
<p>Names introduced in a <code>using</code> declaration obey normal scope rules: They are visible from the point of the <code>using</code> declaration to the end of the scope in which the declaration appears. Entities with the same name defined in an outer scope are hidden. The unqualified name may be used only within the scope in which it is declared and in scopes nested within that scope. Once the scope ends, the fully qualified name must be used.</p>
<p>A <code>using</code> declaration can appear in global, local, namespace, or class scope. In class scope, such declarations may only refer to a base class member (§ <a href="146-15.5._access_control_and_inheritance.html#filepos3901534">15.5</a>, p. <a href="146-15.5._access_control_and_inheritance.html#filepos3901534">615</a>).</p>
<h5><code>using</code> Directives</h5>
<p>A <a href="175-defined_terms.html#filepos5119548" id="filepos4969522"><code>using</code>
<strong>directive</strong></a>, like a <code>using</code> declaration, allows us to use the unqualified form of a namespace name. Unlike a <code>using</code> declaration, we retain no control over which names are made visible—they all are.</p>
<p>A <code>using</code> directive begins with the keyword <code>using</code>, followed by the keyword <code>namespace</code>, followed by a namespace name. It is an error if the name is not a previously defined namespace name. A <code>using</code> directive may appear in global, local, or namespace scope. It may not appear in a class scope.</p>
<p>These directives make all the names from a specific namespace visible without qualification. The short form names can be used from the point of the <code>using</code> directive to the end of the scope in which the <code>using</code> directive appears.</p>

::: warning
<p>Providing a <code>using</code> directive for namespaces, such as <code>std</code>, that our application does not control reintroduces all the name collision problems inherent in using multiple libraries.</p>
:::

<h5><code>using</code> Directives and Scope</h5>
<p>The scope of names introduced by a <code>using</code> directive is more complicated than the scope of names in <code>using</code> declarations. As we’ve seen, a <code>using</code> declaration puts the name in the same scope as that of the <code>using</code> declaration itself. It is as if the <code>using</code> declaration declares a local alias for the namespace member.</p>
<p><a id="filepos4972677"></a>A <code>using</code> directive does not declare local aliases. Rather, it has the effect of lifting the namespace members into the nearest scope that contains both the namespace itself and the <code>using</code> directive.</p>
<p>This difference in scope between a <code>using</code> declaration and a <code>using</code> directive stems directly from how these two facilities work. In the case of a <code>using</code> declaration, we are simply making name directly accessible in the local scope. In contrast, a <code>using</code> directive makes the entire contents of a namespace available In general, a namespace might include definitions that cannot appear in a local scope. As a consequence, a <code>using</code> directive is treated as if it appeared in the nearest enclosing namespace scope.</p>
<p>In the simplest case, assume we have a namespace <code>A</code> and a function <code>f</code>, both defined at global scope. If <code>f</code> has a <code>using</code> directive for <code>A</code>, then in <code>f</code> it will be as if the names in <code>A</code> appeared in the global scope prior to the definition of <code>f</code>:</p>

```c++
// namespace A and function f are defined at global scope
namespace A {
    int i, j;
}
void f()
{
    using namespace A;     // injects the names from A into the global scope
    cout << i *  j << endl; // uses i and j from namespace A
    // ...
}
```

<h5><code>using</code> Directives Example</h5>
<p>Let’s look at an example:</p>

```c++
namespace blip {
    int i = 16, j = 15, k = 23;
    // other declarations
}
int j = 0; // ok: j inside blip is hidden inside a namespace
void manip()
{
    // using directive; the names in blip are ''added'' to the global scope
    using namespace blip; // clash between ::j and blip::j
                          // detected only if j is used
    ++i;        // sets blip::i to 17
    ++j;        // error ambiguous: global j or blip::j?
    ++::j;      // ok: sets global j to 1
    ++blip::j;  // ok: sets blip::j to 16
    int k = 97; // local k hides blip::k
    ++k;        // sets local k to 98
}
```

<p>The <code>using</code> directive in <code>manip</code> makes all the names in <code>blip</code> directly accessible; code inside <code>manip</code> can refer to the names of these members, using their short form.</p>
<p><a id="filepos4981282"></a>The members of <code>blip</code> appear as if they were defined in the scope in which both <code>blip</code> and <code>manip</code> are defined. Assuming <code>manip</code> is defined at global scope, then the members of <code>blip</code> appear as if they were declared in global scope.</p>
<p>When a namespace is injected into an enclosing scope, it is possible for names in the namespace to conflict with other names defined in that (enclosing) scope. For example, inside <code>manip</code>, the <code>blip</code> member <code>j</code> conflicts with the global object named <code>j</code>. Such conflicts are permitted, but to use the name, we must explicitly indicate which version is wanted. Any unqualified use of <code>j</code> within <code>manip</code> is ambiguous.</p>
<p>To use a name such as <code>j</code>, we must use the scope operator to indicate which name is wanted. We would write <code>::j</code> to obtain the variable defined in global scope. To use the <code>j</code> defined in <code>blip</code>, we must use its qualified name, <code>blip::j</code>.</p>
<p>Because the names are in different scopes, local declarations within <code>manip</code> may hide some of the namespace member names. The local variable <code>k</code> hides the namespace member <code>blip::k</code>. Referring to <code>k</code> within <code>manip</code> is not ambiguous; it refers to the local variable <code>k</code>.</p>
<h5>Headers and <code>using</code> Declarations or Directives</h5>
<p>A header that has a <code>using</code> directive or declaration at its top-level scope injects names into every file that includes the header. Ordinarily, headers should define only the names that are part of its interface, not names used in its own implementation. As a result, header files should not contain <code>using</code> directives or <code>using</code> declarations except inside functions or namespaces (§ <a href="030-3.1._namespace_using_declarations.html#filepos638596">3.1</a>, p. <a href="030-3.1._namespace_using_declarations.html#filepos638596">83</a>).</p>

::: warning
<p>Caution: Avoid <code>using</code> Directives</p>
<p><code>using</code> directives, which inject all the names from a namespace, are deceptively simple to use: With only a single statement, all the member names of a namespace are suddenly visible. Although this approach may seem simple, it can introduce its own problems. If an application uses many libraries, and if the names within these libraries are made visible with <code>using</code> directives, then we are back to square one, and the global namespace pollution problem reappears.</p>
<p>Moreover, it is possible that a working program will fail to compile when a new version of the library is introduced. This problem can arise if a new version introduces a name that conflicts with a name that the application is using.</p>
<p>Another problem is that ambiguity errors caused by <code>using</code> directives are detected only at the point of use. This late detection means that conflicts can arise long after introducing a particular library. If the program begins using a new part of the library, previously undetected collisions may arise.</p>
<p>Rather than relying on a <code>using</code> directive, it is better to use a <code>using</code> declaration for each namespace name used in the program. Doing so reduces the number of names injected into the namespace. Ambiguity errors caused by <code>using</code> declarations are detected at the point of declaration, not use, and so are easier to find and fix.</p>
:::
::: tip
<p>One place where <code>using</code> directives are useful is in the implementation files of the namespace itself.</p>
:::

::: info
<a id="filepos4987746"></a><p>Exercises Section 18.2.2</p>
<p><strong>Exercise 18.15:</strong> Explain the differences between <code>using</code> declarations and directives.</p>
<p><strong>Exercise 18.16:</strong> Explain the following code assuming <code>using</code> declarations for all the members of namespace <code>Exercise</code> are located at the location labeled <em>position 1.</em> What if they appear at <em>position 2</em> instead? Now answer the same question but replace the <code>using</code> declarations with a <code>using</code> directive for namespace <code>Exercise</code>.</p>

```c++
namespace Exercise {
    int ivar = 0;
    double dvar = 0;
    const int limit = 1000;
}
int ivar = 0;
// position 1
void manip() {
    // position 2
    double dvar = 3.1416;
    int iobj = limit + 1;
    ++ivar;
    ++::ivar;
}
```

<p><strong>Exercise 18.17:</strong> Write code to test your answers to the previous question.</p>
:::

<h4 id="filepos4989992">18.2.3. Classes, Namespaces, and Scope</h4>
<p>Name lookup for names used inside a namespace follows the normal lookup rules: The search looks outward through the enclosing scopes. An enclosing scope might be one or more nested namespaces, ending in the all-encompassing global namespace. Only names that have been declared before the point of use that are in blocks that are still open are considered:</p>

```c++
namespace A {
    int i;
    namespace B {
        int i;         // hides A::i within B
        int j;
        int f1()
        {
            int j;    // j is local to f1 and hides A::B::j
            return i; // returns B::i
        }
    }  // namespace B is closed and names in it are no longer visible
    int f2() {
       return j;      // error: j is not defined
    }
    int j = i;        // initialized from A::i
}
```

<p><a id="filepos4993189"></a>When a class is wrapped in a namespace, the normal lookup still happens: When a name is used by a member function, look for that name in the member first, then within the class (including base classes), then look in the enclosing scopes, one or more of which might be a namespace:</p>

```c++
namespace A {
    int i;
    int k;

    class C1 {
    public:
        C1(): i(0), j(0) { }   // ok: initializes C1::i and C1::j
        int f1() { return k; } // returns A::k
        int f2() { return h; } // error: h is not defined
        int f3();
    private:
        int i;                 // hides A::i within C1
        int j;
    };
    int h = i;                 // initialized from A::i
}
// member f3 is defined outside class C1 and outside namespace A
int A::C1::f3() { return h; }  // ok: returns A::h
```

<p>With the exception of member function definitions that appear inside the class body (§ <a href="076-7.4._class_scope.html#filepos1931587">7.4.1</a>, p. <a href="076-7.4._class_scope.html#filepos1931587">283</a>), scopes are always searched upward; names must be declared before they can be used. Hence, the <code>return</code> in <code>f2</code> will not compile. It attempts to reference the name <code>h</code> from namespace <code>A</code>, but <code>h</code> has not yet been defined. Had that name been defined in <code>A</code> before the definition of <code>C1</code>, the use of <code>h</code> would be legal. Similarly, the use of <code>h</code> inside <code>f3</code> is okay, because <code>f3</code> is defined after <code>A::h</code>.</p>

::: tip
<p>The order in which scopes are examined to find a name can be inferred from the qualified name of a function. The qualified name indicates, in reverse order, the scopes that are searched.</p>
:::

<p>The qualifiers <code>A::C1::f3</code> indicate the reverse order in which the class scopes and namespace scopes are to be searched. The first scope searched is that of the function <code>f3</code>. Then the class scope of its enclosing class <code>C1</code> is searched. The scope of the namespace <code>A</code> is searched last before the scope containing the definition of <code>f3</code> is examined.</p>
<h5>Argument-Dependent Lookup and Parameters of Class Type</h5>
<img alt="Image" src="/images/00011.jpg"/>
<p>Consider the following simple program:</p>

```c++
std::string s;
std::cin >> s;
```

<p>As we know, this call is equivalent to (§ <a href="130-14.1._basic_concepts.html#filepos3549336">14.1</a>, p. <a href="130-14.1._basic_concepts.html#filepos3549336">553</a>):</p>

```c++
operator>>(std::cin, s);
```

<p><a id="filepos4999892"></a>This <code>operator&gt;&gt;</code> function is defined by the <code>string</code> library, which in turn is defined in the <code>std</code> namespace. Yet we can we call <code>operator&gt;&gt;</code> without an <code>std::</code> qualifier and without a <code>using</code> declaration.</p>
<p>We can directly access the output operator because there is an important exception to the rule that names defined in a namespace are hidden. When we pass an object of a class type to a function, the compiler searches the namespace in which the argument’s class is defined <em>in addition</em> to the normal scope lookup. This exception also applies for calls that pass pointers or references to a class type.</p>
<p>In this example, when the compiler sees the “call” to <code>operator&gt;&gt;</code>, it looks for a matching function in the current scope, including the scopes enclosing the output statement. In addition, because the <code>&gt;&gt;</code> expression has parameters of class type, the compiler also looks in the namespace(s) in which the types of <code>cin</code> and <code>s</code> are defined. Thus, for this call, the compiler looks in the <code>std</code> namespace, which defines the <code>istream</code> and <code>string</code> types. When it searches <code>std</code>, the compiler finds the <code>string</code> output operator function.</p>
<p>This exception in the lookup rules allows nonmember functions that are conceptually part of the interface to a class to be used without requiring a separate <code>using</code> declaration. In the absence of this exception to the lookup rules, either we would have to provide an appropriate <code>using</code> declaration for the output operator:</p>

```c++
using std::operator>>;         // needed to allow cin >> s
```

<p>or we would have to use the function-call notation in order to include the namespace qualifer:</p>

```c++
std::operator>>(std::cin, s); // ok: explicitly use std::>>
```

<p>There would be no way to use operator syntax. Either of these declarations is awkward and would make simple uses of the IO library more complicated.</p>
<h5>Lookup and <code>std::move</code> and <code>std::forward</code></h5>
<p>Many, perhaps even most, C++ programmers never have to think about argument-dependent lookup. Ordinarily, if an application defines a name that is also defined in the library, one of two things is true: Either normal overloading determines (correctly) whether a particular call is intended for the application version or the one from the library, or the application never intends to use the library function.</p>
<p>Now consider the library <code>move</code> and <code>forward</code> functions. Both of these functions are template functions, and the library defines versions of them that have a single rvalue reference function parameter. As we’ve seen, in a function template, an rvalue reference parameter can match any type (§ <a href="155-16.2._template_argument_deduction.html#filepos4403933">16.2.6</a>, p. <a href="155-16.2._template_argument_deduction.html#filepos4403933">690</a>). If our application defines a function named <code>move</code> that takes a single parameter, then—no matter what type the parameter has—the application’s version of <code>move</code> will collide with the library version. Similarly for <code>forward</code>.</p>
<p>As a result, name collisions with <code>move</code> (and <code>forward</code>) are more likely than collisions with other library functions. In addition, because <code>move</code> and <code>forward</code> do very specialized type manipulations, the chances that an application specifically wants to override the behavior of these functions are pretty small.</p>
<p><a id="filepos5006547"></a>The fact that collisions are more likely—and are less likely to be intentional—explains why we suggest always using the fully qualified versions of these names (§ <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos3040235">12.1.5</a>, p. <a href="114-12.1._dynamic_memory_and_smart_pointers.html#filepos3040235">470</a>). So long as we write <code>std::move</code> rather than <code>move</code>, we know that we will get the version from the standard library.</p>
<h5>Friend Declarations and Argument-Dependent Lookup</h5>
<img alt="Image" src="/images/00011.jpg"/>
<p>Recall that when a class declares a friend, the friend declaration does not make the friend visible (§ <a href="074-7.2._access_control_and_encapsulation.html#filepos1841962">7.2.1</a>, p. <a href="074-7.2._access_control_and_encapsulation.html#filepos1841962">270</a>). However, an otherwise undeclared class or function that is first named in a friend declaration is assumed to be a member of the closest enclosing namespace. The combination of this rule and argument-dependent lookup can lead to surprises:</p>

```c++
namespace A {
    class C {
        // two friends; neither is declared apart from a friend declaration
        // these functions implicitly are members of namespace A
        friend void f2();     // won't be found, unless otherwise declared
        friend void f(const C&); // found by argument-dependent lookup
    };
}
```

<p>Here, both <code>f</code> and <code>f2</code> are members of namespace <code>A</code>. Through argument-dependent lookup, we can call <code>f</code> even if there is no additional declaration for <code>f</code>:</p>

```c++
int main()
{
    A::C cobj;
    f(cobj);   // ok: finds A::f through the friend declaration in A::C
    f2();      // error: A::f2 not declared
}
```

<p>Because <code>f</code> takes an argument of a class type, and <code>f</code> is implicitly declared in the same namespace as <code>C</code>, <code>f</code> is found when called. Because <code>f2</code> has no parameter, it will not be found.</p>

::: info
<p>Exercises Section 18.2.3</p>
<p><strong>Exercise 18.18:</strong> Given the following typical definition of <code>swap</code> § <a href="123-13.3._swap.html#filepos3315883">13.3</a> (p. <a href="123-13.3._swap.html#filepos3315883">517</a>), determine which version of <code>swap</code> is used if <code>mem1</code> is a <code>string</code>. What if <code>mem1</code> is an <code>int</code>? Explain how name lookup works in both cases.</p>

```c++
void swap(T v1, T v2)
{
    using std::swap;
    swap(v1.mem1, v2.mem1);
    // swap remaining members of type T
}
```

<p><strong>Exercise 18.19:</strong> What if the call to <code>swap</code> was <code>std::swap(v1.mem1, v2.mem1)?</code></p>
:::

<h4 id="filepos5012905"><a id="filepos5012938"></a>18.2.4. Overloading and Namespaces</h4>
<p>Namespaces have two impacts on function matching (§ <a href="066-6.4._overloaded_functions.html#filepos1597234">6.4</a>, p. <a href="066-6.4._overloaded_functions.html#filepos1597234">233</a>). One of these should be obvious: A <code>using</code> declaration or directive can add functions to the candidate set. The other is much more subtle.</p>
<h5>Argument-Dependent Lookup and Overloading</h5>
<img alt="Image" src="/images/00011.jpg"/>
<p>As we saw in the previous section, name lookup for functions that have class-type arguments includes the namespace in which each argument’s class is defined. This rule also impacts how we determine the candidate set. Each namespace that defines a class used as an argument (and those that define its base classes) is searched for candidate functions. Any functions in those namespaces that have the same name as the called function are added to the candidate set. These functions are added <em>even though they otherwise are not visible at the point of the call</em>:</p>

```c++
namespace NS {
    class Quote { /* ... */ };
    void display(const Quote&) { /* ... */ }
}
// Bulk_item's base class is declared in namespace NS
class Bulk_item : public NS::Quote { /* ... */ };
int main() {
    Bulk_item book1;

    display(book1);
    return 0;
}
```

<p>The argument we passed to <code>display</code> has class type <code>Bulk_item</code>. The candidate functions for the call to <code>display</code> are not only the functions with declarations that are in scope where <code>display</code> is called, but also the functions in the namespace where <code>Bulk_item</code> and its base class, <code>Quote</code>, are declared. The function <code>display(const Quote&amp;)</code> declared in namespace <code>NS</code> is added to the set of candidate functions.</p>
<h5>Overloading and <code>using</code> Declarations</h5>
<p>To understand the interaction between <code>using</code> declarations and overloading, it is important to remember that a <code>using</code> declaration declares a name, not a specific function (§ <a href="147-15.6._class_scope_under_inheritance.html#filepos3941072">15.6</a>, p. <a href="147-15.6._class_scope_under_inheritance.html#filepos3941072">621</a>):</p>

```c++
using NS::print(int);  // error: cannot specify a parameter list
using NS::print;       // ok: using declarations specify names only
```

<p>When we write a <code>using</code> declaration for a function, all the versions of that function are brought into the current scope.</p>
<p>A <code>using</code> declaration incorporates all versions to ensure that the interface of the namespace is not violated. The author of a library provided different functions for a reason. Allowing users to selectively ignore some but not all of the functions from a set of overloaded functions could lead to surprising program behavior.</p>
<p><a id="filepos5018200"></a>The functions introduced by a <code>using</code> declaration overload any other declarations of the functions with the same name already present in the scope where the <code>using</code> declaration appears. If the <code>using</code> declaration appears in a local scope, these names hide existing declarations for that name in the outer scope. If the <code>using</code> declaration introduces a function in a scope that already has a function of the same name with the same parameter list, then the <code>using</code> declaration is in error. Otherwise, the <code>using</code> declaration defines additional overloaded instances of the given name. The effect is to increase the set of candidate functions.</p>
<h5>Overloading and <code>using</code> Directives</h5>
<p>A <code>using</code> directive lifts the namespace members into the enclosing scope. If a namespace function has the same name as a function declared in the scope at which the namespace is placed, then the namespace member is added to the overload set:</p>

```c++
namespace libs_R_us {
    extern void print(int);
    extern void print(double);
}
// ordinary declaration
void print(const std::string &);
// this using directive adds names to the candidate set for calls to print:
using namespace libs_R_us;
// the candidates for calls to print at this point in the program are:
//   print(int) from libs_R_us
//   print(double) from libs_R_us
//   print(const std::string &) declared explicitly
void fooBar(int ival)
{
    print("Value: "); // calls global print(const string &)
    print(ival);      // calls libs_R_us::print(int)
}
```

<p>Differently from how <code>using</code> declarations work, it is not an error if a <code>using</code> directive introduces a function that has the same parameters as an existing function. As with other conflicts generated by <code>using</code> directives, there is no problem unless we try to call the function without specifying whether we want the one from the namespace or from the current scope.</p>
<h5>Overloading across Multiple <code>using</code> Directives</h5>
<p>If many <code>using</code> directives are present, then the names from each namespace become part of the candidate set:</p>

```c++
namespace AW {
    int print(int);
}
namespace Primer {
    double print(double);
}
// using directives create an overload set of functions from different namespaces
using namespace AW;
using namespace Primer;
long double print(long double);
int main() {
    print(1);   // calls AW::print(int)
    print(3.1); // calls Primer::print(double)
    return 0;
}
```

<p>The overload set for the function <code>print</code> in global scope contains the functions <code>print(int), print(double)</code>, and <code>print(long double)</code>. These functions are all part of the overload set considered for the function calls in <code>main</code>, even though these functions were originally declared in different namespace scopes.</p>

::: info
<p>Exercises Section 18.2.4</p>
<p><strong>Exercise 18.20:</strong> In the following code, determine which function, if any, matches the call to <code>compute</code>. List the candidate and viable functions. What type conversions, if any, are applied to the argument to match the parameter in each viable function?</p>

```c++
namespace primerLib {
    void compute();
    void compute(const void *);
}
using primerLib::compute;
void compute(int);
void compute(double, double = 3.4);
void compute(char*, char* = 0);
void f()
{
    compute(0);
}
```

<p>What would happen if the <code>using</code> declaration were located in <code>main</code> before the call to <code>compute?</code> Answer the same questions as before.</p>
:::

---
title: "Part IV: Advanced Topics"
---

<h1 id="filepos4558192">Part IV: Advanced Topics</h1>
<p>Contents</p><ul><li><strong><a href="162-chapter_17._specialized_library_facilities.html#filepos4563206">Chapter 17 Specialized Library Facilities</a></strong></li><li><strong><a href="170-chapter_18._tools_for_large_programs.html#filepos4852546">Chapter 18 Tools for Large Programs</a></strong></li><li><strong><a href="176-chapter_19._specialized_tools_and_techniques.html#filepos5121571">Chapter 19 Specialized Tools and Techniques</a></strong></li></ul>

<p><a href="161-part_iv_advanced_topics.html#filepos4558192">Part IV</a> covers additional features that, although useful in the right context, are not needed by every C++ programmer. These features divide into two clusters: those that are useful for large-scale problems and those that are applicable to specialized problems rather than general ones. Features for specialized problems occur both in the language, the topic of <a href="176-chapter_19._specialized_tools_and_techniques.html#filepos5121571">Chapter 19</a>, and in the library, <a href="162-chapter_17._specialized_library_facilities.html#filepos4563206">Chapter 17</a>.</p>
<p>In <a href="162-chapter_17._specialized_library_facilities.html#filepos4563206">Chapter 17</a> we cover four special-purpose library facilities: the <code>bitset</code> class and three new library facilities: <code>tuple</code>s, regular expressions, and random numbers. We’ll also look at some of the less commonly used parts of the IO library.</p>
<p><a href="170-chapter_18._tools_for_large_programs.html#filepos4852546">Chapter 18</a> covers exception handling, namespaces, and multiple inheritance. These features tend to be most useful in the context of large-scale problems.</p>
<p>Even programs simple enough to be written by a single author can benefit from exception handling, which is why we introduced the basics of exception handling in <a href="053-chapter_5._statements.html#filepos1230677">Chapter 5</a>. However, the need to deal with run-time errors tends to be more important and harder to manage in problems that require large programming teams. In <a href="170-chapter_18._tools_for_large_programs.html#filepos4852546">Chapter 18</a> we review some additional useful exception-handling facilities. We also look in more detail at how exceptions are handled, and show how we can define and use our own exception classes. This section will also cover improvements from the new standard regarding specifying that a particular function will not throw.</p>
<p>Large-scale applications often use code from multiple independent vendors. Combining independently developed libraries would be difficult (if not impossible) if vendors had to put the names they define into a single namespace. Independently developed libraries would almost inevitably use names in common with one another; a name defined in one library would conflict with the use of that name in another library. To avoid name collisions, we can define names inside a <code>namespace</code>.</p>
<p>Whenever we use a name from the standard library, we are using a name defined in the namespace named <code>std</code>. <a href="170-chapter_18._tools_for_large_programs.html#filepos4852546">Chapter 18</a> shows how we can define our own namespaces.</p>
<p><a href="170-chapter_18._tools_for_large_programs.html#filepos4852546">Chapter 18</a> closes by looking at an important but infrequently used language feature: multiple inheritance. Multiple inheritance is most useful for fairly complicated inheritance hierarchies.</p>
<p><a href="176-chapter_19._specialized_tools_and_techniques.html#filepos5121571">Chapter 19</a> covers several specialized tools and techniques that are applicable to particular kinds of problems. Among the features covered in this chapter are how to redefine how memory allocation works; C++ support for run-time type identification (RTTI), which let us determine the actual type of an expression at run time; and how we can define and use pointers to class members. Pointers to class members differ from pointers to ordinary data or functions. Ordinary pointers only vary based on the type of the object or function. Pointers to members must also reflect the class to which the member belongs. We’ll also look at three additional aggregate types: unions, nested classes, and local classes. The chapter closes by looking briefly at a collection of features that are inherently nonportable: the <code>volatile</code> qualifier, bit-fields, and linkage directives.</p> 

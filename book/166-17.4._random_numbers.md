<h3 id="filepos4713529"><a id="filepos4713562"></a>17.4. Random Numbers</h3>
<a id="filepos4713641"></a><img alt="Image" src="/images/00008.jpg"/>
<p>Programs often need a source of random numbers. Prior to the new standard, both C and C++ relied on a simple C library function named <code>rand</code>. That function produces pseudorandom integers that are uniformly distributed in the range from 0 to a system-dependent maximum value that is at least 32767.</p>
<p>The <code>rand</code> function has several problems: Many, if not most, programs need random numbers in a different range from the one produced by <code>rand</code>. Some applications require random floating-point numbers. Some programs need numbers that reflect a nonuniform distribution. Programmers often introduce nonrandomness when they try to transform the range, type, or distribution of the numbers generated by <code>rand</code>.</p>
<p>The random-number library, defined in the <code>random</code> header, solves these problems through a set of cooperating classes: <strong>random-number engines</strong> and <strong>random-number distribution classes</strong>. These clases are described in <a href="166-17.4._random_numbers.html#filepos4715502">Table 17.14</a>. An engine generates a sequence of <code>unsigned</code> random numbers. A distribution uses an engine to generate random numbers of a specified type, in a given range, distributed according to a particular probability distribution.</p>
<p><a id="filepos4715502"></a>Table 17.14. Random Number Library Components</p>
<img alt="Image" src="/images/00124.jpg"/>

::: tip
<p>Best Practices</p>
<p>C++ programs should not use the library <code>rand</code> function. Instead, they should use the <code>default_random_engine</code> along with an appropriate distribution object.</p>
:::

<h4 id="filepos4716290">17.4.1. Random-Number Engines and Distribution</h4>
<p>The random-number engines are function-object classes (§ <a href="137-14.8._functioncall_operator.html#filepos3657799">14.8</a>, p. <a href="137-14.8._functioncall_operator.html#filepos3657799">571</a>) that define a call operator that takes no arguments and returns a random <code>unsigned</code> number. We can generate raw random numbers by calling an object of a random-number engine type:</p>

```c++
default_random_engine e;  // generates random unsigned integers
for (size_t i = 0; i < 10; ++i)
    // e() "calls" the object to produce the next random number
    cout << e() << " ";
```

<p>On our system, this program generates:</p>

```c++
16807 282475249 1622650073 984943658 1144108930 470211272 ...
```

<p>Here, we defined an object named <code>e</code> that has type <code>default_random_engine</code>. Inside the <code>for</code>, we call the object <code>e</code> to obtain the next random number.</p>
<p><a id="filepos4718634"></a>The library defines several random-number engines that differ in terms of their performance and quality of randomness. Each compiler designates one of these engines as the <code>default_random_engine</code> type. This type is intended to be the engine with the most generally useful properties. <a href="166-17.4._random_numbers.html#filepos4719262">Table 17.15</a> lists the engine operations and the engine types defined by the standard are listed in § <a href="190-a.3._random_numbers.html#filepos5515213">A.3.2</a> (p. <a href="190-a.3._random_numbers.html#filepos5515213">884</a>).</p>
<p><a id="filepos4719262"></a>Table 17.15. Random Number Engine Operations</p>
<img alt="Image" src="/images/00125.jpg"/>
<p>For most purposes, the output of an engine is not directly usable, which is why we described them earlier as raw random numbers. The problem is that the numbers usually span a range that differs from the one we need. <em>Correctly</em> transforming the range of a random number is surprisingly hard.</p>
<h5>Distribution Types and Engines</h5>
<p>To get a number in a specified range, we use an object of a distribution type:</p>

```c++
// uniformly distributed from 0 to 9 inclusive
uniform_int_distribution<unsigned> u(0,9);
default_random_engine e;  // generates unsigned random integers
for (size_t i = 0; i < 10; ++i)
    // u uses e as a source of numbers
    // each call returns a uniformly distributed value in the specified range
    cout << u(e) << " ";
```

<p>This code produces output such as</p>

```c++
0 1 7 4 5 2 0 6 6 9
```

<p>Here we define <code>u</code> as a <code>uniform_int_distribution&lt;unsigned&gt;</code>. That type generates uniformly distributed <code>unsigned</code> values. When we define an object of this type, we can supply the minimum and maximum values we want. In this program, <code>u(0,9)</code> says that we want numbers to be in the range <code>0</code> to <code>9</code>
<em>inclusive.</em> The random number distributions use inclusive ranges so that we can obtain every possible value of the given integral type.</p>
<p>Like the engine types, the distribution types are also function-object classes. The distribution types define a call operator that takes a random-number engine as its argument. The distribution object uses its engine argument to produce random numbers that the distribution object maps to the specified distribution.</p>
<p>Note that we pass the engine object itself, <code>u(e)</code>. Had we written the call as <code>u(e())</code>, we would have tried to pass the next value generated by <code>e</code> to <code>u</code>, which would be a compile-time error. We pass the engine, not the next result of the engine, because some distributions may need to call the engine more than once.</p>

::: info
<p>Note</p>
<p>When we refer to a <strong>random-number generator</strong>, we mean the combination of a distribution object with an engine.</p>
:::

<h5>Comparing Random Engines and the <code>rand</code> Function</h5>
<p>For readers familiar with the C library <code>rand</code> function, it is worth noting that the output of calling a <code>default_random_engine</code> object is similar to the output of <code>rand</code>. Engines deliver <code>unsigned</code> integers in a system-defined range. The range <a id="filepos4724905"></a>for <code>rand</code> is 0 to <code>RAND_MAX</code>. The range for an engine type is returned by calling the <code>min</code> and <code>max</code> members on an object of that type:</p>

```c++
cout << "min: " << e.min() << " max: " << e.max() << endl;
```

<p>On our system this program produces the following output:</p>

```c++
min: 1 max: 2147483646
```

<h5>Engines Generate a Sequence of Numbers</h5>
<p>Random number generators have one property that often confuses new users: Even though the numbers that are generated appear to be random, a given generator returns the same sequence of numbers each time it is run. The fact that the sequence is unchanging is very helpful during testing. On the other hand, programs that use random-number generators have to take this fact into account.</p>
<p>As one example, assume we need a function that will generate a <code>vector</code> of 100 random integers uniformly distributed in the range from 0 to 9. We might think we’d write this function as follows:</p>

```c++
// almost surely the wrong way to generate a vector of random integers
// output from this function will be the same 100 numbers on every call!
vector<unsigned> bad_randVec()
{
    default_random_engine e;
    uniform_int_distribution<unsigned> u(0,9);
    vector<unsigned> ret;
    for (size_t i = 0; i < 100; ++i)
        ret.push_back(u(e));
    return ret;
}
```

<p>However, this function will return the same <code>vector</code> every time it is called:</p>

```c++
vector<unsigned> v1(bad_randVec());
vector<unsigned> v2(bad_randVec());
// will print equal
cout << ((v1 == v2) ? "equal" : "not equal") << endl;
```

<p><a id="filepos4728867"></a>This code will print <code>equal</code> because the <code>vector</code>s <code>v1</code> and <code>v2</code> have the same values.</p>
<p>The right way to write our function is to make the engine and associated distribution objects <code>static</code> (§ <a href="063-6.1._function_basics.html#filepos1431793">6.1.1</a>, p. <a href="063-6.1._function_basics.html#filepos1431793">205</a>):</p>

```c++
// returns a vector of 100 uniformly distributed random numbers
vector<unsigned> good_randVec()
{
    // because engines and distributions retain state, they usually should be
    // defined as static so that new numbers are generated on each call
    static default_random_engine e;
    static uniform_int_distribution<unsigned> u(0,9);
    vector<unsigned> ret;
    for (size_t i = 0; i < 100; ++i)
        ret.push_back(u(e));
    return ret;
}
```

<p>Because <code>e</code> and <code>u</code> are <code>static</code>, they will hold their state across calls to the function. The first call will use the first 100 random numbers from the sequence <code>u(e)</code> generates, the second call will get the next 100, and so on.</p>

::: warning
<p>Warning</p>
<p>A given random-number generator always produces the same sequence of numbers. A function with a local random-number generator should make that generator (both the engine and distribution objects) <code>static</code>. Otherwise, the function will generate the identical sequence on each call.</p>
:::

<h5>Seeding a Generator</h5>
<p>The fact that a generator returns the same sequence of numbers is helpful during debugging. However, once our program is tested, we often want to cause each run of the program to generate different random results. We do so by providing a <strong><a href="169-defined_terms.html#filepos4849403" id="filepos4732550">seed</a></strong>. A seed is a value that an engine can use to cause it to start generating numbers at a new point in its sequence.</p>
<p>We can seed an engine in one of two ways: We can provide the seed when we create an engine object, or we can call the engine’s <code>seed</code> member:</p>

```c++
default_random_engine e1;             // uses the default seed
default_random_engine e2(2147483646); // use the given seed value
// e3 and e4 will generate the same sequence because they use the same seed
default_random_engine e3;        // uses the default seed value
e3.seed(32767);                  // call seed to set a new seed value
default_random_engine e4(32767); // set the seed value to 32767
for (size_t i = 0; i != 100; ++i) {
    if (e1() == e2())
        cout << "unseeded match at iteration: " << i << endl;
    if (e3() != e4())
        cout << "seeded differs at iteration: " << i << endl;
}
```

<p>Here we define four engines. The first two, <code>e1</code> and <code>e2</code>, have different seeds and <a id="filepos4735331"></a><em>should</em> generate different sequences. The second two, <code>e3</code> and <code>e4</code>, have the same seed value. These two objects <em>will</em> generate the same sequence.</p>
<p>Picking a good seed, like most things about generating good random numbers, is surprisingly hard. Perhaps the most common approach is to call the system <code>time</code> function. This function, defined in the <code>ctime</code> header, returns the number of seconds since a given epoch. The <code>time</code> function takes a single parameter that is a pointer to a structure into which to write the time. If that pointer is null, the function just returns the time:</p>

```c++
default_random_engine e1(time(0));  // a somewhat random seed
```

<p>Because <code>time</code> returns time as the number of seconds, this seed is useful only for applications that generate the seed at second-level, or longer, intervals.</p>

::: warning
<p>Warning</p>
<p>Using <code>time</code> as a seed usually doesn’t work if the program is run repeatedly as part of an automated process; it might wind up with the same seed several times.</p>
:::

::: info
<p>Exercises Section 17.4.1</p>
<p><strong>Exercise 17.28:</strong> Write a function that generates and returns a uniformly distributed random <code>unsigned int</code> each time it is called.</p>
<p><strong>Exercise 17.29:</strong> Allow the user to supply a seed as an optional argument to the function you wrote in the previous exercise.</p>
<p><strong>Exercise 17.30:</strong> Revise your function again this time to take a minimum and maximum value for the numbers that the function should return.</p>
:::

<h4 id="filepos4738594">17.4.2. Other Kinds of Distributions</h4>
<p>The engines produce <code>unsigned</code> numbers, and each number in the engine’s range has the same likelihood of being generated. Applications often need numbers of different types or distributions. The library handles both these needs by defining different distributions that, when used with an engine, produce the desired results. <a href="166-17.4._random_numbers.html#filepos4739302">Table 17.16</a> (overleaf) lists the operations supported by the distribution types.</p>
<p><a id="filepos4739302"></a>Table 17.16. Distribution Operations</p>
<img alt="Image" src="/images/00126.jpg"/>
<h5>Generating Random Real Numbers</h5>
<p>Programs often need a source of random floating-point values. In particular, programs frequently need random numbers between zero and one.</p>
<p>The most common, <em>but incorrect</em>, way to obtain a random floating-point from <code>rand</code> is to divide the result of <code>rand()</code> by <code>RAND_MAX</code>, which is a system-defined upper limit that is the largest random number that <code>rand</code> can return. This technique is incorrect because random integers usually have less precision than floating-point numbers, in which case there are some floating-point values that will never be produced as output.</p>
<p><a id="filepos4740542"></a>With the new library facilities, we can easily obtain a floating-point random number. We define an object of type <code>uniform_real_distribution</code> and let the library handle mapping random integers to random floating-point numbers. As we did for <code>uniform_int_distribution</code>, we specify the minimum and maximum values when we define the object:</p>

```c++
default_random_engine e; // generates unsigned random integers
// uniformly distributed from 0 to 1 inclusive
uniform_real_distribution<double> u(0,1);
for (size_t i = 0; i < 10; ++i)
    cout << u(e) << " ";
```

<p>This code is nearly identical to the previous program that generated <code>unsigned</code> values. However, because we used a different distribution type, this version generates different results:</p>

```c++
0.131538 0.45865 0.218959 0.678865 0.934693 0.519416 ...
```

<h5>Using the Distribution’s Default Result Type</h5>
<p>With one exception, which we’ll cover in § <a href="166-17.4._random_numbers.html#filepos4738594">17.4.2</a> (p. <a href="166-17.4._random_numbers.html#filepos4738594">752</a>), the distribution types are templates that have a single template type parameter that represents the type of the numbers that the distribution generates. These types always generate either a floating-point type or an integral type.</p>
<p>Each distribution template has a default template argument (§ <a href="154-16.1._defining_a_template.html#filepos4259709">16.1.3</a>, p. <a href="154-16.1._defining_a_template.html#filepos4259709">670</a>). The distribution types that generate floating-point values generate <code>double</code> by default. Distributions that generate integral results use <code>int</code> as their default. Because the distribution types have only one template parameter, when we want to use the default we must remember to follow the template’s name with empty angle brackets to signify that we want the default (§ <a href="154-16.1._defining_a_template.html#filepos4259709">16.1.3</a>, p. <a href="154-16.1._defining_a_template.html#filepos4259709">671</a>):</p>

```c++
// empty <> signify we want to use the default result type
uniform_real_distribution<> u(0,1); // generates double by default
```

<h5><a id="filepos4744864"></a>Generating Numbers That Are Not Uniformly Distributed</h5>
<p>In addition to correctly generating numbers in a specified range, another advantage of the new library is that we can obtain numbers that are nonuniformly distributed. Indeed, the library defines 20 distribution types! These types are listed in § <a href="190-a.3._random_numbers.html#filepos5496561">A.3</a> (p. <a href="190-a.3._random_numbers.html#filepos5496561">882</a>).</p>
<p>As an example, we’ll generate a series of normally distributed values and plot the resulting distribution. Because <code>normal_distribution</code> generates floating-point numbers, our program will use the <code>lround</code> function from the <code>cmath</code> header to round each result to its nearest integer. We’ll generate 200 numbers centered around a mean of 4 with a standard deviation of 1.5. Because we’re using a normal distribution, we can expect all but about 1 percent of the generated numbers to be in the range from 0 to 8, inclusive. Our program will count how many values appear that map to the integers in this range:</p>

```c++
default_random_engine e;        // generates random integers
normal_distribution<> n(4,1.5); // mean 4, standard deviation 1.5
vector<unsigned> vals(9);       // nine elements each 0
for (size_t i = 0; i != 200; ++i) {
    unsigned v = lround(n(e));  // round to the nearest integer
    if (v < vals.size())        // if this result is in range
        ++vals[v];              // count how often each number appears
}
for (size_t j = 0; j != vals.size(); ++j)
    cout << j << ": " << string(vals[j], '*') << endl;
```

<p>We start by defining our random generator objects and a <code>vector</code> named <code>vals</code>. We’ll use <code>vals</code> to count how often each number in the range 0 . . . 9 occurs. Unlike most of our programs that use <code>vector</code>, we allocate <code>vals</code> at its desired size. By doing so, we start out with each element initialized to 0.</p>
<p>Inside the <code>for</code> loop, we call <code>lround(n(e))</code> to round the value returned by <code>n(e)</code> to the nearest integer. Having obtained the integer that corresponds to our floating-point random number, we use that number to index our <code>vector</code> of counters. Because <code>n(e)</code> can produce a number outside the range 0 to 9, we check that the number we got is in range before using it to index <code>vals</code>. If the number is in range, we increment the associated counter.</p>
<p>When the loop completes, we print the contents of <code>vals</code>, which will generate output such as</p>

```c++
0: ***
1: ********
2: ********************
3: **************************************
4: **********************************************************
5: ******************************************
6: ***********************
7: *******
8: *
```

<p>Here we print a <code>string</code> with as many asterisks as the count of the times the current value was returned by our random-number generator. Note that this figure <a id="filepos4750946"></a>is not perfectly symmetrical. If it were, that symmetry should give us reason to suspect the quality of our random-number generator.</p>
<h5>The <code>bernoulli_distribution</code> Class</h5>
<p>We noted that there was one distribution that does not take a template parameter. That distribution is the <code>bernoulli_distribution</code>, which is an ordinary class, not a template. This distribution always returns a <code>bool</code> value. It returns <code>true</code> with a given probability. By default that probability is .5.</p>
<p>As an example of this kind of distribution, we might have a program that plays a game with a user. To play the game, one of the players—either the user or the program—has to go first. We could use a <code>uniform_int_distribution</code> object with a range of 0 to 1 to select the first player. Alternatively, we can use a Bernoulli distribution to make this choice. Assuming that we have a function named <code>play</code> that plays the game, we might have a loop such as the following to interact with the user:</p>

```c++
string resp;
default_random_engine e;  // e has state, so it must be outside the loop!
bernoulli_distribution b; // 50/50 odds by default
do {
    bool first = b(e);    // if true, the program will go first
    cout << (first ? "We go first"
                   : "You get to go first") << endl;
    // play the game passing the indicator of who goes first
    cout << ((play(first)) ? "sorry, you lost"
                           : "congrats, you won") << endl;
    cout << "play again? Enter 'yes' or 'no'" << endl;
} while (cin >> resp && resp[0] == 'y');
```

<p>We use a <code>do while</code> (§ <a href="057-5.4._iterative_statements.html#filepos1343100">5.4.4</a>, p. <a href="057-5.4._iterative_statements.html#filepos1343100">189</a>) to repeatedly prompt the user to play.</p>

::: warning
<p>Warning</p>
<p>Because engines return the same sequence of numbers (§ <a href="166-17.4._random_numbers.html#filepos4716290">17.4.1</a>, p. <a href="166-17.4._random_numbers.html#filepos4716290">747</a>), it is essential that we declare engines outside of loops. Otherwise, we’d create a new engine on each iteration and generate the same values on each iteration. Similarly, distributions may retain state and should also be defined outside loops.</p>
:::

<p>One reason to use a <code>bernoulli_distribution</code> in this program is that doing so lets us give the program a better chance of going first:</p>

```c++
bernoulli_distribution b(.55); // give the house a slight edge
```

<p>If we use this definition for <code>b</code>, then the program has 55/45 odds of going first.</p>
